<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TestIQ Analysis Report</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
            padding: 20px;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 40px;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .timestamp {
            color: #7f8c8d;
            font-size: 0.9em;
            margin-bottom: 30px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        .stat-card {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .stat-card.danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .stat-card.success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        .stat-card.warning {
            background: linear-gradient(135deg, #f7971e 0%, #ffd200 100%);
        }
        .stat-card.info {
            background: linear-gradient(135deg, #00c6ff 0%, #0072ff 100%);
        }
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        h2 {
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #00c6ff;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
            background: white;
        }
        th {
            background: #00c6ff;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        td {
            padding: 12px;
            border-bottom: 1px solid #ecf0f1;
            word-break: break-word;
            overflow-wrap: break-word;
            max-width: 400px;
        }
        tr:hover {
            background: #f8f9fa;
        }
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }
        .badge-danger {
            background: #fee;
            color: #c33;
        }
        .badge-warning {
            background: #ffeaa7;
            color: #d63031;
        }
        .badge-info {
            background: #dfe6e9;
            color: #2d3436;
        }
        .test-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            border-left: 4px solid #00c6ff;
        }
        .test-name {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            background: #ecf0f1;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
            max-width: 100%;
            line-height: 1.6;
        }
        .test-name .test-part {
            display: inline;
        }
        .test-name .test-separator {
            color: #3498db;
            font-weight: bold;
            margin: 0 2px;
        }
        .action {
            color: #27ae60;
            font-weight: 600;
        }
        .footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9em;
        }
        .clickable-row {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .clickable-row:hover {
            background: #e8f4f8 !important;
            transform: translateX(3px);
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            animation: fadeIn 0.3s;
        }
        .modal-content {
            background-color: white;
            margin: 10px auto;
            padding: 0;
            width: calc(100% - 20px);
            height: calc(100vh - 20px);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .modal-header {
            padding: 20px;
            background: linear-gradient(135deg, #00c6ff 0%, #764ba2 100%);
            color: white;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .close {
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            transition: transform 0.2s;
        }
        .close:hover {
            transform: scale(1.2);
        }
        .split-view {
            display: flex;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
        }
        .split-view.independent {
            overflow: hidden;
        }
        .file-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 2px solid #ecf0f1;
            min-width: 0;
        }
        .file-panel.independent {
            overflow-y: auto;
        }
        .file-panel:last-child {
            border-right: none;
        }
        .panel-header {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 2px solid #ecf0f1;
            font-weight: 600;
            color: #2c3e50;
            position: sticky;
            top: 0;
            z-index: 10;
            flex-shrink: 0;
        }
        .file-content {
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.8;
            background: #fafafa;
        }
        .code-line {
            padding: 2px 8px;
            border-radius: 3px;
            margin: 1px 0;
            white-space: pre;
        }
        .covered {
            background: #d4edda;
            border-left: 3px solid #28a745;
            font-weight: 600;
        }
        .not-covered {
            opacity: 0.6;
        }
        .file-path {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #7f8c8d;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .coverage-info {
            background: #e8f4f8;
            padding: 15px;
            margin: 10px 20px;
            border-left: 4px solid #00c6ff;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        .filter-section {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .filter-select {
            padding: 6px 10px;
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            font-size: 0.85em;
            background: rgba(255,255,255,0.95);
            cursor: pointer;
            min-width: 180px;
            color: #2c3e50;
        }
        .filter-select:hover {
            background: white;
            border-color: white;
        }
        .sync-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(255,255,255,0.95);
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
            color: #2c3e50;
        }
        .sync-toggle:hover {
            background: white;
            border-color: white;
            background: #f0f0ff;
        }
        .sync-toggle.active {
            background: #00c6ff;
            color: white;
        }
        .sync-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
            border-left: 4px solid #00c6ff;
            border-radius: 4px;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .progress-bar {
            height: 30px;
            background: #ecf0f1;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00c6ff 0%, #0072ff 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            transition: width 0.3s ease;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin: 30px 0 20px 0;
            border-bottom: 2px solid #ecf0f1;
        }
        .tab {
            padding: 12px 24px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            color: #7f8c8d;
            transition: all 0.3s ease;
            position: relative;
            bottom: -2px;
        }
        .tab:hover {
            background: #e9ecef;
            color: #495057;
        }
        .tab.active {
            background: white;
            color: #00c6ff;
            border-bottom: 2px solid #00c6ff;
        }
        .tab-content {
            display: none;
            animation: fadeIn 0.3s;
        }
        .tab-content.active {
            display: block;
        }
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }
        .page-btn {
            padding: 8px 12px;
            background: #00c6ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .page-btn:hover:not(:disabled) {
            background: #0088cc;
            transform: translateY(-2px);
        }
        .page-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .page-info {
            color: #7f8c8d;
            font-weight: 600;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #00c6ff;
        }
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #00c6ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ TestIQ Analysis Report</h1>
        <div class="timestamp">Generated on 2026-01-13 17:16:14</div>
        
        <div class="stats">
            <div class="stat-card" onclick="switchTab('exact')">
                <div class="stat-value">224</div>
                <div class="stat-label">Total Test Methods</div>
            </div>
            <div class="stat-card danger" onclick="switchTab('exact')">
                <div class="stat-value">3</div>
                <div class="stat-label">Duplicates</div>
            </div>
            <div class="stat-card info" onclick="switchTab('similar')">
                <div class="stat-value">203</div>
                <div class="stat-label">Similar Test Pairs</div>
            </div>
            <div class="stat-card warning" onclick="switchTab('subset')">
                <div class="stat-value">715</div>
                <div class="stat-label">Subset Duplicates</div>
            </div>
            <div class="stat-card success">
                <div class="stat-value">32.9%</div>
                <div class="stat-label">Lines Covered</div>
            </div>
            <div class="stat-card warning">
                <div class="stat-value">67.1%</div>
                <div class="stat-label">Lines Uncovered</div>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" style="width: 1.3%">
                1.3%
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('exact')">üéØ Exact Duplicates (3)</button>
            <button class="tab" onclick="switchTab('similar')">üîç Similar Tests (203)</button>
            <button class="tab" onclick="switchTab('subset')">üìä Subset Duplicates (715)</button>
        </div>

        <div id="exact-content" class="tab-content active">
            <h2>üéØ Exact Duplicates</h2>
            <p>Tests with identical code coverage that can be safely removed.</p>
            <div id="exact-table"></div>
            <div id="exact-pagination" class="pagination"></div>
        </div>

        <div id="similar-content" class="tab-content">
            <h2>üîç Similar Tests (‚â•70% overlap)</h2>
            <p>Test pairs with significant code coverage overlap that may indicate redundancy.</p>
            <div id="similar-table"></div>
            <div id="similar-pagination" class="pagination"></div>
        </div>

        <div id="subset-content" class="tab-content">
            <h2>üìä Subset Duplicates</h2>
            <p>Tests that are subsets of other tests and may be redundant.</p>
            <div id="subset-table"></div>
            <div id="subset-pagination" class="pagination"></div>
        </div>

        <script>
        // Utility function for escaping HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Utility function to format test names with separators
        function formatTestName(testName) {
            // Split test name at :: for better readability
            const parts = testName.split('::');
            if (parts.length === 1) return testName;
            
            return parts.map((part, idx) => {
                if (idx === parts.length - 1) {
                    return '<span class="test-part">' + part + '</span>';
                }
                return '<span class="test-part">' + part + '</span><span class="test-separator">::</span><wbr>';
            }).join('');
        }
        
        // Data for pagination
        const exactDupsData = [[["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage"], 0], [["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates"], 1], [["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results"], 2]];
        const similarData = [["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.9764705882352941, 3], ["tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.9615384615384616, 4], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.9613899613899614, 5], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.9578544061302682, 6], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.9576923076923077, 7], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.9552238805970149, 8], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.9552238805970149, 9], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.9504950495049505, 10], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", 0.9482758620689655, 11], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.9433962264150944, 12], ["tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails", 0.9248554913294798, 13], ["tests/test_cli.py::TestCLIConfig::test_log_level_option", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.922509225092251, 14], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.9222222222222223, 15], ["tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.921875, 16], ["tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.9090909090909091, 17], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", 0.9076923076923077, 18], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results", 0.9076923076923077, 19], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.9057971014492754, 20], ["tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.9038461538461539, 21], ["tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.9030612244897959, 22], ["tests/test_cicd.py::TestQualityGateChecker::test_fails_max_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_passes_max_duplicates", 0.9006211180124224, 23], ["tests/test_cicd.py::TestQualityGateChecker::test_passes_max_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_percentage", 0.9, 24], ["tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.8984771573604061, 25], ["tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", "tests/test_cicd.py::TestQualityGateChecker::test_passes_max_duplicates", 0.8950617283950617, 26], ["tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", 0.8881578947368421, 27], ["tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.881578947368421, 28], ["tests/test_cli.py::TestCLI::test_analyze_json_format", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.8805970149253731, 29], ["tests/test_cicd.py::TestQualityGateChecker::test_fails_max_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_percentage", 0.8787878787878788, 30], ["tests/test_cli.py::TestCLI::test_analyze_with_all_options", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.8659003831417624, 31], ["tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_percentage", 0.8622754491017964, 32], ["tests/test_cli.py::TestCLI::test_analyze_json_format", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.8598484848484849, 33], ["tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.857566765578635, 34], ["tests/test_cli.py::TestCLIQualityGate::test_save_baseline", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.8561643835616438, 35], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.8556701030927835, 36], ["tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_duplicates", 0.8520710059171598, 37], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_security.py::TestValidateCoverageData::test_valid_at_line_limit", 0.85, 38], ["tests/test_reporting.py::TestHTMLReportGenerator::test_generate_html_report", "tests/test_reporting.py::TestHTMLReportGenerator::test_html_report_stats_cards", 0.8477366255144033, 39], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.8469945355191257, 40], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_invalid_line_numbers", "tests/test_security.py::TestValidateCoverageData::test_non_integer_line_number", 0.8461538461538461, 41], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_invalid_line_numbers", "tests/test_security.py::TestValidateCoverageData::test_invalid_line_number", 0.8461538461538461, 42], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_invalid_line_numbers", "tests/test_security.py::TestValidateCoverageData::test_negative_line_number", 0.8461538461538461, 43], ["tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.8445945945945946, 44], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.8417508417508418, 45], ["tests/test_cli.py::TestCLI::test_analyze_with_all_options", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.8398576512455516, 46], ["tests/test_cli.py::TestCLI::test_analyze_with_all_options", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.8388278388278388, 47], ["tests/test_cicd.py::TestQualityGateChecker::test_passes_max_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_fails_on_increase", 0.8372093023255814, 48], ["tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.8366013071895425, 49], ["tests/test_cli.py::TestCLI::test_analyze_json_format", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.8333333333333334, 50], ["tests/test_cicd.py::TestQualityGateChecker::test_fails_max_percentage", "tests/test_cicd.py::TestQualityGateChecker::test_fails_on_increase", 0.8285714285714286, 51], ["tests/test_cli.py::TestCLI::test_analyze_json_format", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.8280701754385965, 52], ["tests/test_enterprise.py::TestPerformance::test_parallel_processor", "tests/test_performance.py::TestParallelProcessor::test_map_parallel_thread", 0.8214285714285714, 53], ["tests/test_cicd.py::TestQualityGateChecker::test_fails_max_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_fails_on_increase", 0.8192090395480226, 54], ["tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.81875, 55], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_empty", "tests/test_security.py::TestValidateCoverageData::test_empty_coverage_data", 0.8181818181818182, 56], ["tests/test_cli.py::TestCLI::test_analyze_stdout_output", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.8178438661710037, 57], ["tests/test_cli.py::TestCLIQualityGate::test_save_baseline", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.8143322475570033, 58], ["tests/test_cli.py::TestCLI::test_analyze_stdout_output", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.8129496402877698, 59], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_dangerous_pattern", "tests/test_security.py::TestValidateFilePath::test_path_traversal_attack", 0.8125, 60], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_dangerous_pattern", "tests/test_security.py::TestValidateFilePath::test_tilde_expansion", 0.8125, 61], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_dangerous", "tests/test_security.py::TestSanitizeOutputPath::test_dangerous_pattern_in_path", 0.8125, 62], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_invalid_extension", "tests/test_security.py::TestValidateFilePath::test_invalid_extension", 0.8095238095238095, 63], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_security.py::TestValidateCoverageData::test_valid_coverage_data", 0.8095238095238095, 64], ["tests/test_cli.py::TestCLI::test_analyze_stdout_output", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.8081180811808119, 65], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.8074074074074075, 66], ["tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", "tests/test_cicd.py::TestQualityGateChecker::test_fails_on_increase", 0.8044692737430168, 67], ["tests/test_enterprise.py::TestPerformance::test_cache_manager", "tests/test_performance.py::TestCacheManager::test_set_and_get", 0.8, 68], ["tests/test_cli.py::TestCLI::test_analyze_nonexistent_file", "tests/test_cli.py::TestCLIBaseline::test_baseline_delete_nonexistent", 0.7976190476190477, 69], ["tests/test_cli.py::TestCLI::test_analyze_stdout_output", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.7963636363636364, 70], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.7934782608695652, 71], ["tests/test_cli.py::TestCLI::test_analyze_stdout_output", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.7898550724637681, 72], ["tests/test_cli.py::TestCLIIntegration::test_full_workflow", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.7896551724137931, 73], ["tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", 0.7891566265060241, 74], ["tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", 0.7861271676300579, 75], ["tests/test_security.py::TestValidateCoverageData::test_invalid_line_number", "tests/test_security.py::TestValidateCoverageData::test_negative_line_number", 0.7857142857142857, 76], ["tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", 0.7848837209302325, 77], ["tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.7844311377245509, 78], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.7815533980582524, 79], ["tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.7793427230046949, 80], ["tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.7772727272727272, 81], ["tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.7763975155279503, 82], ["tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.7757009345794392, 83], ["tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.7757009345794392, 84], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.7737556561085973, 85], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.7737556561085973, 86], ["tests/test_cli.py::TestCLIConfig::test_custom_config_file", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.7737226277372263, 87], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.7728937728937729, 88], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.772093023255814, 89], ["tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.772093023255814, 90], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.772093023255814, 91], ["tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.7716049382716049, 92], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.7703180212014135, 93], ["tests/test_cli.py::TestCLI::test_analyze_nonexistent_file", "tests/test_cli.py::TestCLIBaseline::test_baseline_list_empty", 0.7701149425287356, 94], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_too_many_tests", "tests/test_security.py::TestValidateCoverageData::test_too_many_tests", 0.7692307692307693, 95], ["tests/test_enterprise.py::TestPerformance::test_parallel_processor_disabled", "tests/test_performance.py::TestParallelProcessor::test_map_empty_list", 0.7692307692307693, 96], ["tests/test_enterprise.py::TestPerformance::test_parallel_processor_disabled", "tests/test_performance.py::TestParallelProcessor::test_map_single_item", 0.7692307692307693, 97], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", 0.7685185185185185, 98], ["tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.7685185185185185, 99], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.7676767676767676, 100], ["tests/test_cli.py::TestCLI::test_analyze_stdout_output", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.7657342657342657, 101], ["tests/test_cli.py::TestCLI::test_analyze_with_all_options", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.7649122807017544, 102], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_dangerous_pattern", "tests/test_security.py::TestValidateFilePath::test_dangerous_pattern_windows_backslash", 0.7647058823529411, 103], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_too_large", "tests/test_security.py::TestCheckFileSize::test_file_exceeds_limit", 0.7647058823529411, 104], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", 0.7638190954773869, 105], ["tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", 0.7627118644067796, 106], ["tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.762589928057554, 107], ["tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.7614678899082569, 108], ["tests/test_cli.py::TestCLI::test_analyze_json_format", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.7604166666666666, 109], ["tests/test_cli.py::TestCLI::test_analyze_markdown_format", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.7601351351351351, 110], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_invalid_structure", "tests/test_security.py::TestValidateCoverageData::test_non_list_lines", 0.76, 111], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.7598566308243727, 112], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.759581881533101, 113], ["tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.7579908675799086, 114], ["tests/test_cli.py::TestCLI::test_analyze_markdown_format", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.7577854671280276, 115], ["tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", 0.7572254335260116, 116], ["tests/test_cli.py::TestCLI::test_analyze_json_format", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.7558528428093646, 117], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.7545454545454545, 118], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.7545454545454545, 119], ["tests/test_cli.py::TestCLI::test_analyze_with_all_options", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.754325259515571, 120], ["tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.7528089887640449, 121], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.7524271844660194, 122], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.7517241379310344, 123], ["tests/test_cli.py::TestCLI::test_analyze_json_format", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.75, 124], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_security.py::TestValidateFilePath::test_nonexistent_file_without_check", 0.75, 125], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.7487684729064039, 126], ["tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.7485029940119761, 127], ["tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", 0.7485029940119761, 128], ["tests/test_cli.py::TestCLI::test_analyze_with_all_options", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.7482758620689656, 129], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.7474402730375427, 130], ["tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.7471264367816092, 131], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.7465753424657534, 132], ["tests/test_cli.py::TestCLIFormats::test_csv_format", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.7465753424657534, 133], ["tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.746031746031746, 134], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.7457044673539519, 135], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.7450980392156863, 136], ["tests/test_cli.py::TestCLI::test_analyze_json_format", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.7440273037542662, 137], ["tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", 0.7421052631578947, 138], ["tests/test_cli.py::TestCLI::test_analyze_invalid_json", "tests/test_cli.py::TestCLIErrorHandling::test_invalid_coverage_structure", 0.7419354838709677, 139], ["tests/test_cli.py::TestCLIErrorHandling::test_invalid_coverage_structure", "tests/test_cli.py::TestCLIErrorHandling::test_security_violation", 0.7419354838709677, 140], ["tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.7414634146341463, 141], ["tests/test_cli.py::TestCLIBaseline::test_baseline_list_empty", "tests/test_cli.py::TestCLIBaseline::test_baseline_delete_nonexistent", 0.7395833333333334, 142], ["tests/test_cli.py::TestCLIFormats::test_csv_format", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.7364864864864865, 143], ["tests/test_cli.py::TestCLI::test_analyze_nonexistent_file", "tests/test_cli.py::TestCLIBaseline::test_baseline_show_nonexistent", 0.7362637362637363, 144], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.734006734006734, 145], ["tests/test_cli.py::TestCLIConfig::test_custom_config_file", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.7335640138408305, 146], ["tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.7325227963525835, 147], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.7317073170731707, 148], ["tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.7282608695652174, 149], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.7272727272727273, 150], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_security.py::TestSanitizeOutputPath::test_valid_output_path", 0.7272727272727273, 151], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_security.py::TestSanitizeOutputPath::test_no_allowed_dirs_restriction", 0.7272727272727273, 152], ["tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.7268041237113402, 153], ["tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.7268041237113402, 154], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.7266666666666667, 155], ["tests/test_cli.py::TestCLI::test_analyze_with_all_options", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.7266666666666667, 156], ["tests/test_cli.py::TestCLI::test_analyze_invalid_json", "tests/test_cli.py::TestCLIErrorHandling::test_security_violation", 0.7264957264957265, 157], ["tests/test_security.py::TestValidateCoverageData::test_non_integer_line_number", "tests/test_security.py::TestValidateCoverageData::test_invalid_line_number", 0.7241379310344828, 158], ["tests/test_security.py::TestValidateCoverageData::test_non_integer_line_number", "tests/test_security.py::TestValidateCoverageData::test_negative_line_number", 0.7241379310344828, 159], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.7238095238095238, 160], ["tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.7237237237237237, 161], ["tests/test_cli.py::TestCLI::test_analyze_markdown_format", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.7236842105263158, 162], ["tests/test_cli.py::TestCLIIntegration::test_full_workflow", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.7235494880546075, 163], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.723404255319149, 164], ["tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", 0.7230769230769231, 165], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.7227722772277227, 166], ["tests/test_cli.py::TestCLI::test_analyze_json_format", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.7227722772277227, 167], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.7226027397260274, 168], ["tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.7218543046357616, 169], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.7215568862275449, 170], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", 0.7209302325581395, 171], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", 0.7209302325581395, 172], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", 0.7209302325581395, 173], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", 0.7209302325581395, 174], ["tests/test_cli.py::TestCLI::test_analyze_markdown_format", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.7203947368421053, 175], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", 0.7203791469194313, 176], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.7203791469194313, 177], ["tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", 0.7191011235955056, 178], ["tests/test_cli.py::TestCLI::test_analyze_markdown_format", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.7188498402555911, 179], ["tests/test_enterprise.py::TestPerformance::test_parallel_processor", "tests/test_performance.py::TestParallelProcessor::test_map_parallel_process", 0.71875, 180], ["tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", "tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", 0.7183908045977011, 181], ["tests/test_cli.py::TestCLI::test_analyze_markdown_format", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.7142857142857143, 182], ["tests/test_cli.py::TestCLIIntegration::test_full_workflow", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.7138047138047138, 183], ["tests/test_cli.py::TestCLI::test_analyze_stdout_output", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.7133550488599348, 184], ["tests/test_reporting.py::TestCSVReportGenerator::test_generate_exact_duplicates_csv", "tests/test_reporting.py::TestCSVReportGenerator::test_csv_valid_format", 0.7127659574468085, 185], ["tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.7124183006535948, 186], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.7119741100323624, 187], ["tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.7101449275362319, 188], ["tests/test_cli.py::TestCLI::test_analyze_command", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.7100977198697068, 189], ["tests/test_cli.py::TestCLIFormats::test_csv_format", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.7100977198697068, 190], ["tests/test_cli.py::TestCLIBaseline::test_baseline_show_nonexistent", "tests/test_cli.py::TestCLIBaseline::test_baseline_delete_nonexistent", 0.71, 191], ["tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.7085427135678392, 192], ["tests/test_security.py::TestValidateCoverageData::test_valid_coverage_data", "tests/test_security.py::TestValidateCoverageData::test_valid_at_line_limit", 0.7083333333333334, 193], ["tests/test_cli.py::TestCLIIntegration::test_full_workflow", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.7080536912751678, 194], ["tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.7070422535211267, 195], ["tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.7068403908794788, 196], ["tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", 0.7067307692307693, 197], ["tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.7067307692307693, 198], ["tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.7037037037037037, 199], ["tests/test_cli.py::TestCLI::test_analyze_markdown_format", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.7032258064516129, 200], ["tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.703030303030303, 201], ["tests/test_cli.py::TestCLI::test_analyze_with_threshold", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.7021276595744681, 202], ["tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.7005813953488372, 203], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.7004608294930875, 204], ["tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.7004608294930875, 205]];
        const subsetData = [["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage", 0.9076923076923077, 206], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results", 0.9076923076923077, 207], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_security.py::TestValidateCoverageData::test_valid_at_line_limit", 0.85, 208], ["tests/test_enterprise.py::TestPerformance::test_parallel_processor", "tests/test_performance.py::TestParallelProcessor::test_map_parallel_thread", 0.8214285714285714, 209], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_empty", "tests/test_security.py::TestValidateCoverageData::test_empty_coverage_data", 0.8181818181818182, 210], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_dangerous_pattern", "tests/test_security.py::TestValidateFilePath::test_path_traversal_attack", 0.8125, 211], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_dangerous_pattern", "tests/test_security.py::TestValidateFilePath::test_tilde_expansion", 0.8125, 212], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_dangerous", "tests/test_security.py::TestSanitizeOutputPath::test_dangerous_pattern_in_path", 0.8125, 213], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_invalid_extension", "tests/test_security.py::TestValidateFilePath::test_invalid_extension", 0.8095238095238095, 214], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_security.py::TestValidateCoverageData::test_valid_coverage_data", 0.8095238095238095, 215], ["tests/test_enterprise.py::TestPerformance::test_cache_manager", "tests/test_performance.py::TestCacheManager::test_set_and_get", 0.8, 216], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_too_many_tests", "tests/test_security.py::TestValidateCoverageData::test_too_many_tests", 0.7692307692307693, 217], ["tests/test_enterprise.py::TestPerformance::test_parallel_processor_disabled", "tests/test_performance.py::TestParallelProcessor::test_map_empty_list", 0.7692307692307693, 218], ["tests/test_enterprise.py::TestPerformance::test_parallel_processor_disabled", "tests/test_performance.py::TestParallelProcessor::test_map_single_item", 0.7692307692307693, 219], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_dangerous_pattern", "tests/test_security.py::TestValidateFilePath::test_dangerous_pattern_windows_backslash", 0.7647058823529411, 220], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_too_large", "tests/test_security.py::TestCheckFileSize::test_file_exceeds_limit", 0.7647058823529411, 221], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_security.py::TestValidateFilePath::test_nonexistent_file_without_check", 0.75, 222], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_security.py::TestSanitizeOutputPath::test_valid_output_path", 0.7272727272727273, 223], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_security.py::TestSanitizeOutputPath::test_no_allowed_dirs_restriction", 0.7272727272727273, 224], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", 0.7209302325581395, 225], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", 0.7209302325581395, 226], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", 0.7209302325581395, 227], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", 0.7209302325581395, 228], ["tests/test_enterprise.py::TestPerformance::test_parallel_processor", "tests/test_performance.py::TestParallelProcessor::test_map_parallel_process", 0.71875, 229], ["tests/test_enterprise.py::TestPerformance::test_parallel_processor", "tests/test_performance.py::TestParallelProcessor::test_map_with_error", 0.696969696969697, 230], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_enterprise.py::TestExceptions::test_error_codes", 0.6666666666666666, 231], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_empty", 0.6666666666666666, 232], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_security.py::TestValidateFilePath::test_valid_json_file", 0.6428571428571429, 233], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_security.py::TestValidateFilePath::test_valid_yaml_file", 0.6428571428571429, 234], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_security.py::TestValidateFilePath::test_valid_yml_file", 0.6428571428571429, 235], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_performance.py::TestComputeSimilarity::test_identical_sets", 0.6363636363636364, 236], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_performance.py::TestComputeSimilarity::test_no_overlap", 0.6363636363636364, 237], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_performance.py::TestComputeSimilarity::test_partial_overlap", 0.6363636363636364, 238], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_performance.py::TestComputeSimilarity::test_subset", 0.6363636363636364, 239], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_similar_tests_csv", 0.6276595744680851, 240], ["tests/test_enterprise.py::TestPerformance::test_parallel_processor_disabled", "tests/test_performance.py::TestParallelProcessor::test_map_sequential", 0.625, 241], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateCoverageData::test_non_dict_coverage_data", 0.6, 242], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_empty_finder", "tests/test_analysis.py::TestQualityAnalyzer::test_empty_finder_score", 0.5882352941176471, 243], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_security.py::TestValidateCoverageData::test_too_many_lines", 0.5862068965517241, 244], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_performance.py::TestComputeSimilarity::test_caching", 0.5833333333333334, 245], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_security.py::TestCheckFileSize::test_file_within_limit", 0.5714285714285714, 246], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_security.py::TestCheckFileSize::test_file_at_exact_limit", 0.5714285714285714, 247], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_security.py::TestCheckFileSize::test_default_max_size", 0.5714285714285714, 248], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_subset_duplicates_csv", 0.57, 249], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_subset_duplicates_csv", 0.56, 250], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", 0.5535714285714286, 251], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", 0.5535714285714286, 252], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateCoverageData::test_empty_coverage_data", 0.5454545454545454, 253], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", 0.543859649122807, 254], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", 0.543859649122807, 255], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_exact_duplicates_csv", 0.5375, 256], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_exact_duplicates_csv", 0.5375, 257], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_reporting.py::TestCSVReportGenerator::test_csv_valid_format", 0.5308641975308642, 258], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_reporting.py::TestCSVReportGenerator::test_csv_valid_format", 0.5308641975308642, 259], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", 0.5254237288135594, 260], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", 0.5254237288135594, 261], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestTestCoverage::test_test_coverage_hash", 0.5, 262], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestConfig::test_default_config", 0.5, 263], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestLogging::test_get_logger", 0.5, 264], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestConstants::test_max_tests", 0.5, 265], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestConstants::test_max_lines_per_file", 0.5, 266], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage", 0.47692307692307695, 267], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results", 0.47692307692307695, 268], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage", 0.47692307692307695, 269], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results", 0.47692307692307695, 270], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestCheckFileSize::test_nonexistent_file", 0.46153846153846156, 271], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_enterprise.py::TestLogging::test_setup_logging_with_file", 0.45161290322580644, 272], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_empty_finder", "tests/test_reporting.py::TestCSVReportGenerator::test_csv_report_empty_finder", 0.4225352112676056, 273], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_generate_report", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.4059040590405904, 274], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.4, 275], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateCoverageData::test_non_string_test_name", 0.4, 276], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_security.py::TestSanitizeOutputPath::test_allowed_directory", 0.4, 277], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", 0.3971631205673759, 278], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_summary_csv", 0.3958333333333333, 279], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_generate_report", 0.39090909090909093, 280], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_generate_report", 0.39090909090909093, 281], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_empty_finder", "tests/test_analysis.py::TestRecommendationEngine::test_empty_finder_recommendations", 0.38961038961038963, 282], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_summary_csv", 0.3888888888888889, 283], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_exact_duplicates_csv", 0.3875, 284], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_exact_duplicates_csv", 0.3875, 285], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", 0.3835616438356164, 286], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.3835616438356164, 287], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_reporting.py::TestCSVReportGenerator::test_csv_valid_format", 0.38271604938271603, 288], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_reporting.py::TestCSVReportGenerator::test_csv_valid_format", 0.38271604938271603, 289], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateCoverageData::test_empty_test_name", 0.375, 290], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cicd.py::TestQualityGateChecker::test_passes_max_duplicates", 0.37333333333333335, 291], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", 0.3708609271523179, 292], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_percentage", 0.36363636363636365, 293], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", 0.36075949367088606, 294], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_duplicates", 0.358974358974359, 295], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", 0.35668789808917195, 296], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", 0.35443037974683544, 297], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateFilePath::test_nonexistent_file_with_check", 0.35294117647058826, 298], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", 0.3373493975903614, 299], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cicd.py::TestQualityGateChecker::test_fails_on_increase", 0.3373493975903614, 300], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestConstants::test_max_file_size", 0.3333333333333333, 301], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateCoverageData::test_non_dict_coverage", 0.3333333333333333, 302], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_security.py::TestSanitizeOutputPath::test_multiple_allowed_directories", 0.3333333333333333, 303], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_similar_tests_csv", 0.32978723404255317, 304], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_similar_tests_csv", 0.32978723404255317, 305], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.32558139534883723, 306], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_empty_finder", "tests/test_reporting.py::TestHTMLReportGenerator::test_html_report_empty_finder", 0.3191489361702128, 307], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_subset_duplicates_csv", 0.31, 308], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_subset_duplicates_csv", 0.31, 309], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_enterprise.py::TestSecurity::test_check_file_size_too_large", 0.3076923076923077, 310], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.30714285714285716, 311], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.30714285714285716, 312], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", 0.3049645390070922, 313], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", 0.3049645390070922, 314], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.30434782608695654, 315], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", 0.3027027027027027, 316], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateCoverageData::test_non_string_file_name", 0.3, 317], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_summary_csv", 0.2986111111111111, 318], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_summary_csv", 0.2986111111111111, 319], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.2962962962962963, 320], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", 0.2945205479452055, 321], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", 0.2945205479452055, 322], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.2945205479452055, 323], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.2945205479452055, 324], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.29081632653061223, 325], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", 0.2893401015228426, 326], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.2893401015228426, 327], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.28717948717948716, 328], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_passes_max_duplicates", 0.2866666666666667, 329], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_passes_max_duplicates", 0.2866666666666667, 330], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.2857142857142857, 331], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_enterprise.py::TestConfig::test_config_from_dict", 0.2857142857142857, 332], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", 0.2847682119205298, 333], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", 0.2847682119205298, 334], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", 0.28426395939086296, 335], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.28426395939086296, 336], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_generate_report", 0.2818181818181818, 337], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_generate_report", 0.2818181818181818, 338], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_percentage", 0.2792207792207792, 339], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_percentage", 0.2792207792207792, 340], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_duplicates", 0.27564102564102566, 341], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_duplicates", 0.27564102564102566, 342], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage", "tests/test_cli.py::TestCLI::test_demo_command", 0.2754237288135593, 343], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results", "tests/test_cli.py::TestCLI::test_demo_command", 0.2754237288135593, 344], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", 0.27388535031847133, 345], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", 0.27388535031847133, 346], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_invalid_structure", 0.2727272727272727, 347], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateCoverageData::test_non_list_lines", 0.2727272727272727, 348], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", 0.2721518987341772, 349], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", 0.2721518987341772, 350], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "tests/test_reporting.py::TestHTMLReportGenerator::test_html_report_stats_cards", 0.2638888888888889, 351], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_invalid_line_numbers", 0.2608695652173913, 352], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_reporting.py::TestHTMLReportGenerator::test_html_report_stats_cards", 0.25925925925925924, 353], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", 0.25903614457831325, 354], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", 0.25903614457831325, 355], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_fails_on_increase", 0.25903614457831325, 356], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cicd.py::TestQualityGateChecker::test_fails_on_increase", 0.25903614457831325, 357], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.25, 358], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.25, 359], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", "tests/test_cli.py::TestCLI::test_demo_command", 0.25, 360], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestGetExitCode::test_exit_code_gate_failed", 0.25, 361], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", 0.25, 362], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestConstants::test_dangerous_patterns", 0.25, 363], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "tests/test_reporting.py::TestHTMLReportGenerator::test_generate_html_report", 0.2446351931330472, 364], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "tests/test_cli.py::TestCLI::test_demo_command", 0.24152542372881355, 365], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_reporting.py::TestHTMLReportGenerator::test_generate_html_report", 0.24034334763948498, 366], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateCoverageData::test_non_integer_line_number", 0.24, 367], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateCoverageData::test_invalid_line_number", 0.24, 368], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_security.py::TestValidateCoverageData::test_negative_line_number", 0.24, 369], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLI::test_demo_command", 0.23728813559322035, 370], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.23628691983122363, 371], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_security.py::TestCheckFileSize::test_file_exceeds_limit", 0.23529411764705882, 372], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.23369565217391305, 373], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.23369565217391305, 374], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", 0.23243243243243245, 375], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", 0.23243243243243245, 376], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.2275132275132275, 377], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.2275132275132275, 378], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.224, 379], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.22310756972111553, 380], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.2222222222222222, 381], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.22142857142857142, 382], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.22142857142857142, 383], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.22134387351778656, 384], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.2209737827715356, 385], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.2205128205128205, 386], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.2205128205128205, 387], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.2204724409448819, 388], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", 0.2198581560283688, 389], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", 0.2198581560283688, 390], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.2193877551020408, 391], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.2193877551020408, 392], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", 0.2182741116751269, 393], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", 0.2182741116751269, 394], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.2182741116751269, 395], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.2182741116751269, 396], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.2178988326848249, 397], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.2178988326848249, 398], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLI::test_analyze_command", 0.21705426356589147, 399], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_summary_csv", 0.2152777777777778, 400], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_summary_csv", 0.2152777777777778, 401], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", 0.21232876712328766, 402], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", 0.21232876712328766, 403], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.21232876712328766, 404], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.21232876712328766, 405], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.20973782771535582, 406], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.208955223880597, 407], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cicd.py::TestQualityGateChecker::test_passes_max_duplicates", 0.20666666666666667, 408], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cicd.py::TestQualityGateChecker::test_passes_max_duplicates", 0.20666666666666667, 409], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.2066420664206642, 410], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.2066420664206642, 411], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", 0.2052980132450331, 412], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", 0.2052980132450331, 413], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLI::test_analyze_nonexistent_file", 0.2028985507246377, 414], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_percentage", 0.2012987012987013, 415], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_percentage", 0.2012987012987013, 416], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestGetExitCode::test_exit_code_success", 0.2, 417], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestGetExitCode::test_exit_code_duplicates_found", 0.2, 418], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestGetExitCode::test_exit_code_gate_failed_priority", 0.2, 419], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_version", 0.2, 420], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestBatchIterator::test_empty_list", 0.2, 421], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestConstants::test_allowed_extensions", 0.2, 422], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_reporting.py::TestHTMLReportGenerator::test_html_report_stats_cards", 0.19907407407407407, 423], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_reporting.py::TestHTMLReportGenerator::test_html_report_stats_cards", 0.19907407407407407, 424], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_duplicates", 0.1987179487179487, 425], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_duplicates", 0.1987179487179487, 426], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", 0.19745222929936307, 427], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", 0.19745222929936307, 428], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", 0.1962025316455696, 429], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", 0.1962025316455696, 430], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.19377162629757785, 431], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_enterprise.py::TestConfig::test_load_config_yaml", 0.1891891891891892, 432], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", 0.18674698795180722, 433], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", 0.18674698795180722, 434], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cicd.py::TestQualityGateChecker::test_fails_on_increase", 0.18674698795180722, 435], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", 0.18674698795180722, 436], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cicd.py::TestQualityGateChecker::test_fails_on_increase", 0.18674698795180722, 437], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", 0.18674698795180722, 438], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails", 0.18562874251497005, 439], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails", 0.18562874251497005, 440], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.18454935622317598, 441], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_reporting.py::TestHTMLReportGenerator::test_generate_html_report", 0.18454935622317598, 442], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.18454935622317598, 443], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_reporting.py::TestHTMLReportGenerator::test_generate_html_report", 0.18454935622317598, 444], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLI::test_demo_command", 0.18220338983050846, 445], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLI::test_demo_command", 0.18220338983050846, 446], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.18143459915611815, 447], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.18143459915611815, 448], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.18122977346278318, 449], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.18023255813953487, 450], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.18023255813953487, 451], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.18006430868167203, 452], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.172, 453], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.172, 454], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.17131474103585656, 455], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.17131474103585656, 456], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIBaseline::test_baseline_delete_nonexistent", 0.17073170731707318, 457], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.17063492063492064, 458], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.17063492063492064, 459], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.16996047430830039, 460], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.16996047430830039, 461], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.16929133858267717, 462], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.16929133858267717, 463], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.16847826086956522, 464], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.16847826086956522, 465], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_invalid_extension", "tests/test_cli.py::TestCLIErrorHandling::test_security_violation", 0.16831683168316833, 466], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", 0.16756756756756758, 467], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", 0.16756756756756758, 468], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.16731517509727625, 469], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.16731517509727625, 470], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.16731517509727625, 471], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.16731517509727625, 472], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLI::test_analyze_command", 0.16666666666666666, 473], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLI::test_analyze_command", 0.16666666666666666, 474], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestQualityGate::test_default_gate", 0.16666666666666666, 475], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_help", 0.16666666666666666, 476], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestExceptions::test_testiq_error", 0.16666666666666666, 477], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIBaseline::test_baseline_list_empty", 0.16470588235294117, 478], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.164021164021164, 479], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.164021164021164, 480], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.16104868913857678, 481], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.16104868913857678, 482], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.16044776119402984, 483], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.16044776119402984, 484], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.15897435897435896, 485], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.15897435897435896, 486], ["tests/test_enterprise.py::TestConfig::test_load_config_yaml", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.15879828326180256, 487], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.15867158671586715, 488], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.15867158671586715, 489], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.15867158671586715, 490], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.15867158671586715, 491], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.15816326530612246, 492], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.15816326530612246, 493], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", 0.15736040609137056, 494], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", 0.15736040609137056, 495], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.15736040609137056, 496], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.15736040609137056, 497], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIBaseline::test_baseline_show_nonexistent", 0.15730337078651685, 498], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.14878892733564014, 499], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.14878892733564014, 500], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_reporting.py::TestHTMLReportGenerator::test_html_report_stats_cards", 0.14351851851851852, 501], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_reporting.py::TestHTMLReportGenerator::test_html_report_stats_cards", 0.14351851851851852, 502], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestConfig::test_config_from_dict", 0.14285714285714285, 503], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestConfig::test_load_config_invalid_file", 0.14285714285714285, 504], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestPerformance::test_compute_similarity", 0.14285714285714285, 505], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_init_disabled", 0.14285714285714285, 506], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestBatchIterator::test_single_batch", 0.14285714285714285, 507], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestCheckFileSize::test_file_within_limit", 0.14285714285714285, 508], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestCheckFileSize::test_file_at_exact_limit", 0.14285714285714285, 509], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestCheckFileSize::test_default_max_size", 0.14285714285714285, 510], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.13915857605177995, 511], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.13915857605177995, 512], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLI::test_analyze_invalid_json", 0.13861386138613863, 513], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIErrorHandling::test_security_violation", 0.13861386138613863, 514], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.1382636655948553, 515], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.1382636655948553, 516], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.13564668769716087, 517], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.13564668769716087, 518], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.13304721030042918, 519], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_reporting.py::TestHTMLReportGenerator::test_generate_html_report", 0.13304721030042918, 520], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.13304721030042918, 521], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_reporting.py::TestHTMLReportGenerator::test_generate_html_report", 0.13304721030042918, 522], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLI::test_demo_command", 0.13135593220338984, 523], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLI::test_demo_command", 0.13135593220338984, 524], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.1308016877637131, 525], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.1308016877637131, 526], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", 0.125, 527], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestBatchIterator::test_exact_batches", 0.125, 528], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestBatchIterator::test_uneven_batches", 0.125, 529], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.124, 530], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.124, 531], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.12350597609561753, 532], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.12350597609561753, 533], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.12301587301587301, 534], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.12301587301587301, 535], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.1225296442687747, 536], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.1225296442687747, 537], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.1220472440944882, 538], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.1220472440944882, 539], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIErrorHandling::test_invalid_coverage_structure", 0.12173913043478261, 540], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.12062256809338522, 541], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.12062256809338522, 542], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.12062256809338522, 543], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.12062256809338522, 544], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLI::test_analyze_command", 0.12015503875968993, 545], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLI::test_analyze_command", 0.12015503875968993, 546], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.11610486891385768, 547], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.11610486891385768, 548], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.11567164179104478, 549], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.11567164179104478, 550], ["tests/test_enterprise.py::TestLogging::test_setup_logging_with_file", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.11567164179104478, 551], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.11439114391143912, 552], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.11439114391143912, 553], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.11439114391143912, 554], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.11439114391143912, 555], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestBaselineManager::test_creates_baseline_directory", 0.1111111111111111, 556], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestExceptions::test_error_codes", 0.1111111111111111, 557], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", 0.1111111111111111, 558], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_empty", 0.1111111111111111, 559], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestPerformance::test_cache_manager_disabled", 0.1111111111111111, 560], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_clear_disabled", 0.1111111111111111, 561], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestParallelProcessor::test_init_disabled", 0.1111111111111111, 562], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestBatchIterator::test_batch_size_one", 0.1111111111111111, 563], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage", 0.1076923076923077, 564], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results", 0.1076923076923077, 565], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.10726643598615918, 566], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.10726643598615918, 567], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", 0.10240963855421686, 568], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails", 0.10179640718562874, 569], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLI::test_analyze_nonexistent_file", 0.10144927536231885, 570], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.10032362459546926, 571], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.10032362459546926, 572], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestTestQualityScore::test_score_initialization", 0.1, 573], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestTestQualityScore::test_score_perfect", 0.1, 574], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestQualityGate::test_custom_gate", 0.1, 575], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_too_many_tests", 0.1, 576], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestPerformance::test_parallel_processor_disabled", 0.1, 577], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_init_with_default_dir", 0.1, 578], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_get_disabled", 0.1, 579], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestParallelProcessor::test_init_enabled", 0.1, 580], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestProgressTracker::test_init", 0.1, 581], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_non_dict_coverage_data", 0.1, 582], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestComputeFileHash::test_hash_large_file", 0.1, 583], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestComputeFileHash::test_hash_empty_file", 0.1, 584], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.09967845659163987, 585], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.09967845659163987, 586], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.09779179810725552, 587], ["tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.09779179810725552, 588], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_set_disabled", 0.09090909090909091, 589], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestComputeSimilarity::test_identical_sets", 0.09090909090909091, 590], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestComputeSimilarity::test_no_overlap", 0.09090909090909091, 591], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestComputeSimilarity::test_partial_overlap", 0.09090909090909091, 592], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestComputeSimilarity::test_subset", 0.09090909090909091, 593], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestComputeSimilarity::test_empty_sets", 0.09090909090909091, 594], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_empty_coverage_data", 0.09090909090909091, 595], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestSanitizeOutputPath::test_valid_output_path", 0.09090909090909091, 596], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestSanitizeOutputPath::test_no_allowed_dirs_restriction", 0.09090909090909091, 597], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestComputeFileHash::test_hash_small_file", 0.09090909090909091, 598], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestComputeFileHash::test_hash_consistency", 0.09090909090909091, 599], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLI::test_analyze_invalid_json", 0.0891089108910891, 600], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_enterprise.py::TestConfig::test_config_to_dict", 0.08695652173913043, 601], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIBaseline::test_baseline_delete_nonexistent", 0.08536585365853659, 602], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", 0.08433734939759036, 603], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails", 0.08383233532934131, 604], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestBaselineManager::test_load_nonexistent_baseline", 0.08333333333333333, 605], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_init_with_custom_dir", 0.08333333333333333, 606], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestStreamingJSONParser::test_parse_empty_file", 0.08333333333333333, 607], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestComputeSimilarity::test_caching", 0.08333333333333333, 608], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateFilePath::test_nonexistent_file_without_check", 0.08333333333333333, 609], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIBaseline::test_baseline_list_empty", 0.08235294117647059, 610], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIBaseline::test_baseline_show_nonexistent", 0.07865168539325842, 611], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIErrorHandling::test_invalid_coverage_structure", 0.0782608695652174, 612], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_validate_file_path_dangerous_pattern", 0.07692307692307693, 613], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_check_file_size_too_large", 0.07692307692307693, 614], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_dangerous", 0.07692307692307693, 615], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_get_cache_key_string", 0.07692307692307693, 616], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_get_cache_key_consistency", 0.07692307692307693, 617], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestParallelProcessor::test_map_empty_list", 0.07692307692307693, 618], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestParallelProcessor::test_map_single_item", 0.07692307692307693, 619], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestProgressTracker::test_update_default_increment", 0.07692307692307693, 620], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestCheckFileSize::test_nonexistent_file", 0.07692307692307693, 621], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_too_many_tests", 0.07692307692307693, 622], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestComputeFileHash::test_hash_different_content", 0.07692307692307693, 623], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.07296137339055794, 624], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.07172995780590717, 625], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestConfig::test_load_config_from_env", 0.07142857142857142, 626], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestLogging::test_setup_logging", 0.07142857142857142, 627], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_get_cache_key_dict", 0.07142857142857142, 628], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_get_miss", 0.07142857142857142, 629], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateFilePath::test_valid_json_file", 0.07142857142857142, 630], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateFilePath::test_valid_yaml_file", 0.07142857142857142, 631], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateFilePath::test_valid_yml_file", 0.07142857142857142, 632], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLI::test_analyze_invalid_json", 0.06930693069306931, 633], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIErrorHandling::test_security_violation", 0.06930693069306931, 634], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.068, 635], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.06772908366533864, 636], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.06746031746031746, 637], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.06719367588932806, 638], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.06692913385826772, 639], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestTrendTracker::test_trend_with_insufficient_data", 0.06666666666666667, 640], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestStreamingJSONParser::test_parse_coverage_file_chunked", 0.06666666666666667, 641], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_non_string_test_name", 0.06666666666666667, 642], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.06614785992217899, 643], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.06614785992217899, 644], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLI::test_analyze_command", 0.06589147286821706, 645], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.06367041198501873, 646], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.06343283582089553, 647], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.06273062730627306, 648], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.06273062730627306, 649], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestStreamingJSONParser::test_parse_invalid_json", 0.0625, 650], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestParallelProcessor::test_map_sequential", 0.0625, 651], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateFilePath::test_path_traversal_attack", 0.0625, 652], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateFilePath::test_tilde_expansion", 0.0625, 653], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_empty_test_name", 0.0625, 654], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestSanitizeOutputPath::test_dangerous_pattern_in_path", 0.0625, 655], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIErrorHandling::test_invalid_coverage_structure", 0.06086956521739131, 656], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.060085836909871244, 657], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLI::test_demo_command", 0.059322033898305086, 658], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.05907172995780591, 659], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_validate_file_path_invalid_extension", 0.058823529411764705, 660], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", 0.058823529411764705, 661], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestHookType::test_hook_type_values", 0.058823529411764705, 662], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateFilePath::test_nonexistent_file_with_check", 0.058823529411764705, 663], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateFilePath::test_dangerous_pattern_windows_backslash", 0.058823529411764705, 664], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestCheckFileSize::test_file_exceeds_limit", 0.058823529411764705, 665], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.058823529411764705, 666], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.056, 667], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.055776892430278883, 668], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestProgressTracker::test_progress_percentage", 0.05555555555555555, 669], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_non_dict_coverage", 0.05555555555555555, 670], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.05555555555555555, 671], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.05533596837944664, 672], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.05511811023622047, 673], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.05501618122977346, 674], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.05466237942122187, 675], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.054474708171206226, 676], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.054474708171206226, 677], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLI::test_analyze_command", 0.05426356589147287, 678], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", 0.05421686746987952, 679], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_enterprise.py::TestConfig::test_load_config_yaml", 0.05405405405405406, 680], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails", 0.05389221556886228, 681], ["tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.05362776025236593, 682], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestStreamingJSONParser::test_parse_non_dict_json", 0.05263157894736842, 683], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestProgressTracker::test_update_progress", 0.05263157894736842, 684], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestProgressTracker::test_complete_progress", 0.05263157894736842, 685], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.052434456928838954, 686], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.05223880597014925, 687], ["tests/test_enterprise.py::TestExceptions::test_testiq_error", "tests/test_cli.py::TestCLIErrorHandling::test_invalid_coverage_structure", 0.05217391304347826, 688], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.05166051660516605, 689], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.05166051660516605, 690], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.05, 691], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestPerformance::test_cache_manager", 0.05, 692], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_non_string_file_name", 0.05, 693], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_valid_at_line_limit", 0.05, 694], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestSanitizeOutputPath::test_allowed_directory", 0.05, 695], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.04844290657439446, 696], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", 0.04794520547945205, 697], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestStreamingJSONParser::test_parse_coverage_file", 0.047619047619047616, 698], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestHookType::test_all_hook_types_exist", 0.047619047619047616, 699], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginManager::test_trigger_nonexistent_hook", 0.047619047619047616, 700], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateFilePath::test_invalid_extension", 0.047619047619047616, 701], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_valid_coverage_data", 0.047619047619047616, 702], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", 0.046357615894039736, 703], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_invalid_structure", 0.045454545454545456, 704], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginManager::test_unregister_nonexistent_hook", 0.045454545454545456, 705], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_non_list_lines", 0.045454545454545456, 706], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.045307443365695796, 707], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.04501607717041801, 708], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", 0.044585987261146494, 709], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", 0.04430379746835443, 710], ["tests/test_enterprise.py::TestLogging::test_setup_logging", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.04416403785488959, 711], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_invalid_line_numbers", 0.043478260869565216, 712], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestConfig::test_config_to_dict", 0.043478260869565216, 713], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestPerformance::test_parallel_processor", 0.043478260869565216, 714], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", 0.04216867469879518, 715], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails", 0.041916167664670656, 716], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestSanitizeOutputPath::test_multiple_allowed_directories", 0.041666666666666664, 717], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.040697674418604654, 718], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_set_and_get", 0.04, 719], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_non_integer_line_number", 0.04, 720], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_invalid_line_number", 0.04, 721], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_negative_line_number", 0.04, 722], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLI::test_analyze_invalid_json", 0.039603960396039604, 723], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.03862660944206009, 724], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_get_corrupted_cache", 0.038461538461538464, 725], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginManager::test_register_hook", 0.038461538461538464, 726], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginManager::test_register_multiple_hooks", 0.038461538461538464, 727], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.0379746835443038, 728], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.036, 729], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.035897435897435895, 730], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.035856573705179286, 731], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestParallelProcessor::test_map_parallel_thread", 0.03571428571428571, 732], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginManager::test_clear_hooks", 0.03571428571428571, 733], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestGlobalFunctions::test_clear_global_hooks", 0.03571428571428571, 734], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestSanitizeOutputPath::test_disallowed_directory", 0.03571428571428571, 735], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.03571428571428571, 736], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.03557312252964427, 737], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.03543307086614173, 738], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.03501945525291829, 739], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.03501945525291829, 740], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLI::test_analyze_command", 0.03488372093023256, 741], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIErrorHandling::test_invalid_coverage_structure", 0.034782608695652174, 742], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestCacheManager::test_clear_cache", 0.034482758620689655, 743], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_security.py::TestValidateCoverageData::test_too_many_lines", 0.034482758620689655, 744], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.033707865168539325, 745], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.033582089552238806, 746], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_empty_finder", 0.03333333333333333, 747], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginManager::test_unregister_hook", 0.03333333333333333, 748], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.033210332103321034, 749], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.033210332103321034, 750], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", 0.03225806451612903, 751], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage", 0.03225806451612903, 752], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestLogging::test_setup_logging_with_file", 0.03225806451612903, 753], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.032, 754], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.031746031746031744, 755], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.031496062992125984, 756], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIErrorHandling::test_config_error", 0.03125, 757], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestParallelProcessor::test_map_parallel_process", 0.03125, 758], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.031141868512110725, 759], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_performance.py::TestParallelProcessor::test_map_with_error", 0.030303030303030304, 760], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.030042918454935622, 761], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_reporting.py::TestHTMLReportGenerator::test_generate_html_report", 0.030042918454935622, 762], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.0299625468164794, 763], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLI::test_demo_command", 0.029661016949152543, 764], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_cli.py::TestCLI::test_demo_command", 0.029661016949152543, 765], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.029535864978902954, 766], ["tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.02952029520295203, 767], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.02912621359223301, 768], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLI::test_analyze_nonexistent_file", 0.028985507246376812, 769], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.028938906752411574, 770], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginManager::test_trigger_hook", 0.02857142857142857, 771], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestGlobalFunctions::test_register_global_hook", 0.02857142857142857, 772], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestGlobalFunctions::test_unregister_global_hook", 0.02857142857142857, 773], ["tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.028391167192429023, 774], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.028, 775], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.027888446215139442, 776], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginManager::test_trigger_multiple_hooks", 0.027777777777777776, 777], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestGlobalFunctions::test_multiple_registrations_same_function", 0.027777777777777776, 778], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.027777777777777776, 779], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.027777777777777776, 780], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.02766798418972332, 781], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.027559055118110236, 782], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.027237354085603113, 783], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.027237354085603113, 784], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLI::test_analyze_command", 0.027131782945736434, 785], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_cli.py::TestCLI::test_analyze_command", 0.027131782945736434, 786], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestBaselineManager::test_baseline_file_format", 0.02702702702702703, 787], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_enterprise.py::TestConfig::test_load_config_yaml", 0.02702702702702703, 788], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.026217228464419477, 789], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.026119402985074626, 790], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.025830258302583026, 791], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.025830258302583026, 792], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginIntegration::test_conditional_hook_execution", 0.02564102564102564, 793], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginManager::test_hook_error_handling", 0.025, 794], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestGlobalFunctions::test_hook_with_data", 0.024390243902439025, 795], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIBaseline::test_baseline_delete_nonexistent", 0.024390243902439025, 796], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.02422145328719723, 797], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", 0.024096385542168676, 798], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails", 0.023952095808383235, 799], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIBaseline::test_baseline_list_empty", 0.023529411764705882, 800], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", 0.023255813953488372, 801], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates", 0.023255813953488372, 802], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.022653721682847898, 803], ["tests/test_enterprise.py::TestPerformance::test_compute_similarity", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.022653721682847898, 804], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.022508038585209004, 805], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIBaseline::test_baseline_show_nonexistent", 0.02247191011235955, 806], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_plugins.py::TestPluginIntegration::test_complete_workflow", 0.022222222222222223, 807], ["tests/test_enterprise.py::TestConfig::test_config_from_dict", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.022082018927444796, 808], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestTrendTracker::test_add_and_get_history", 0.02040816326530612, 809], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLI::test_analyze_invalid_json", 0.019801980198019802, 810], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIErrorHandling::test_security_violation", 0.019801980198019802, 811], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestQualityAnalyzer::test_empty_finder_score", 0.0196078431372549, 812], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestBaselineManager::test_save_and_load_baseline", 0.019230769230769232, 813], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestTrendTracker::test_calculate_trend_improving", 0.018518518518518517, 814], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestTrendTracker::test_calculate_trend_worsening", 0.018518518518518517, 815], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets", 0.017857142857142856, 816], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", 0.017543859649122806, 817], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIErrorHandling::test_invalid_coverage_structure", 0.017391304347826087, 818], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.017167381974248927, 819], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", 0.01694915254237288, 820], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.016877637130801686, 821], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.016, 822], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.01593625498007968, 823], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.015873015873015872, 824], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.015810276679841896, 825], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.015748031496062992, 826], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.01556420233463035, 827], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.01556420233463035, 828], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLI::test_analyze_command", 0.015503875968992248, 829], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage", 0.015384615384615385, 830], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results", 0.015384615384615385, 831], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestBaselineManager::test_list_baselines", 0.015384615384615385, 832], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.0149812734082397, 833], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.014925373134328358, 834], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.014760147601476014, 835], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.014760147601476014, 836], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_analyze_nonexistent_file", 0.014492753623188406, 837], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_reporting.py::TestCSVReportGenerator::test_csv_report_empty_finder", 0.014084507042253521, 838], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.01384083044982699, 839], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestRecommendationEngine::test_empty_finder_recommendations", 0.012987012987012988, 840], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.012944983818770227, 841], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.012861736334405145, 842], ["tests/test_enterprise.py::TestSecurity::test_check_file_size_valid", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.012618296529968454, 843], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_exact_duplicates_csv", 0.0125, 844], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_reporting.py::TestCSVReportGenerator::test_csv_valid_format", 0.012345679012345678, 845], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIBaseline::test_baseline_delete_nonexistent", 0.012195121951219513, 846], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", 0.012048192771084338, 847], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails", 0.011976047904191617, 848], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIBaseline::test_baseline_list_empty", 0.011764705882352941, 849], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIBaseline::test_baseline_show_nonexistent", 0.011235955056179775, 850], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_reporting.py::TestHTMLReportGenerator::test_html_report_empty_finder", 0.010638297872340425, 851], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_similar_tests_csv", 0.010638297872340425, 852], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_subset_duplicates_csv", 0.01, 853], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_analyze_invalid_json", 0.009900990099009901, 854], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIErrorHandling::test_security_violation", 0.009900990099009901, 855], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_generate_report", 0.00909090909090909, 856], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIErrorHandling::test_invalid_coverage_structure", 0.008695652173913044, 857], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.008583690987124463, 858], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLI::test_demo_command", 0.00847457627118644, 859], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.008438818565400843, 860], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.008, 861], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.00796812749003984, 862], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.007936507936507936, 863], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.007905138339920948, 864], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.007874015748031496, 865], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.007782101167315175, 866], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.007782101167315175, 867], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLI::test_analyze_command", 0.007751937984496124, 868], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.00749063670411985, 869], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.007462686567164179, 870], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.007380073800738007, 871], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.007380073800738007, 872], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestQualityAnalyzer::test_grade_mapping", 0.007142857142857143, 873], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestQualityAnalyzer::test_score_components_range", 0.0070921985815602835, 874], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_reporting.py::TestCSVReportGenerator::test_generate_summary_csv", 0.006944444444444444, 875], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.006920415224913495, 876], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestQualityAnalyzer::test_high_quality_score", 0.00684931506849315, 877], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds", 0.00684931506849315, 878], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestQualityGateChecker::test_passes_max_duplicates", 0.006666666666666667, 879], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", 0.006622516556291391, 880], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_percentage", 0.006493506493506494, 881], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.006472491909385114, 882], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.006430868167202572, 883], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestQualityGateChecker::test_fails_max_duplicates", 0.00641025641025641, 884], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestQualityGateChecker::test_passes_with_no_limits", 0.006369426751592357, 885], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestQualityAnalyzer::test_low_quality_score", 0.006329113924050633, 886], ["tests/test_enterprise.py::TestConfig::test_default_config", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.006309148264984227, 887], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_high_quality", 0.006024096385542169, 888], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cicd.py::TestQualityGateChecker::test_fails_on_increase", 0.006024096385542169, 889], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", 0.006024096385542169, 890], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails", 0.005988023952095809, 891], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_for_perfect_suite", 0.005813953488372093, 892], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", 0.005434782608695652, 893], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", 0.005405405405405406, 894], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow", 0.005291005291005291, 895], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestIntegration::test_score_influences_recommendations", 0.005128205128205128, 896], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation", 0.00510204081632653, 897], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", 0.005076142131979695, 898], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", 0.005076142131979695, 899], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_reporting.py::TestHTMLReportGenerator::test_html_report_stats_cards", 0.004629629629629629, 900], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIConfig::test_custom_config_file", 0.004291845493562232, 901], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_reporting.py::TestHTMLReportGenerator::test_generate_html_report", 0.004291845493562232, 902], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_demo_command", 0.00423728813559322, 903], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_analyze_stdout_output", 0.004219409282700422, 904], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_analyze_with_all_options", 0.004, 905], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_analyze_with_threshold", 0.00398406374501992, 906], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIIntegration::test_full_workflow", 0.003968253968253968, 907], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIConfig::test_log_level_option", 0.003952569169960474, 908], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_analyze_json_format", 0.003937007874015748, 909], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIFormats::test_csv_format", 0.0038910505836575876, 910], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", 0.0038910505836575876, 911], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_analyze_command", 0.003875968992248062, 912], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIIntegration::test_threshold_affects_results", 0.003745318352059925, 913], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIConfig::test_log_file_option", 0.0037313432835820895, 914], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLI::test_analyze_markdown_format", 0.0036900369003690036, 915], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIQualityScore::test_quality_score_with_output", 0.0036900369003690036, 916], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIQualityGate::test_save_baseline", 0.0034602076124567475, 917], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_pass", 0.003236245954692557, 918], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIFormats::test_html_format", 0.003215434083601286, 919], ["tests/test_analyzer.py::TestTestCoverage::test_test_coverage_creation", "tests/test_cli.py::TestCLIQualityGate::test_quality_gate_fail", 0.0031545741324921135, 920]];
        
        // Build coverage data per file
        const coverageByFile = {};
        coverageByFile["src/testiq/analysis.py"] = {lines: 112, tests: 18};
        coverageByFile["src/testiq/analyzer.py"] = {lines: 102, tests: 64};
        coverageByFile["src/testiq/cicd.py"] = {lines: 127, tests: 26};
        coverageByFile["src/testiq/cli.py"] = {lines: 227, tests: 29};
        coverageByFile["src/testiq/config.py"] = {lines: 78, tests: 35};
        coverageByFile["src/testiq/exceptions.py"] = {lines: 8, tests: 37};
        coverageByFile["src/testiq/logging_config.py"] = {lines: 31, tests: 67};
        coverageByFile["src/testiq/performance.py"] = {lines: 90, tests: 110};
        coverageByFile["src/testiq/plugins.py"] = {lines: 38, tests: 18};
        coverageByFile["src/testiq/pytest_plugin.py"] = {lines: 1, tests: 224};
        coverageByFile["src/testiq/reporting.py"] = {lines: 155, tests: 11};
        coverageByFile["src/testiq/security.py"] = {lines: 77, tests: 74};
        coverageByFile["src/testiq/source_reader.py"] = {lines: 11, tests: 4};
        coverageByFile["tests/test_analysis.py"] = {lines: 153, tests: 19};
        coverageByFile["tests/test_cicd.py"] = {lines: 167, tests: 20};
        coverageByFile["tests/test_cli.py"] = {lines: 228, tests: 31};
        coverageByFile["tests/test_performance.py"] = {lines: 195, tests: 42};
        coverageByFile["tests/test_plugins.py"] = {lines: 134, tests: 18};
        coverageByFile["tests/test_reporting.py"] = {lines: 128, tests: 9};
        coverageByFile["tests/test_security.py"] = {lines: 158, tests: 44};
        
        const itemsPerPage = 20;
        let currentPages = { exact: 1, similar: 1, subset: 1, coverage: 1 };
        
        function truncateTestName(testName) {
            if (!testName || typeof testName !== 'string') {
                return '';
            }
            
            // Extract just the meaningful parts of the test name
            const parts = testName.split('::');
            if (parts.length <= 2) {
                return testName;
            }
            
            try {
                // Get the file name (without path)
                const filePart = parts[0].split('/').pop() || parts[0];
                // Get the class name (if exists) and test name
                const classPart = parts.length > 2 ? parts[parts.length - 2] : '';
                const testPart = parts[parts.length - 1];
                
                // Format: FileName::Class::test_name
                if (classPart) {
                    return filePart + '::' + classPart + '::' + testPart;
                } else {
                    return filePart + '::' + testPart;
                }
            } catch (e) {
                console.error('Error truncating test name:', e);
                return testName;
            }
        }
        
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            // Show selected tab
            event.target.classList.add('active');
            document.getElementById(tabName + '-content').classList.add('active');
        }
        
        function renderExactDuplicates(page) {
            const start = (page - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageData = exactDupsData.slice(start, end);
            
            let html = '';
            if (pageData.length === 0) {
                html = '<p style="color: #27ae60; text-align: center; padding: 20px;">‚úì No exact duplicates found!</p>';
            } else {
                html = `
                <table>
                    <thead>
                        <tr>
                            <th>Group</th>
                            <th>Tests</th>
                            <th>Count</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>`;
                
                pageData.forEach(([group, coverageIdx], idx) => {
                    const groupNum = start + idx + 1;
                    const testList = group.map(test => {
                        if (!test) return '';
                        const truncated = truncateTestName(test);
                        return `<span class="test-name" title="${escapeHtml(test)}" style="cursor: help;">${escapeHtml(truncated)}</span>`;
                    }).filter(t => t).join('<br>');
                    html += `
                        <tr class="clickable-row" onclick="showComparison(${coverageIdx})">
                            <td><strong>Group ${groupNum}</strong></td>
                            <td>${testList}</td>
                            <td><span class="badge badge-danger">${group.length} tests</span></td>
                            <td><span style="color: #00c6ff; font-weight: 600;">üîç View Coverage</span></td>
                        </tr>`;
                });
                
                html += '</tbody></table>';
            }
            
            document.getElementById('exact-table').innerHTML = html;
            renderPagination('exact', exactDupsData.length, page);
            formatTestNames();
        }
        
        function renderSimilarTests(page) {
            const start = (page - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageData = similarData.slice(start, end);
            
            let html = '';
            if (pageData.length === 0) {
                html = '<p style="color: #27ae60; text-align: center; padding: 20px;">‚úì No similar tests found!</p>';
            } else {
                html = `
                <table>
                    <thead>
                        <tr>
                            <th>Test 1</th>
                            <th>Test 2</th>
                            <th>Similarity</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>`;
                
                pageData.forEach(([test1, test2, similarity, coverageIdx]) => {
                    if (!test1 || !test2) return;
                    const t1 = escapeHtml(truncateTestName(test1));
                    const t2 = escapeHtml(truncateTestName(test2));
                    const simPercent = (similarity * 100).toFixed(1);
                    html += `
                        <tr class="clickable-row" onclick="showComparison(${coverageIdx})">
                            <td><span class="test-name" title="${escapeHtml(test1)}" style="cursor: help;">${t1}</span></td>
                            <td><span class="test-name" title="${escapeHtml(test2)}" style="cursor: help;">${t2}</span></td>
                            <td><span class="badge badge-info">${simPercent}%</span></td>
                            <td><span style="color: #00c6ff; font-weight: 600;">üîç View Coverage</span></td>
                        </tr>`;
                });
                
                html += '</tbody></table>';
            }
            
            document.getElementById('similar-table').innerHTML = html;
            renderPagination('similar', similarData.length, page);
            formatTestNames();
        }
        
        function renderSubsetDuplicates(page) {
            const start = (page - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageData = subsetData.slice(start, end);
            
            let html = '';
            if (pageData.length === 0) {
                html = '<p style="color: #27ae60; text-align: center; padding: 20px;">‚úì No subset duplicates found!</p>';
            } else {
                html = `
                <table>
                    <thead>
                        <tr>
                            <th>Subset Test</th>
                            <th>Superset Test</th>
                            <th>Coverage Ratio</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>`;
                
                pageData.forEach(([subsetTest, supersetTest, ratio, coverageIdx]) => {
                    if (!subsetTest || !supersetTest) return;
                    const sub = escapeHtml(truncateTestName(subsetTest));
                    const sup = escapeHtml(truncateTestName(supersetTest));
                    const ratioPercent = (ratio * 100).toFixed(1);
                    html += `
                        <tr class="clickable-row" onclick="showComparison(${coverageIdx})">
                            <td><span class="test-name" title="${escapeHtml(subsetTest)}" style="cursor: help;">${sub}</span></td>
                            <td><span class="test-name" title="${escapeHtml(supersetTest)}" style="cursor: help;">${sup}</span></td>
                            <td><span class="badge badge-warning">${ratioPercent}%</span></td>
                            <td><span style="color: #00c6ff; font-weight: 600;">üîç View Coverage</span></td>
                        </tr>`;
                });
                
                html += '</tbody></table>';
            }
            
            document.getElementById('subset-table').innerHTML = html;
            renderPagination('subset', subsetData.length, page);
            formatTestNames();
        }
        
        function renderPagination(type, totalItems, currentPage) {
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            
            if (totalPages <= 1) {
                document.getElementById(type + '-pagination').innerHTML = '';
                return;
            }
            
            const start = (currentPage - 1) * itemsPerPage + 1;
            const end = Math.min(currentPage * itemsPerPage, totalItems);
            
            let html = '<button class="page-btn" onclick="changePage(\'' + type + '\', ' + (currentPage - 1) + ')" ' +
                (currentPage === 1 ? 'disabled' : '') + '>‚Üê Previous</button>' +
                '<span class="page-info">' + start + '-' + end + ' of ' + totalItems + ' | Page ' + currentPage + '/' + totalPages + '</span>' +
                '<button class="page-btn" onclick="changePage(\'' + type + '\', ' + (currentPage + 1) + ')" ' +
                (currentPage === totalPages ? 'disabled' : '') + '>Next ‚Üí</button>';
            
            document.getElementById(type + '-pagination').innerHTML = html;
        }
        
        function changePage(type, newPage) {
            currentPages[type] = newPage;
            
            if (type === 'exact') {
                renderExactDuplicates(newPage);
            } else if (type === 'similar') {
                renderSimilarTests(newPage);
            } else if (type === 'subset') {
                renderSubsetDuplicates(newPage);
            }
            
            // Scroll to top of table
            document.getElementById(type + '-content').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function formatTestNames() {
            const testNames = document.querySelectorAll('.test-name');
            testNames.forEach(el => {
                const originalText = el.textContent;
                if (originalText.includes('::')) {
                    el.innerHTML = formatTestName(originalText);
                }
            });
        }
        
        // Initial render
        renderExactDuplicates(1);
        renderSimilarTests(1);
        renderSubsetDuplicates(1);
        </script>

        <!-- Modal for split-screen coverage view -->
        <div id="comparisonModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 style="margin: 0;">üìä Coverage Comparison</h2>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div class="filter-section">
                            <label for="fileFilter" style="font-weight: 600; margin-right: 8px;">üìÅ</label>
                            <select id="fileFilter" class="filter-select" onchange="applyFileFilter()">
                                <option value="">All Files</option>
                            </select>
                        </div>
                        <div class="sync-toggle" id="syncToggle" onclick="toggleSync()">
                            <input type="checkbox" id="syncCheckbox" class="sync-checkbox" checked>
                            <label for="syncCheckbox" style="cursor: pointer; user-select: none;">üîó Sync Scroll</label>
                        </div>
                        <span class="close" onclick="closeModal()">&times;</span>
                    </div>
                </div>
                <div class="coverage-info">
                    <div>
                        <strong>Subset Test:</strong> <span id="subsetName" class="test-name"></span>
                        &nbsp;&nbsp;|&nbsp;&nbsp;
                        <strong>Superset Test:</strong> <span id="supersetName" class="test-name"></span>
                        &nbsp;&nbsp;|&nbsp;&nbsp;
                        <strong>Coverage Ratio:</strong> <span id="coverageRatio" class="badge badge-warning"></span>
                    </div>
                </div>
                <div class="split-view">
                    <div class="file-panel">
                        <div class="panel-header">üìÑ Subset Test Coverage</div>
                        <div id="subsetContent" class="file-content"></div>
                    </div>
                    <div class="file-panel">
                        <div class="panel-header">üìÑ Superset Test Coverage</div>
                        <div id="supersetContent" class="file-content"></div>
                    </div>
                </div>
            </div>
        </div>

        <script>
        const coverageData = [{"subset": {"src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93], "src/testiq/pytest_plugin.py": [78]}, "ratio": 1.0, "subsetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "supersetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_multiple_files_coverage"}, {"subset": {"src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128], "src/testiq/pytest_plugin.py": [78]}, "ratio": 1.0, "subsetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates", "supersetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates_no_duplicates"}, {"subset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 214, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 214, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/pytest_plugin.py": [78]}, "ratio": 1.0, "subsetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage", "supersetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 65, 67], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 70, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 425, 426], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9764705882352941, "subsetName": "tests/test_cli.py::TestCLI::test_analyze_with_threshold", "supersetName": "tests/test_cli.py::TestCLIConfig::test_log_level_option"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 286, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 296, 297, 298, 299, 301, 303], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 70, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 425, 426], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9615384615384616, "subsetName": "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", "supersetName": "tests/test_cli.py::TestCLIConfig::test_log_level_option"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 65, 67], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 286, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 296, 297, 298, 299, 301, 303], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9613899613899614, "subsetName": "tests/test_cli.py::TestCLI::test_analyze_with_threshold", "supersetName": "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 59, 61], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 70, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 425, 426], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9578544061302682, "subsetName": "tests/test_cli.py::TestCLI::test_analyze_command", "supersetName": "tests/test_cli.py::TestCLIConfig::test_log_level_option"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 59, 61], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 65, 67], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9576923076923077, "subsetName": "tests/test_cli.py::TestCLI::test_analyze_command", "supersetName": "tests/test_cli.py::TestCLI::test_analyze_with_threshold"}, {"subset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 161, 162, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 102, 104, 107, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 140, 141, 153, 154, 155, 160, 161, 165, 176, 181, 184, 189, 194, 211, 212, 224, 226, 227, 228, 229, 230, 233, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 264, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_analysis.py": [30, 33, 34, 37, 38, 40, 179, 180, 183, 186, 187], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 161, 162, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 102, 104, 107, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 140, 141, 153, 154, 155, 160, 161, 165, 176, 181, 184, 189, 194, 211, 212, 224, 226, 227, 228, 229, 230, 233, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 264, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_analysis.py": [30, 33, 34, 37, 38, 40, 225, 226, 229, 230], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9552238805970149, "subsetName": "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", "supersetName": "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation"}, {"subset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 161, 162, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 102, 104, 107, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 140, 141, 153, 154, 155, 160, 161, 165, 176, 181, 184, 189, 194, 211, 212, 224, 226, 227, 228, 229, 230, 233, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 264, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_analysis.py": [30, 33, 34, 37, 38, 40, 215, 216, 219, 220, 221], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 161, 162, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 102, 104, 107, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 140, 141, 153, 154, 155, 160, 161, 165, 176, 181, 184, 189, 194, 211, 212, 224, 226, 227, 228, 229, 230, 233, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 264, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_analysis.py": [30, 33, 34, 37, 38, 40, 225, 226, 229, 230], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9552238805970149, "subsetName": "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities", "supersetName": "tests/test_analysis.py::TestRecommendationEngine::test_duplicate_recommendation"}, {"subset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 161, 162, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 102, 104, 107, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 140, 141, 153, 154, 155, 160, 161, 165, 176, 181, 184, 189, 194, 211, 212, 224, 226, 227, 228, 229, 230, 233, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 264, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_analysis.py": [30, 33, 34, 37, 38, 40, 179, 180, 183, 186, 187], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 161, 162, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 102, 104, 107, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 140, 141, 153, 154, 155, 160, 161, 165, 176, 181, 184, 189, 194, 211, 212, 224, 226, 227, 228, 229, 230, 233, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 264, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_analysis.py": [30, 33, 34, 37, 38, 40, 215, 216, 219, 220, 221], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9504950495049505, "subsetName": "tests/test_analysis.py::TestRecommendationEngine::test_recommendations_for_low_quality", "supersetName": "tests/test_analysis.py::TestRecommendationEngine::test_recommendation_priorities"}, {"subset": {"src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 144, 148, 149, 151, 152, 153, 155, 156, 157, 160, 161, 162, 167, 168, 170, 171, 172], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 144, 148, 149, 151, 152, 153, 155, 156, 157, 160, 163, 167, 168, 170, 171, 172], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9482758620689655, "subsetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates", "supersetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_subset_duplicates_no_subsets"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 59, 61], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 286, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 296, 297, 298, 299, 301, 303], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9433962264150944, "subsetName": "tests/test_cli.py::TestCLI::test_analyze_command", "supersetName": "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 238, 239, 240, 291, 295, 299], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 274, 275, 276], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 246, 247, 248, 291, 295, 299], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 290, 291, 292], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9248554913294798, "subsetName": "tests/test_cli.py::TestCLIFormats::test_html_without_output_fails", "supersetName": "tests/test_cli.py::TestCLIFormats::test_csv_without_output_fails"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 70, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 425, 426], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 80, 82, 83, 84, 85, 86, 87, 92, 93, 94, 95, 97, 98, 100], "src/testiq/cli.py": [65, 66, 69, 71, 72, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 430, 431, 432, 434], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.922509225092251, "subsetName": "tests/test_cli.py::TestCLIConfig::test_log_level_option", "supersetName": "tests/test_cli.py::TestCLIConfig::test_log_file_option"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 65, 67], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 80, 82, 83, 84, 85, 86, 87, 92, 93, 94, 95, 97, 98, 100], "src/testiq/cli.py": [65, 66, 69, 71, 72, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 430, 431, 432, 434], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9222222222222223, "subsetName": "tests/test_cli.py::TestCLI::test_analyze_with_threshold", "supersetName": "tests/test_cli.py::TestCLIConfig::test_log_file_option"}, {"subset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 101, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 143, 144, 145, 153, 165, 176, 181, 184, 189, 194, 211, 212, 224, 226, 227, 228, 229, 230, 233, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 250, 264, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_analysis.py": [46, 49, 50, 51, 54, 55, 57, 201, 202, 205, 206, 208, 209, 210, 211], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 101, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 143, 144, 145, 153, 165, 176, 181, 184, 189, 194, 211, 212, 224, 226, 227, 228, 229, 230, 233, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 250, 264, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_analysis.py": [46, 49, 50, 51, 54, 55, 57, 258, 259, 261, 264, 266, 267, 268], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.921875, "subsetName": "tests/test_analysis.py::TestRecommendationEngine::test_report_contains_statistics", "supersetName": "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 286, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 296, 297, 298, 299, 301, 303], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 80, 82, 83, 84, 85, 86, 87, 92, 93, 94, 95, 97, 98, 100], "src/testiq/cli.py": [65, 66, 69, 71, 72, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 430, 431, 432, 434], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9090909090909091, "subsetName": "tests/test_cli.py::TestCLIFormats::test_text_format_ignores_output", "supersetName": "tests/test_cli.py::TestCLIConfig::test_log_file_option"}, {"subset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 214, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 214, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9076923076923077, "subsetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage", "supersetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold"}, {"subset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 214, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 214, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9076923076923077, "subsetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", "supersetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results"}, {"subset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 100], "src/testiq/cli.py": [65, 66, 69, 71, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 59, 61], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/logging_config.py": [27, 33, 35, 38, 61, 62, 63, 66, 69, 70, 71, 72, 73, 75, 76, 79, 80, 82, 83, 84, 85, 86, 87, 92, 93, 94, 95, 97, 98, 100], "src/testiq/cli.py": [65, 66, 69, 71, 72, 75, 76, 77, 78, 79, 80, 84, 85, 87, 88, 154, 157, 158, 160, 162, 164, 165, 168, 169, 172, 174, 177, 178, 179, 180, 181, 185, 186, 189, 190, 214, 237, 245, 253, 274, 285, 287, 289, 291, 295, 299, 307, 308, 309, 310, 315, 316, 317, 318, 319, 320, 322, 323, 324, 325, 327, 328, 331, 332, 345, 346, 359, 360, 361, 363, 364, 365, 366, 368], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/config.py": [39, 73, 74, 75, 76, 77, 163, 164, 166, 169, 170, 171, 172, 173, 176, 177, 178, 179, 181, 200, 203, 205, 209, 211, 215, 219, 223, 228, 247, 250, 251, 254, 259, 260, 263, 268, 269, 274], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60, 77, 78, 79, 99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_cli.py": [14, 20, 21, 22, 23, 26, 27, 29, 430, 431, 432, 434], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9057971014492754, "subsetName": "tests/test_cli.py::TestCLI::test_analyze_command", "supersetName": "tests/test_cli.py::TestCLIConfig::test_log_file_option"}, {"subset": {"src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 101, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 143, 144, 145, 153, 165, 176, 181, 184, 189, 194], "tests/test_analysis.py": [46, 49, 50, 51, 54, 55, 57, 117, 118, 121, 122], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 101, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 143, 144, 145, 153, 165, 176, 181, 184, 189, 194], "tests/test_analysis.py": [46, 49, 50, 51, 54, 55, 57, 163, 165, 166, 170, 171], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9038461538461539, "subsetName": "tests/test_analysis.py::TestQualityAnalyzer::test_medium_quality_score", "supersetName": "tests/test_analysis.py::TestQualityAnalyzer::test_score_with_different_thresholds"}, {"subset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 101, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 143, 144, 145, 153, 165, 176, 181, 184, 189, 194, 211, 212, 224, 226, 227, 228, 229, 230, 233, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 250, 264, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_analysis.py": [46, 49, 50, 51, 54, 55, 57, 258, 259, 261, 264, 266, 267, 268], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128, 144, 148, 149, 151, 152, 153, 155, 156, 157, 158, 160, 163, 167, 168, 170, 171, 172, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 216, 217, 219, 220, 221, 222], "src/testiq/analysis.py": [45, 57, 59, 60, 61, 63, 64, 74, 77, 78, 81, 82, 85, 86, 89, 90, 91, 92, 96, 98, 100, 101, 110, 111, 114, 115, 116, 117, 118, 119, 120, 123, 124, 134, 137, 138, 139, 143, 144, 145, 153, 165, 176, 181, 184, 189, 194, 211, 212, 224, 226, 227, 228, 229, 230, 233, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 250, 264, 276, 277, 278, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "tests/test_analysis.py": [46, 49, 50, 51, 54, 55, 57, 288, 289, 291, 292, 295, 296, 298, 299, 302, 303, 304, 305], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9030612244897959, "subsetName": "tests/test_analysis.py::TestRecommendationEngine::test_statistics_accuracy", "supersetName": "tests/test_analysis.py::TestIntegration::test_complete_analysis_workflow"}, {"subset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 214, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 214, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9076923076923077, "subsetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", "supersetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage"}, {"subset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 214, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 192, 195, 199, 200, 202, 203, 204, 206, 207, 209, 210, 213, 214, 216, 217, 219, 220, 221, 222], "src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158, 213, 214, 216, 217, 219, 222, 236, 237, 238, 239, 248, 249, 252, 253, 254], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.9076923076923077, "subsetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_similar_coverage_with_threshold", "supersetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_sorted_similar_results"}, {"subset": {"src/testiq/security.py": [99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/security.py": [99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "tests/test_security.py": [219, 220, 222], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.85, "subsetName": "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "supersetName": "tests/test_security.py::TestValidateCoverageData::test_valid_at_line_limit"}, {"subset": {"src/testiq/performance.py": [153, 154, 155, 156, 157, 158, 173, 177, 179, 181, 182, 183, 184, 186, 187, 188, 189, 194], "src/testiq/logging_config.py": [27, 33, 35, 38], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/performance.py": [153, 154, 155, 156, 157, 158, 173, 177, 179, 181, 182, 183, 184, 186, 187, 188, 189, 194], "src/testiq/logging_config.py": [27, 33, 35, 38], "tests/test_performance.py": [219, 220, 222, 225, 226], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.8214285714285714, "subsetName": "tests/test_enterprise.py::TestPerformance::test_parallel_processor", "supersetName": "tests/test_performance.py::TestParallelProcessor::test_map_parallel_thread"}, {"subset": {"src/testiq/exceptions.py": [11, 12, 13, 16, 30], "src/testiq/security.py": [99, 102, 103], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/exceptions.py": [11, 12, 13, 16, 30], "tests/test_security.py": [147, 148], "src/testiq/security.py": [99, 102, 103], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.8181818181818182, "subsetName": "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_empty", "supersetName": "tests/test_security.py::TestValidateCoverageData::test_empty_coverage_data"}, {"subset": {"src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/security.py": [38, 40, 43, 44, 45, 46, 62], "src/testiq/pytest_plugin.py": [78]}, "superset": {"tests/test_security.py": [66, 67, 68], "src/testiq/security.py": [38, 40, 43, 44, 45, 46, 62], "src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.8125, "subsetName": "tests/test_enterprise.py::TestSecurity::test_validate_file_path_dangerous_pattern", "supersetName": "tests/test_security.py::TestValidateFilePath::test_path_traversal_attack"}, {"subset": {"src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/security.py": [38, 40, 43, 44, 45, 46, 62], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/security.py": [38, 40, 43, 44, 45, 46, 62], "tests/test_security.py": [90, 91, 92], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.8125, "subsetName": "tests/test_enterprise.py::TestSecurity::test_validate_file_path_dangerous_pattern", "supersetName": "tests/test_security.py::TestValidateFilePath::test_tilde_expansion"}, {"subset": {"src/testiq/security.py": [163, 164, 167, 168, 169, 170, 188], "src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/security.py": [163, 164, 167, 168, 169, 170, 188], "src/testiq/exceptions.py": [11, 12, 13, 16, 37], "tests/test_security.py": [236, 237, 238], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.8125, "subsetName": "tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_dangerous", "supersetName": "tests/test_security.py::TestSanitizeOutputPath::test_dangerous_pattern_in_path"}, {"subset": {"src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 55, 56, 57, 62], "src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 55, 56, 57, 62], "tests/test_security.py": [72, 73, 74, 75], "src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.8095238095238095, "subsetName": "tests/test_enterprise.py::TestSecurity::test_validate_file_path_invalid_extension", "supersetName": "tests/test_security.py::TestValidateFilePath::test_invalid_extension"}, {"subset": {"src/testiq/security.py": [99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/security.py": [99, 102, 105, 109, 110, 113, 116, 122, 123, 124, 127, 132, 135, 136, 138, 142], "tests/test_security.py": [138, 139, 140, 143], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.8095238095238095, "subsetName": "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_valid", "supersetName": "tests/test_security.py::TestValidateCoverageData::test_valid_coverage_data"}, {"subset": {"src/testiq/performance.py": [32, 33, 34, 38, 39, 40, 60, 63, 64, 65, 66, 67, 68, 82, 85, 86, 87, 88, 89], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/performance.py": [32, 33, 34, 38, 39, 40, 60, 63, 64, 65, 66, 67, 68, 82, 85, 86, 87, 88, 89], "tests/test_performance.py": [77, 78, 79, 80, 81], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.8, "subsetName": "tests/test_enterprise.py::TestPerformance::test_cache_manager", "supersetName": "tests/test_performance.py::TestCacheManager::test_set_and_get"}, {"subset": {"src/testiq/security.py": [99, 102, 105, 106], "src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/security.py": [99, 102, 105, 106], "tests/test_security.py": [157, 158, 159], "src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.7692307692307693, "subsetName": "tests/test_enterprise.py::TestSecurity::test_validate_coverage_data_too_many_tests", "supersetName": "tests/test_security.py::TestValidateCoverageData::test_too_many_tests"}, {"subset": {"src/testiq/performance.py": [153, 154, 155, 156, 157, 158, 173, 174, 175], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/performance.py": [153, 154, 155, 156, 157, 158, 173, 174, 175], "tests/test_performance.py": [264, 265, 266], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.7692307692307693, "subsetName": "tests/test_enterprise.py::TestPerformance::test_parallel_processor_disabled", "supersetName": "tests/test_performance.py::TestParallelProcessor::test_map_empty_list"}, {"subset": {"src/testiq/performance.py": [153, 154, 155, 156, 157, 158, 173, 174, 175], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/performance.py": [153, 154, 155, 156, 157, 158, 173, 174, 175], "tests/test_performance.py": [270, 271, 272], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.7692307692307693, "subsetName": "tests/test_enterprise.py::TestPerformance::test_parallel_processor_disabled", "supersetName": "tests/test_performance.py::TestParallelProcessor::test_map_single_item"}, {"subset": {"src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/security.py": [38, 40, 43, 44, 45, 46, 62], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/security.py": [38, 40, 43, 44, 45, 46, 62], "tests/test_security.py": [80, 81, 82, 83], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.7647058823529411, "subsetName": "tests/test_enterprise.py::TestSecurity::test_validate_file_path_dangerous_pattern", "supersetName": "tests/test_security.py::TestValidateFilePath::test_dangerous_pattern_windows_backslash"}, {"subset": {"src/testiq/security.py": [77, 78, 79, 80, 81, 82, 83], "src/testiq/exceptions.py": [11, 12, 13, 16, 37], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/security.py": [77, 78, 79, 80, 81, 82, 83], "src/testiq/exceptions.py": [11, 12, 13, 16, 37], "tests/test_security.py": [107, 108, 109, 110], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.7647058823529411, "subsetName": "tests/test_enterprise.py::TestSecurity::test_check_file_size_too_large", "supersetName": "tests/test_security.py::TestCheckFileSize::test_file_exceeds_limit"}, {"subset": {"src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60], "src/testiq/pytest_plugin.py": [78]}, "superset": {"tests/test_security.py": [60, 61, 62], "src/testiq/security.py": [38, 40, 43, 44, 45, 50, 54, 60], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.75, "subsetName": "tests/test_enterprise.py::TestSecurity::test_validate_file_path_valid", "supersetName": "tests/test_security.py::TestValidateFilePath::test_nonexistent_file_without_check"}, {"subset": {"src/testiq/security.py": [163, 164, 167, 168, 169, 173, 186], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/security.py": [163, 164, 167, 168, 169, 173, 186], "tests/test_security.py": [230, 231, 232], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.7272727272727273, "subsetName": "tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "supersetName": "tests/test_security.py::TestSanitizeOutputPath::test_valid_output_path"}, {"subset": {"src/testiq/security.py": [163, 164, 167, 168, 169, 173, 186], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/security.py": [163, 164, 167, 168, 169, 173, 186], "tests/test_security.py": [260, 261, 262], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.7272727272727273, "subsetName": "tests/test_enterprise.py::TestSecurity::test_sanitize_output_path_valid", "supersetName": "tests/test_security.py::TestSanitizeOutputPath::test_no_allowed_dirs_restriction"}, {"subset": {"src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93], "src/testiq/pytest_plugin.py": [78]}, "superset": {"src/testiq/performance.py": [32, 33, 36, 38, 39, 40, 153, 154, 155, 156, 157, 158], "src/testiq/analyzer.py": [53, 54, 55, 57, 58, 59, 60, 74, 77, 80, 81, 82, 83, 87, 88, 90, 92, 93, 109, 113, 114, 116, 117, 119, 120, 121, 124, 126, 127, 128], "src/testiq/pytest_plugin.py": [78]}, "ratio": 0.7209302325581395, "subsetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_add_test_coverage", "supersetName": "tests/test_analyzer.py::TestCoverageDuplicateFinder::test_find_exact_duplicates"}];
        const sourceCode = {"src/testiq/config.py": {"1": "\"\"\"", "2": "Configuration management for TestIQ.", "3": "Supports YAML, TOML config files and environment variables.", "4": "\"\"\"", "5": "", "6": "import os", "7": "from dataclasses import dataclass, field", "8": "from pathlib import Path", "9": "from typing import Any, Optional", "10": "", "11": "try:", "12": "    import tomllib", "13": "except ImportError:", "14": "    import tomli as tomllib  # Python < 3.11", "15": "", "16": "import yaml", "17": "", "18": "from testiq.exceptions import ConfigurationError", "19": "", "20": "", "21": "@dataclass", "22": "class LogConfig:", "23": "    \"\"\"Logging configuration.\"\"\"", "24": "", "25": "    level: str = \"INFO\"", "26": "    file: Optional[str] = None", "27": "    enable_rotation: bool = True", "28": "    max_bytes: int = 10 * 1024 * 1024  # 10MB", "29": "    backup_count: int = 5", "30": "", "31": "", "32": "@dataclass", "33": "class SecurityConfig:", "34": "    \"\"\"Security configuration.\"\"\"", "35": "", "36": "    max_file_size: int = 100 * 1024 * 1024  # 100MB", "37": "    max_tests: int = 50000", "38": "    max_lines_per_file: int = 100000", "39": "    allowed_extensions: list[str] = field(default_factory=lambda: [\".json\", \".yaml\", \".yml\"])", "40": "", "41": "", "42": "@dataclass", "43": "class PerformanceConfig:", "44": "    \"\"\"Performance configuration.\"\"\"", "45": "", "46": "    enable_parallel: bool = True", "47": "    max_workers: int = 4", "48": "    enable_caching: bool = True", "49": "    cache_dir: Optional[str] = None", "50": "", "51": "", "52": "@dataclass", "53": "class AnalysisConfig:", "54": "    \"\"\"Analysis configuration.\"\"\"", "55": "", "56": "    similarity_threshold: float = 0.7", "57": "    min_coverage_lines: int = 1", "58": "    max_results: int = 1000", "59": "", "60": "", "61": "@dataclass", "62": "class TestIQConfig:", "63": "    \"\"\"Main TestIQ configuration.\"\"\"", "64": "", "65": "    log: LogConfig = field(default_factory=LogConfig)", "66": "    security: SecurityConfig = field(default_factory=SecurityConfig)", "67": "    performance: PerformanceConfig = field(default_factory=PerformanceConfig)", "68": "    analysis: AnalysisConfig = field(default_factory=AnalysisConfig)", "69": "", "70": "    @classmethod", "71": "    def from_dict(cls, data: dict[str, Any]) -> \"TestIQConfig\":", "72": "        \"\"\"Create config from dictionary.\"\"\"", "73": "        return cls(", "74": "            log=LogConfig(**data.get(\"log\", {})),", "75": "            security=SecurityConfig(**data.get(\"security\", {})),", "76": "            performance=PerformanceConfig(**data.get(\"performance\", {})),", "77": "            analysis=AnalysisConfig(**data.get(\"analysis\", {})),", "78": "        )", "79": "", "80": "    def to_dict(self) -> dict[str, Any]:", "81": "        \"\"\"Convert config to dictionary.\"\"\"", "82": "        return {", "83": "            \"log\": {", "84": "                \"level\": self.log.level,", "85": "                \"file\": self.log.file,", "86": "                \"enable_rotation\": self.log.enable_rotation,", "87": "                \"max_bytes\": self.log.max_bytes,", "88": "                \"backup_count\": self.log.backup_count,", "89": "            },", "90": "            \"security\": {", "91": "                \"max_file_size\": self.security.max_file_size,", "92": "                \"max_tests\": self.security.max_tests,", "93": "                \"max_lines_per_file\": self.security.max_lines_per_file,", "94": "                \"allowed_extensions\": self.security.allowed_extensions,", "95": "            },", "96": "            \"performance\": {", "97": "                \"enable_parallel\": self.performance.enable_parallel,", "98": "                \"max_workers\": self.performance.max_workers,", "99": "                \"enable_caching\": self.performance.enable_caching,", "100": "                \"cache_dir\": self.performance.cache_dir,", "101": "            },", "102": "            \"analysis\": {", "103": "                \"similarity_threshold\": self.analysis.similarity_threshold,", "104": "                \"min_coverage_lines\": self.analysis.min_coverage_lines,", "105": "                \"max_results\": self.analysis.max_results,", "106": "            },", "107": "        }", "108": "", "109": "", "110": "def load_config_file(config_path: Path) -> dict[str, Any]:", "111": "    \"\"\"", "112": "    Load configuration from file.", "113": "", "114": "    Args:", "115": "        config_path: Path to config file (.yaml, .yml, or .toml)", "116": "", "117": "    Returns:", "118": "        Configuration dictionary", "119": "", "120": "    Raises:", "121": "        ConfigurationError: If file cannot be loaded", "122": "    \"\"\"", "123": "    if not config_path.exists():", "124": "        raise ConfigurationError(f\"Config file not found: {config_path}\")", "125": "", "126": "    suffix = config_path.suffix.lower()", "127": "", "128": "    try:", "129": "        with open(config_path, \"rb\") as f:", "130": "            if suffix in (\".yaml\", \".yml\"):", "131": "                data = yaml.safe_load(f)", "132": "            elif suffix == \".toml\":", "133": "                data = tomllib.load(f)", "134": "            else:", "135": "                raise ConfigurationError(", "136": "                    f\"Unsupported config file format: {suffix}. \"", "137": "                    \"Supported formats: .yaml, .yml, .toml\"", "138": "                )", "139": "", "140": "        if not isinstance(data, dict):", "141": "            raise ConfigurationError(\"Config file must contain a dictionary\")", "142": "", "143": "        return data", "144": "", "145": "    except yaml.YAMLError as e:", "146": "        raise ConfigurationError(f\"Invalid YAML in config file: {e}\")", "147": "    except tomllib.TOMLDecodeError as e:", "148": "        raise ConfigurationError(f\"Invalid TOML in config file: {e}\")", "149": "    except Exception as e:", "150": "        raise ConfigurationError(f\"Error reading config file: {e}\")", "151": "", "152": "", "153": "def find_config_file(start_path: Path = None) -> Optional[Path]:", "154": "    \"\"\"", "155": "    Find config file in current directory or parent directories.", "156": "", "157": "    Args:", "158": "        start_path: Starting directory (default: current directory)", "159": "", "160": "    Returns:", "161": "        Path to config file or None if not found", "162": "    \"\"\"", "163": "    if start_path is None:", "164": "        start_path = Path.cwd()", "165": "", "166": "    config_names = [\".testiq.yaml\", \".testiq.yml\", \".testiq.toml\", \"testiq.yaml\", \"testiq.yml\"]", "167": "", "168": "    # Search current directory and parents", "169": "    current = start_path.resolve()", "170": "    for _ in range(10):  # Limit search depth", "171": "        for config_name in config_names:", "172": "            config_path = current / config_name", "173": "            if config_path.exists():", "174": "                return config_path", "175": "", "176": "        parent = current.parent", "177": "        if parent == current:  # Reached root", "178": "            break", "179": "        current = parent", "180": "", "181": "    return None", "182": "", "183": "", "184": "def load_config_from_env() -> dict[str, Any]:", "185": "    \"\"\"", "186": "    Load configuration from environment variables.", "187": "", "188": "    Environment variables:", "189": "        TESTIQ_LOG_LEVEL: Log level", "190": "        TESTIQ_LOG_FILE: Log file path", "191": "        TESTIQ_MAX_FILE_SIZE: Maximum file size in bytes", "192": "        TESTIQ_MAX_TESTS: Maximum number of tests", "193": "        TESTIQ_ENABLE_PARALLEL: Enable parallel processing (true/false)", "194": "        TESTIQ_MAX_WORKERS: Maximum number of workers", "195": "        TESTIQ_SIMILARITY_THRESHOLD: Similarity threshold (0.0-1.0)", "196": "", "197": "    Returns:", "198": "        Configuration dictionary", "199": "    \"\"\"", "200": "    config: dict[str, Any] = {}", "201": "", "202": "    # Log config", "203": "    if \"TESTIQ_LOG_LEVEL\" in os.environ:", "204": "        config.setdefault(\"log\", {})[\"level\"] = os.environ[\"TESTIQ_LOG_LEVEL\"]", "205": "    if \"TESTIQ_LOG_FILE\" in os.environ:", "206": "        config.setdefault(\"log\", {})[\"file\"] = os.environ[\"TESTIQ_LOG_FILE\"]", "207": "", "208": "    # Security config", "209": "    if \"TESTIQ_MAX_FILE_SIZE\" in os.environ:", "210": "        config.setdefault(\"security\", {})[\"max_file_size\"] = int(os.environ[\"TESTIQ_MAX_FILE_SIZE\"])", "211": "    if \"TESTIQ_MAX_TESTS\" in os.environ:", "212": "        config.setdefault(\"security\", {})[\"max_tests\"] = int(os.environ[\"TESTIQ_MAX_TESTS\"])", "213": "", "214": "    # Performance config", "215": "    if \"TESTIQ_ENABLE_PARALLEL\" in os.environ:", "216": "        config.setdefault(\"performance\", {})[\"enable_parallel\"] = (", "217": "            os.environ[\"TESTIQ_ENABLE_PARALLEL\"].lower() == \"true\"", "218": "        )", "219": "    if \"TESTIQ_MAX_WORKERS\" in os.environ:", "220": "        config.setdefault(\"performance\", {})[\"max_workers\"] = int(os.environ[\"TESTIQ_MAX_WORKERS\"])", "221": "", "222": "    # Analysis config", "223": "    if \"TESTIQ_SIMILARITY_THRESHOLD\" in os.environ:", "224": "        config.setdefault(\"analysis\", {})[\"similarity_threshold\"] = float(", "225": "            os.environ[\"TESTIQ_SIMILARITY_THRESHOLD\"]", "226": "        )", "227": "", "228": "    return config", "229": "", "230": "", "231": "def load_config(config_path: Optional[Path] = None) -> TestIQConfig:", "232": "    \"\"\"", "233": "    Load configuration from file and environment.", "234": "", "235": "    Priority (highest to lowest):", "236": "        1. Environment variables", "237": "        2. Specified config file", "238": "        3. Auto-discovered config file", "239": "        4. Default values", "240": "", "241": "    Args:", "242": "        config_path: Path to config file (optional)", "243": "", "244": "    Returns:", "245": "        TestIQ configuration", "246": "    \"\"\"", "247": "    config_data: dict[str, Any] = {}", "248": "", "249": "    # 1. Load from auto-discovered file", "250": "    if config_path is None:", "251": "        config_path = find_config_file()", "252": "", "253": "    # 2. Load from specified or discovered file", "254": "    if config_path:", "255": "        file_config = load_config_file(config_path)", "256": "        config_data = _deep_merge(config_data, file_config)", "257": "", "258": "    # 3. Override with environment variables", "259": "    env_config = load_config_from_env()", "260": "    config_data = _deep_merge(config_data, env_config)", "261": "", "262": "    # 4. Create config with defaults", "263": "    return TestIQConfig.from_dict(config_data)", "264": "", "265": "", "266": "def _deep_merge(base: dict[str, Any], override: dict[str, Any]) -> dict[str, Any]:", "267": "    \"\"\"Deep merge two dictionaries.\"\"\"", "268": "    result = base.copy()", "269": "    for key, value in override.items():", "270": "        if key in result and isinstance(result[key], dict) and isinstance(value, dict):", "271": "            result[key] = _deep_merge(result[key], value)", "272": "        else:", "273": "            result[key] = value", "274": "    return result"}, "src/testiq/logging_config.py": {"1": "\"\"\"", "2": "Structured logging configuration for TestIQ.", "3": "Provides enterprise-grade logging with rotation, levels, and multiple handlers.", "4": "\"\"\"", "5": "", "6": "import logging", "7": "import logging.handlers", "8": "import sys", "9": "from pathlib import Path", "10": "from typing import Optional", "11": "", "12": "", "13": "class StructuredFormatter(logging.Formatter):", "14": "    \"\"\"Custom formatter with structured output.\"\"\"", "15": "", "16": "    COLORS = {", "17": "        \"DEBUG\": \"\\033[36m\",  # Cyan", "18": "        \"INFO\": \"\\033[32m\",  # Green", "19": "        \"WARNING\": \"\\033[33m\",  # Yellow", "20": "        \"ERROR\": \"\\033[31m\",  # Red", "21": "        \"CRITICAL\": \"\\033[35m\",  # Magenta", "22": "        \"RESET\": \"\\033[0m\",", "23": "    }", "24": "", "25": "    def format(self, record: logging.LogRecord) -> str:", "26": "        \"\"\"Format log record with colors and structure.\"\"\"", "27": "        if hasattr(sys.stderr, \"isatty\") and sys.stderr.isatty():", "28": "            color = self.COLORS.get(record.levelname, self.COLORS[\"RESET\"])", "29": "            reset = self.COLORS[\"RESET\"]", "30": "            record.levelname = f\"{color}{record.levelname}{reset}\"", "31": "", "32": "        # Add context if available", "33": "        if hasattr(record, \"test_name\"):", "34": "            record.msg = f\"[{record.test_name}] {record.msg}\"", "35": "        if hasattr(record, \"file_path\"):", "36": "            record.msg = f\"[{record.file_path}] {record.msg}\"", "37": "", "38": "        return super().format(record)", "39": "", "40": "", "41": "def setup_logging(", "42": "    level: str = \"INFO\",", "43": "    log_file: Optional[Path] = None,", "44": "    enable_rotation: bool = True,", "45": "    max_bytes: int = 10 * 1024 * 1024,  # 10MB", "46": "    backup_count: int = 5,", "47": ") -> logging.Logger:", "48": "    \"\"\"", "49": "    Setup structured logging for TestIQ.", "50": "", "51": "    Args:", "52": "        level: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)", "53": "        log_file: Path to log file (if None, logs only to console)", "54": "        enable_rotation: Enable log file rotation", "55": "        max_bytes: Maximum size of log file before rotation", "56": "        backup_count: Number of backup log files to keep", "57": "", "58": "    Returns:", "59": "        Configured logger instance", "60": "    \"\"\"", "61": "    logger = logging.getLogger(\"testiq\")", "62": "    logger.setLevel(getattr(logging, level.upper()))", "63": "    logger.propagate = False", "64": "", "65": "    # Remove existing handlers", "66": "    logger.handlers.clear()", "67": "", "68": "    # Console handler with colors", "69": "    console_handler = logging.StreamHandler(sys.stderr)", "70": "    console_handler.setLevel(logging.INFO)", "71": "    console_formatter = StructuredFormatter(", "72": "        \"%(asctime)s | %(levelname)-8s | %(name)s | %(message)s\",", "73": "        datefmt=\"%Y-%m-%d %H:%M:%S\",", "74": "    )", "75": "    console_handler.setFormatter(console_formatter)", "76": "    logger.addHandler(console_handler)", "77": "", "78": "    # File handler with rotation", "79": "    if log_file:", "80": "        log_file.parent.mkdir(parents=True, exist_ok=True)", "81": "", "82": "        if enable_rotation:", "83": "            file_handler: logging.Handler = logging.handlers.RotatingFileHandler(", "84": "                log_file,", "85": "                maxBytes=max_bytes,", "86": "                backupCount=backup_count,", "87": "                encoding=\"utf-8\",", "88": "            )", "89": "        else:", "90": "            file_handler = logging.FileHandler(log_file, encoding=\"utf-8\")", "91": "", "92": "        file_handler.setLevel(logging.DEBUG)", "93": "        file_formatter = logging.Formatter(", "94": "            \"%(asctime)s | %(levelname)-8s | %(name)s | %(funcName)s:%(lineno)d | %(message)s\",", "95": "            datefmt=\"%Y-%m-%d %H:%M:%S\",", "96": "        )", "97": "        file_handler.setFormatter(file_formatter)", "98": "        logger.addHandler(file_handler)", "99": "", "100": "    return logger", "101": "", "102": "", "103": "def get_logger(name: str = \"testiq\") -> logging.Logger:", "104": "    \"\"\"Get or create a logger instance.\"\"\"", "105": "    return logging.getLogger(name)"}, "tests/test_cli.py": {"1": "\"\"\"Tests for TestIQ CLI module.\"\"\"", "2": "", "3": "import json", "4": "", "5": "import pytest", "6": "from click.testing import CliRunner", "7": "", "8": "from testiq.cli import main", "9": "", "10": "", "11": "@pytest.fixture", "12": "def runner():", "13": "    \"\"\"Create a CLI runner for testing.\"\"\"", "14": "    return CliRunner()", "15": "", "16": "", "17": "@pytest.fixture", "18": "def sample_coverage_data(tmp_path):", "19": "    \"\"\"Create a sample coverage data file.\"\"\"", "20": "    coverage_data = {", "21": "        \"test_user_login_1\": {\"auth.py\": [10, 11, 12, 15, 20], \"user.py\": [5, 6, 7]},", "22": "        \"test_user_login_2\": {\"auth.py\": [10, 11, 12, 15, 20], \"user.py\": [5, 6, 7]},", "23": "        \"test_admin_login\": {\"auth.py\": [10, 11, 12, 15, 20, 30], \"admin.py\": [50]},", "24": "    }", "25": "", "26": "    coverage_file = tmp_path / \"coverage.json\"", "27": "    coverage_file.write_text(json.dumps(coverage_data, indent=2))", "28": "", "29": "    return coverage_file", "30": "", "31": "", "32": "class TestCLI:", "33": "    \"\"\"Test suite for CLI commands.\"\"\"", "34": "", "35": "    def test_version(self, runner):", "36": "        \"\"\"Test --version flag.\"\"\"", "37": "        result = runner.invoke(main, [\"--version\"])", "38": "", "39": "        assert result.exit_code == 0", "40": "        assert \"testiq\" in result.output.lower() or \"version\" in result.output.lower()", "41": "", "42": "    def test_help(self, runner):", "43": "        \"\"\"Test --help flag.\"\"\"", "44": "        result = runner.invoke(main, [\"--help\"])", "45": "", "46": "        assert result.exit_code == 0", "47": "        assert \"TestIQ\" in result.output", "48": "        assert \"Intelligent Test Analysis\" in result.output", "49": "", "50": "    def test_demo_command(self, runner):", "51": "        \"\"\"Test demo command.\"\"\"", "52": "        result = runner.invoke(main, [\"demo\"])", "53": "", "54": "        assert result.exit_code == 0", "55": "        assert \"demo\" in result.output.lower() or \"Exact Duplicates\" in result.output", "56": "", "57": "    def test_analyze_command(self, runner, sample_coverage_data):", "58": "        \"\"\"Test analyze command with valid data.\"\"\"", "59": "        result = runner.invoke(main, [\"analyze\", str(sample_coverage_data)])", "60": "", "61": "        assert result.exit_code == 0", "62": "", "63": "    def test_analyze_with_threshold(self, runner, sample_coverage_data):", "64": "        \"\"\"Test analyze command with custom threshold.\"\"\"", "65": "        result = runner.invoke(main, [\"analyze\", str(sample_coverage_data), \"--threshold\", \"0.8\"])", "66": "", "67": "        assert result.exit_code == 0", "68": "", "69": "    def test_analyze_json_format(self, runner, sample_coverage_data, tmp_path):", "70": "        \"\"\"Test analyze command with JSON output.\"\"\"", "71": "        output_file = tmp_path / \"output.json\"", "72": "", "73": "        result = runner.invoke(", "74": "            main,", "75": "            [", "76": "                \"analyze\",", "77": "                str(sample_coverage_data),", "78": "                \"--format\",", "79": "                \"json\",", "80": "                \"--output\",", "81": "                str(output_file),", "82": "            ],", "83": "        )", "84": "", "85": "        assert result.exit_code == 0", "86": "        assert output_file.exists()", "87": "", "88": "        # Verify JSON is valid", "89": "        with open(output_file) as f:", "90": "            data = json.load(f)", "91": "            assert \"exact_duplicates\" in data", "92": "            assert \"subset_duplicates\" in data", "93": "            assert \"similar_tests\" in data", "94": "", "95": "    def test_analyze_markdown_format(self, runner, sample_coverage_data, tmp_path):", "96": "        \"\"\"Test analyze command with markdown output.\"\"\"", "97": "        output_file = tmp_path / \"report.md\"", "98": "", "99": "        result = runner.invoke(", "100": "            main,", "101": "            [", "102": "                \"analyze\",", "103": "                str(sample_coverage_data),", "104": "                \"--format\",", "105": "                \"markdown\",", "106": "                \"--output\",", "107": "                str(output_file),", "108": "            ],", "109": "        )", "110": "", "111": "        assert result.exit_code == 0", "112": "        assert output_file.exists()", "113": "", "114": "        content = output_file.read_text()", "115": "        assert \"# Test Duplication Report\" in content", "116": "", "117": "    def test_analyze_nonexistent_file(self, runner):", "118": "        \"\"\"Test analyze command with non-existent file.\"\"\"", "119": "        result = runner.invoke(main, [\"analyze\", \"nonexistent.json\"])", "120": "", "121": "        assert result.exit_code != 0", "122": "", "123": "    def test_analyze_invalid_json(self, runner, tmp_path):", "124": "        \"\"\"Test analyze command with invalid JSON.\"\"\"", "125": "        bad_file = tmp_path / \"bad.json\"", "126": "        bad_file.write_text(\"not valid json {\")", "127": "", "128": "        result = runner.invoke(main, [\"analyze\", str(bad_file)])", "129": "", "130": "        assert result.exit_code != 0", "131": "        assert \"error\" in result.output.lower() or \"invalid\" in result.output.lower()", "132": "", "133": "    def test_analyze_with_all_options(self, runner, sample_coverage_data, tmp_path):", "134": "        \"\"\"Test analyze command with all options.\"\"\"", "135": "        output_file = tmp_path / \"full_report.json\"", "136": "", "137": "        result = runner.invoke(", "138": "            main,", "139": "            [", "140": "                \"analyze\",", "141": "                str(sample_coverage_data),", "142": "                \"--threshold\",", "143": "                \"0.75\",", "144": "                \"--format\",", "145": "                \"json\",", "146": "                \"--output\",", "147": "                str(output_file),", "148": "            ],", "149": "        )", "150": "", "151": "        assert result.exit_code == 0", "152": "        assert output_file.exists()", "153": "", "154": "    def test_analyze_stdout_output(self, runner, sample_coverage_data):", "155": "        \"\"\"Test analyze command outputs to stdout by default.\"\"\"", "156": "        result = runner.invoke(main, [\"analyze\", str(sample_coverage_data), \"--format\", \"json\"])", "157": "", "158": "        assert result.exit_code == 0", "159": "        # Output may contain logging lines, find the JSON block", "160": "        output = result.output", "161": "", "162": "        # Find JSON start", "163": "        json_start = output.find(\"{\")", "164": "        if json_start >= 0:", "165": "            # Find matching closing brace", "166": "            json_text = output[json_start:]", "167": "            # Try to parse JSON", "168": "            try:", "169": "                data = json.loads(json_text)", "170": "                assert \"exact_duplicates\" in data", "171": "            except json.JSONDecodeError:", "172": "                # JSON might be split by logging, just verify output exists", "173": "                assert \"{\" in output and \"}\" in output", "174": "        else:", "175": "            # No JSON found, just verify output exists", "176": "            assert len(output) > 0", "177": "", "178": "", "179": "class TestCLIIntegration:", "180": "    \"\"\"Integration tests for CLI.\"\"\"", "181": "", "182": "    def test_full_workflow(self, runner, tmp_path):", "183": "        \"\"\"Test a complete workflow: create data, analyze, check output.\"\"\"", "184": "        # Create coverage data", "185": "        coverage_data = {", "186": "            \"test_a\": {\"file.py\": [1, 2, 3]},", "187": "            \"test_b\": {\"file.py\": [1, 2, 3]},", "188": "            \"test_c\": {\"file.py\": [10, 20]},", "189": "        }", "190": "", "191": "        input_file = tmp_path / \"coverage.json\"", "192": "        input_file.write_text(json.dumps(coverage_data))", "193": "", "194": "        output_file = tmp_path / \"report.json\"", "195": "", "196": "        # Run analysis", "197": "        result = runner.invoke(", "198": "            main, [\"analyze\", str(input_file), \"--format\", \"json\", \"--output\", str(output_file)]", "199": "        )", "200": "", "201": "        assert result.exit_code == 0", "202": "        assert output_file.exists()", "203": "", "204": "        # Verify results", "205": "        with open(output_file) as f:", "206": "            data = json.load(f)", "207": "            # Should find test_a and test_b as duplicates", "208": "            assert len(data[\"exact_duplicates\"]) >= 1", "209": "            duplicates = data[\"exact_duplicates\"][0]", "210": "            assert set(duplicates) == {\"test_a\", \"test_b\"}", "211": "", "212": "    def test_threshold_affects_results(self, runner, sample_coverage_data, tmp_path):", "213": "        \"\"\"Test that threshold parameter affects similarity results.\"\"\"", "214": "        output_low = tmp_path / \"low_threshold.json\"", "215": "        output_high = tmp_path / \"high_threshold.json\"", "216": "", "217": "        # Run with low threshold", "218": "        runner.invoke(", "219": "            main,", "220": "            [", "221": "                \"analyze\",", "222": "                str(sample_coverage_data),", "223": "                \"--threshold\",", "224": "                \"0.5\",", "225": "                \"--format\",", "226": "                \"json\",", "227": "                \"--output\",", "228": "                str(output_low),", "229": "            ],", "230": "        )", "231": "", "232": "        # Run with high threshold", "233": "        runner.invoke(", "234": "            main,", "235": "            [", "236": "                \"analyze\",", "237": "                str(sample_coverage_data),", "238": "                \"--threshold\",", "239": "                \"0.9\",", "240": "                \"--format\",", "241": "                \"json\",", "242": "                \"--output\",", "243": "                str(output_high),", "244": "            ],", "245": "        )", "246": "", "247": "        # Low threshold should find more similar tests", "248": "        with open(output_low) as f:", "249": "            low_data = json.load(f)", "250": "", "251": "        with open(output_high) as f:", "252": "            high_data = json.load(f)", "253": "", "254": "        assert len(low_data[\"similar_tests\"]) >= len(high_data[\"similar_tests\"])", "255": "", "256": "", "257": "class TestCLIFormats:", "258": "    \"\"\"Test different output formats.\"\"\"", "259": "", "260": "    def test_html_format(self, runner, sample_coverage_data, tmp_path):", "261": "        \"\"\"Test HTML output format.\"\"\"", "262": "        output_file = tmp_path / \"report.html\"", "263": "        result = runner.invoke(", "264": "            main,", "265": "            [\"analyze\", str(sample_coverage_data), \"--format\", \"html\", \"--output\", str(output_file)],", "266": "        )", "267": "        assert result.exit_code == 0", "268": "        assert output_file.exists()", "269": "        content = output_file.read_text()", "270": "        assert \"<html\" in content.lower()", "271": "", "272": "    def test_html_without_output_fails(self, runner, sample_coverage_data):", "273": "        \"\"\"Test HTML format requires output file.\"\"\"", "274": "        result = runner.invoke(main, [\"analyze\", str(sample_coverage_data), \"--format\", \"html\"])", "275": "        assert result.exit_code != 0", "276": "        assert \"requires --output\" in result.output.lower()", "277": "", "278": "    def test_csv_format(self, runner, sample_coverage_data, tmp_path):", "279": "        \"\"\"Test CSV output format.\"\"\"", "280": "        output_file = tmp_path / \"report.csv\"", "281": "        result = runner.invoke(", "282": "            main,", "283": "            [\"analyze\", str(sample_coverage_data), \"--format\", \"csv\", \"--output\", str(output_file)],", "284": "        )", "285": "        assert result.exit_code == 0", "286": "        assert output_file.exists()", "287": "", "288": "    def test_csv_without_output_fails(self, runner, sample_coverage_data):", "289": "        \"\"\"Test CSV format requires output file.\"\"\"", "290": "        result = runner.invoke(main, [\"analyze\", str(sample_coverage_data), \"--format\", \"csv\"])", "291": "        assert result.exit_code != 0", "292": "        assert \"requires --output\" in result.output.lower()", "293": "", "294": "    def test_text_format_ignores_output(self, runner, sample_coverage_data, tmp_path):", "295": "        \"\"\"Test text format ignores output file.\"\"\"", "296": "        output_file = tmp_path / \"ignored.txt\"", "297": "        result = runner.invoke(", "298": "            main,", "299": "            [\"analyze\", str(sample_coverage_data), \"--format\", \"text\", \"--output\", str(output_file)],", "300": "        )", "301": "        assert result.exit_code == 0", "302": "        # Text format displays to console, not to file", "303": "        assert not output_file.exists() or output_file.stat().st_size == 0", "304": "", "305": "", "306": "class TestCLIQualityGate:", "307": "    \"\"\"Test quality gate functionality.\"\"\"", "308": "", "309": "    def test_quality_gate_pass(self, runner, tmp_path):", "310": "        \"\"\"Test quality gate passes with good code.\"\"\"", "311": "        coverage_data = {", "312": "            \"test_a\": {\"file.py\": [1, 2]},", "313": "            \"test_b\": {\"file.py\": [3, 4]},", "314": "            \"test_c\": {\"file.py\": [5, 6]},", "315": "        }", "316": "        coverage_file = tmp_path / \"coverage.json\"", "317": "        coverage_file.write_text(json.dumps(coverage_data))", "318": "", "319": "        result = runner.invoke(", "320": "            main, [\"analyze\", str(coverage_file), \"--quality-gate\", \"--max-duplicates\", \"0\"]", "321": "        )", "322": "        assert result.exit_code == 0", "323": "        assert \"PASSED\" in result.output", "324": "", "325": "    def test_quality_gate_fail(self, runner, tmp_path):", "326": "        \"\"\"Test quality gate fails with duplicates.\"\"\"", "327": "        coverage_data = {", "328": "            \"test_a\": {\"file.py\": [1, 2, 3]},", "329": "            \"test_b\": {\"file.py\": [1, 2, 3]},", "330": "        }", "331": "        coverage_file = tmp_path / \"coverage.json\"", "332": "        coverage_file.write_text(json.dumps(coverage_data))", "333": "", "334": "        result = runner.invoke(", "335": "            main, [\"analyze\", str(coverage_file), \"--quality-gate\", \"--max-duplicates\", \"0\"]", "336": "        )", "337": "        assert result.exit_code == 2", "338": "        assert \"FAILED\" in result.output", "339": "", "340": "    def test_save_baseline(self, runner, sample_coverage_data, tmp_path):", "341": "        \"\"\"Test saving analysis baseline.\"\"\"", "342": "        baseline_file = tmp_path / \"test_baseline\"", "343": "        result = runner.invoke(", "344": "            main, [\"analyze\", str(sample_coverage_data), \"--save-baseline\", str(baseline_file)]", "345": "        )", "346": "        assert result.exit_code == 0", "347": "        assert \"saved\" in result.output.lower()", "348": "", "349": "", "350": "class TestCLIQualityScore:", "351": "    \"\"\"Test quality-score command.\"\"\"", "352": "", "353": "    def test_quality_score_with_output(self, runner, sample_coverage_data, tmp_path):", "354": "        \"\"\"Test quality score with output file.\"\"\"", "355": "        output_file = tmp_path / \"quality.json\"", "356": "        result = runner.invoke(", "357": "            main, [\"quality-score\", str(sample_coverage_data), \"--output\", str(output_file)]", "358": "        )", "359": "        # May fail due to Rich formatting issues, but we test file output", "360": "        if result.exit_code == 0:", "361": "            assert output_file.exists()", "362": "            with open(output_file) as f:", "363": "                data = json.load(f)", "364": "                assert \"score\" in data", "365": "                assert \"recommendations\" in data", "366": "                assert \"statistics\" in data", "367": "", "368": "", "369": "class TestCLIBaseline:", "370": "    \"\"\"Test baseline management commands.\"\"\"", "371": "", "372": "    def test_baseline_list_empty(self, runner, tmp_path, monkeypatch):", "373": "        \"\"\"Test listing baselines when none exist.\"\"\"", "374": "        # Set baseline dir to temp location", "375": "        baseline_dir = tmp_path / \".testiq\" / \"baselines\"", "376": "        baseline_dir.mkdir(parents=True, exist_ok=True)", "377": "        monkeypatch.setenv(\"HOME\", str(tmp_path))", "378": "        result = runner.invoke(main, [\"baseline\", \"list\"])", "379": "        # Exit code may vary, just check output", "380": "        assert \"No baselines\" in result.output or len(result.output) > 0", "381": "", "382": "    def test_baseline_show_nonexistent(self, runner, tmp_path, monkeypatch):", "383": "        \"\"\"Test showing non-existent baseline.\"\"\"", "384": "        baseline_dir = tmp_path / \".testiq\" / \"baselines\"", "385": "        baseline_dir.mkdir(parents=True, exist_ok=True)", "386": "        monkeypatch.setenv(\"HOME\", str(tmp_path))", "387": "        result = runner.invoke(main, [\"baseline\", \"show\", \"nonexistent\"])", "388": "        # Should fail or show not found", "389": "        assert result.exit_code != 0 or \"not found\" in result.output.lower()", "390": "", "391": "    def test_baseline_delete_nonexistent(self, runner, tmp_path, monkeypatch):", "392": "        \"\"\"Test deleting non-existent baseline.\"\"\"", "393": "        baseline_dir = tmp_path / \".testiq\" / \"baselines\"", "394": "        baseline_dir.mkdir(parents=True, exist_ok=True)", "395": "        monkeypatch.setenv(\"HOME\", str(tmp_path))", "396": "        result = runner.invoke(main, [\"baseline\", \"delete\", \"nonexistent\", \"--force\"])", "397": "        # Should fail or show not found", "398": "        assert result.exit_code != 0 or \"not found\" in result.output.lower()", "399": "", "400": "", "401": "class TestCLIConfig:", "402": "    \"\"\"Test configuration handling.\"\"\"", "403": "", "404": "    def test_custom_config_file(self, runner, tmp_path):", "405": "        \"\"\"Test loading custom config file.\"\"\"", "406": "        config_file = tmp_path / \"testiq.yaml\"", "407": "        config_file.write_text(\"\"\"", "408": "analysis:", "409": "  similarity_threshold: 0.95", "410": "", "411": "performance:", "412": "  enable_parallel: false", "413": "\"\"\")", "414": "        coverage_data = {\"test_a\": {\"file.py\": [1, 2]}}", "415": "        coverage_file = tmp_path / \"coverage.json\"", "416": "        coverage_file.write_text(json.dumps(coverage_data))", "417": "", "418": "        result = runner.invoke(", "419": "            main, [\"--config\", str(config_file), \"analyze\", str(coverage_file)]", "420": "        )", "421": "        assert result.exit_code == 0", "422": "", "423": "    def test_log_level_option(self, runner, sample_coverage_data):", "424": "        \"\"\"Test setting log level.\"\"\"", "425": "        result = runner.invoke(main, [\"--log-level\", \"DEBUG\", \"analyze\", str(sample_coverage_data)])", "426": "        assert result.exit_code == 0", "427": "", "428": "    def test_log_file_option(self, runner, sample_coverage_data, tmp_path):", "429": "        \"\"\"Test setting log file.\"\"\"", "430": "        log_file = tmp_path / \"testiq.log\"", "431": "        result = runner.invoke(", "432": "            main, [\"--log-file\", str(log_file), \"analyze\", str(sample_coverage_data)]", "433": "        )", "434": "        assert result.exit_code == 0", "435": "", "436": "", "437": "class TestCLIErrorHandling:", "438": "    \"\"\"Test error handling in CLI.\"\"\"", "439": "", "440": "    def test_invalid_coverage_structure(self, runner, tmp_path):", "441": "        \"\"\"Test handling invalid coverage data structure.\"\"\"", "442": "        bad_data = {\"test1\": \"not a dict\"}", "443": "        coverage_file = tmp_path / \"bad.json\"", "444": "        coverage_file.write_text(json.dumps(bad_data))", "445": "", "446": "        result = runner.invoke(main, [\"analyze\", str(coverage_file)])", "447": "        assert result.exit_code != 0", "448": "", "449": "    def test_security_violation(self, runner, tmp_path):", "450": "        \"\"\"Test security validation failures.\"\"\"", "451": "        # Create file with invalid extension", "452": "        bad_file = tmp_path / \"test.exe\"", "453": "        bad_file.write_text(\"{}\")", "454": "", "455": "        result = runner.invoke(main, [\"analyze\", str(bad_file)])", "456": "        assert result.exit_code != 0", "457": "", "458": "    def test_config_error(self, runner, tmp_path):", "459": "        \"\"\"Test configuration error handling.\"\"\"", "460": "        bad_config = tmp_path / \"bad_config.yaml\"", "461": "        bad_config.write_text(\"invalid: yaml: content: [unclosed\")", "462": "", "463": "        coverage_data = {\"test\": {\"file.py\": [1]}}", "464": "        coverage_file = tmp_path / \"coverage.json\"", "465": "        coverage_file.write_text(json.dumps(coverage_data))", "466": "", "467": "        result = runner.invoke(", "468": "            main, [\"--config\", str(bad_config), \"analyze\", str(coverage_file)]", "469": "        )", "470": "        assert result.exit_code != 0"}, "tests/test_cicd.py": {"1": "\"\"\"", "2": "Tests for CI/CD integration module (quality gates, baselines, trends).", "3": "\"\"\"", "4": "", "5": "import json", "6": "import tempfile", "7": "from datetime import datetime", "8": "from pathlib import Path", "9": "", "10": "import pytest", "11": "", "12": "from testiq.analyzer import CoverageDuplicateFinder", "13": "from testiq.cicd import (", "14": "    AnalysisResult,", "15": "    BaselineManager,", "16": "    QualityGate,", "17": "    QualityGateChecker,", "18": "    TrendTracker,", "19": "    get_exit_code,", "20": ")", "21": "", "22": "", "23": "@pytest.fixture", "24": "def sample_finder():", "25": "    \"\"\"Create a finder with sample test data.\"\"\"", "26": "    finder = CoverageDuplicateFinder()", "27": "", "28": "    # Add 10 tests with 2 exact duplicates", "29": "    for i in range(10):", "30": "        coverage = {\"file.py\": [1, 2, 3, i + 10]}  # Each test is unique", "31": "        finder.add_test_coverage(f\"test_{i}\", coverage)", "32": "", "33": "    # Add exact duplicates (overwrite test_0 and test_1)", "34": "    finder.add_test_coverage(\"test_dup_0\", {\"file.py\": [1, 2, 3, 100]})", "35": "    finder.add_test_coverage(\"test_dup_1\", {\"file.py\": [1, 2, 3, 100]})", "36": "", "37": "    return finder", "38": "", "39": "", "40": "@pytest.fixture", "41": "def sample_result():", "42": "    \"\"\"Create a sample analysis result.\"\"\"", "43": "    return AnalysisResult(", "44": "        timestamp=datetime.now().isoformat(),", "45": "        total_tests=100,", "46": "        exact_duplicates=10,", "47": "        duplicate_groups=5,", "48": "        subset_duplicates=8,", "49": "        similar_pairs=15,", "50": "        duplicate_percentage=10.0,", "51": "        threshold=0.9,", "52": "    )", "53": "", "54": "", "55": "class TestQualityGate:", "56": "    \"\"\"Tests for QualityGate.\"\"\"", "57": "", "58": "    def test_default_gate(self):", "59": "        \"\"\"Test default quality gate settings.\"\"\"", "60": "        gate = QualityGate()", "61": "        assert gate.max_duplicates is None", "62": "        assert gate.max_duplicate_percentage is None", "63": "        assert gate.fail_on_increase is True  # Default is True", "64": "", "65": "    def test_custom_gate(self):", "66": "        \"\"\"Test custom quality gate settings.\"\"\"", "67": "        gate = QualityGate(", "68": "            max_duplicates=5,", "69": "            max_duplicate_percentage=10.0,", "70": "            fail_on_increase=True,", "71": "        )", "72": "        assert gate.max_duplicates == 5", "73": "        assert gate.max_duplicate_percentage == 10.0", "74": "        assert gate.fail_on_increase is True", "75": "", "76": "", "77": "class TestQualityGateChecker:", "78": "    \"\"\"Tests for QualityGateChecker.\"\"\"", "79": "", "80": "    def test_passes_with_no_limits(self, sample_finder):", "81": "        \"\"\"Test that gate passes with no limits set.\"\"\"", "82": "        gate = QualityGate()", "83": "        checker = QualityGateChecker(gate)", "84": "", "85": "        passed, details = checker.check(sample_finder, 0.9)", "86": "", "87": "        assert passed is True", "88": "        assert details[\"passed\"] is True", "89": "        assert len(details[\"failures\"]) == 0", "90": "", "91": "    def test_fails_max_duplicates(self, sample_finder):", "92": "        \"\"\"Test gate fails when exceeding max duplicates.\"\"\"", "93": "        gate = QualityGate(max_duplicates=0)", "94": "        checker = QualityGateChecker(gate)", "95": "", "96": "        passed, details = checker.check(sample_finder, 0.9)", "97": "", "98": "        assert passed is False", "99": "        assert details[\"passed\"] is False", "100": "        assert len(details[\"failures\"]) > 0", "101": "        assert any(\"exact duplicates\" in f.lower() for f in details[\"failures\"])", "102": "", "103": "    def test_passes_max_duplicates(self, sample_finder):", "104": "        \"\"\"Test gate passes when under max duplicates.\"\"\"", "105": "        gate = QualityGate(max_duplicates=10)", "106": "        checker = QualityGateChecker(gate)", "107": "", "108": "        passed, details = checker.check(sample_finder, 0.9)", "109": "", "110": "        assert passed is True", "111": "", "112": "    def test_fails_max_percentage(self, sample_finder):", "113": "        \"\"\"Test gate fails when exceeding max percentage.\"\"\"", "114": "        gate = QualityGate(max_duplicate_percentage=5.0)  # 5%", "115": "        checker = QualityGateChecker(gate)", "116": "", "117": "        passed, details = checker.check(sample_finder, 0.9)", "118": "", "119": "        # With 10 tests and 1 duplicate = 10%, should fail 5% limit", "120": "        assert passed is False", "121": "", "122": "    def test_fails_on_increase(self, sample_finder, sample_result):", "123": "        \"\"\"Test gate fails when duplicates increase from baseline.\"\"\"", "124": "        # Baseline has 10 duplicates, current has more", "125": "        gate = QualityGate(fail_on_increase=True)", "126": "        checker = QualityGateChecker(gate)", "127": "", "128": "        # Modify baseline to have fewer duplicates", "129": "        baseline = sample_result", "130": "        baseline.exact_duplicates = 0", "131": "", "132": "        passed, details = checker.check(sample_finder, 0.9, baseline)", "133": "", "134": "        assert passed is False", "135": "        assert any(\"increased\" in f.lower() for f in details[\"failures\"])", "136": "", "137": "", "138": "class TestBaselineManager:", "139": "    \"\"\"Tests for BaselineManager.\"\"\"", "140": "", "141": "    def test_save_and_load_baseline(self, sample_result):", "142": "        \"\"\"Test saving and loading a baseline.\"\"\"", "143": "        with tempfile.TemporaryDirectory() as tmpdir:", "144": "            manager = BaselineManager(Path(tmpdir))", "145": "", "146": "            # Save baseline", "147": "            manager.save(sample_result, \"test_baseline\")", "148": "", "149": "            # Load baseline", "150": "            loaded = manager.load(\"test_baseline\")", "151": "", "152": "            assert loaded is not None", "153": "            assert loaded.total_tests == sample_result.total_tests", "154": "            assert loaded.exact_duplicates == sample_result.exact_duplicates", "155": "            assert loaded.duplicate_percentage == sample_result.duplicate_percentage", "156": "", "157": "    def test_load_nonexistent_baseline(self):", "158": "        \"\"\"Test loading a baseline that doesn't exist.\"\"\"", "159": "        with tempfile.TemporaryDirectory() as tmpdir:", "160": "            manager = BaselineManager(Path(tmpdir))", "161": "", "162": "            loaded = manager.load(\"nonexistent\")", "163": "            assert loaded is None", "164": "", "165": "    def test_list_baselines(self, sample_result):", "166": "        \"\"\"Test listing all baselines.\"\"\"", "167": "        with tempfile.TemporaryDirectory() as tmpdir:", "168": "            manager = BaselineManager(Path(tmpdir))", "169": "", "170": "            # Save multiple baselines", "171": "            manager.save(sample_result, \"baseline1\")", "172": "            manager.save(sample_result, \"baseline2\")", "173": "", "174": "            # List baselines", "175": "            baselines = manager.list_baselines()", "176": "", "177": "            assert len(baselines) == 2", "178": "            baseline_names = [b[\"name\"] for b in baselines]", "179": "            assert \"baseline1\" in baseline_names", "180": "            assert \"baseline2\" in baseline_names", "181": "            # Verify structure includes result objects", "182": "            assert all(\"result\" in b for b in baselines)", "183": "            assert all(isinstance(b[\"result\"], AnalysisResult) for b in baselines)", "184": "", "185": "    def test_baseline_file_format(self, sample_result):", "186": "        \"\"\"Test that baseline is saved in correct JSON format.\"\"\"", "187": "        with tempfile.TemporaryDirectory() as tmpdir:", "188": "            manager = BaselineManager(Path(tmpdir))", "189": "", "190": "            manager.save(sample_result, \"test\")", "191": "", "192": "            # Read raw JSON file", "193": "            baseline_file = Path(tmpdir) / \"test.json\"", "194": "            with open(baseline_file) as f:", "195": "                data = json.load(f)", "196": "", "197": "            assert \"timestamp\" in data", "198": "            assert \"total_tests\" in data", "199": "            assert \"exact_duplicates\" in data", "200": "", "201": "    def test_creates_baseline_directory(self):", "202": "        \"\"\"Test that baseline directory is created if it doesn't exist.\"\"\"", "203": "        with tempfile.TemporaryDirectory() as tmpdir:", "204": "            baseline_dir = Path(tmpdir) / \"new_dir\"", "205": "            assert not baseline_dir.exists()", "206": "", "207": "            manager = BaselineManager(baseline_dir)", "208": "            assert baseline_dir.exists()", "209": "", "210": "", "211": "class TestTrendTracker:", "212": "    \"\"\"Tests for TrendTracker.\"\"\"", "213": "", "214": "    def test_add_and_get_history(self, sample_result):", "215": "        \"\"\"Test adding results and getting history.\"\"\"", "216": "        with tempfile.TemporaryDirectory() as tmpdir:", "217": "            history_file = Path(tmpdir) / \"history.json\"", "218": "            tracker = TrendTracker(history_file)", "219": "", "220": "            # Add multiple results", "221": "            tracker.add_result(sample_result)", "222": "", "223": "            result2 = AnalysisResult(", "224": "                timestamp=datetime.now().isoformat(),", "225": "                total_tests=110,", "226": "                exact_duplicates=8,", "227": "                duplicate_groups=4,", "228": "                subset_duplicates=6,", "229": "                similar_pairs=12,", "230": "                duplicate_percentage=7.3,", "231": "                threshold=0.9,", "232": "            )", "233": "            tracker.add_result(result2)", "234": "", "235": "            # Get history", "236": "            history = tracker.load_history()", "237": "", "238": "            assert len(history) == 2", "239": "            assert history[0][\"total_tests\"] == 100", "240": "            assert history[1][\"total_tests\"] == 110", "241": "", "242": "    def test_calculate_trend_improving(self):", "243": "        \"\"\"Test trend calculation shows improvement.\"\"\"", "244": "        with tempfile.TemporaryDirectory() as tmpdir:", "245": "            history_file = Path(tmpdir) / \"history.json\"", "246": "            tracker = TrendTracker(history_file)", "247": "", "248": "            # Add results showing improvement (fewer duplicates)", "249": "            result1 = AnalysisResult(", "250": "                timestamp=datetime.now().isoformat(),", "251": "                total_tests=100,", "252": "                exact_duplicates=20,", "253": "                duplicate_groups=10,", "254": "                subset_duplicates=15,", "255": "                similar_pairs=25,", "256": "                duplicate_percentage=20.0,", "257": "                threshold=0.9,", "258": "            )", "259": "", "260": "            result2 = AnalysisResult(", "261": "                timestamp=datetime.now().isoformat(),", "262": "                total_tests=100,", "263": "                exact_duplicates=10,", "264": "                duplicate_groups=5,", "265": "                subset_duplicates=8,", "266": "                similar_pairs=15,", "267": "                duplicate_percentage=10.0,", "268": "                threshold=0.9,", "269": "            )", "270": "", "271": "            tracker.add_result(result1)", "272": "            tracker.add_result(result2)", "273": "", "274": "            # Check if improving", "275": "            assert tracker.is_improving(\"exact_duplicates\") is True", "276": "", "277": "    def test_calculate_trend_worsening(self):", "278": "        \"\"\"Test trend calculation shows worsening.\"\"\"", "279": "        with tempfile.TemporaryDirectory() as tmpdir:", "280": "            history_file = Path(tmpdir) / \"history.json\"", "281": "            tracker = TrendTracker(history_file)", "282": "", "283": "            # Add results showing worsening (more duplicates)", "284": "            result1 = AnalysisResult(", "285": "                timestamp=datetime.now().isoformat(),", "286": "                total_tests=100,", "287": "                exact_duplicates=5,", "288": "                duplicate_groups=3,", "289": "                subset_duplicates=4,", "290": "                similar_pairs=8,", "291": "                duplicate_percentage=5.0,", "292": "                threshold=0.9,", "293": "            )", "294": "", "295": "            result2 = AnalysisResult(", "296": "                timestamp=datetime.now().isoformat(),", "297": "                total_tests=100,", "298": "                exact_duplicates=15,", "299": "                duplicate_groups=8,", "300": "                subset_duplicates=12,", "301": "                similar_pairs=20,", "302": "                duplicate_percentage=15.0,", "303": "                threshold=0.9,", "304": "            )", "305": "", "306": "            tracker.add_result(result1)", "307": "            tracker.add_result(result2)", "308": "", "309": "            # Check if worsening (not improving)", "310": "            assert tracker.is_improving(\"exact_duplicates\") is False", "311": "", "312": "    def test_trend_with_insufficient_data(self):", "313": "        \"\"\"Test trend calculation with insufficient data.\"\"\"", "314": "        with tempfile.TemporaryDirectory() as tmpdir:", "315": "            history_file = Path(tmpdir) / \"history.json\"", "316": "            tracker = TrendTracker(history_file)", "317": "", "318": "            # Empty history should return True (improving)", "319": "            assert tracker.is_improving() is True", "320": "", "321": "", "322": "class TestGetExitCode:", "323": "    \"\"\"Tests for get_exit_code helper function.\"\"\"", "324": "", "325": "    def test_exit_code_success(self):", "326": "        \"\"\"Test exit code for successful run with no duplicates.\"\"\"", "327": "        # Success: no duplicates, gate passed", "328": "        assert get_exit_code(passed=True, duplicate_count=0, total_tests=10) == 0", "329": "", "330": "    def test_exit_code_duplicates_found(self):", "331": "        \"\"\"Test exit code when duplicates are found.\"\"\"", "332": "        # Duplicates found but gate passed", "333": "        assert get_exit_code(passed=True, duplicate_count=5, total_tests=10) == 1", "334": "", "335": "    def test_exit_code_gate_failed(self):", "336": "        \"\"\"Test exit code when quality gate fails.\"\"\"", "337": "        # Gate failed", "338": "        assert get_exit_code(passed=False, duplicate_count=10, total_tests=10) == 2", "339": "", "340": "    def test_exit_code_gate_failed_priority(self):", "341": "        \"\"\"Test that gate failure takes priority over duplicates.\"\"\"", "342": "        # Gate failure (2) should override duplicates found (1)", "343": "        assert get_exit_code(passed=False, duplicate_count=5, total_tests=10) == 2", "344": "        assert get_exit_code(passed=False, duplicate_count=0, total_tests=10) == 2"}, "src/testiq/source_reader.py": {"1": "\"\"\"", "2": "Source code reader for TestIQ reports.", "3": "Reads actual source files to display in coverage comparisons.", "4": "\"\"\"", "5": "", "6": "from pathlib import Path", "7": "from typing import Optional", "8": "", "9": "", "10": "class SourceCodeReader:", "11": "    \"\"\"Read and cache source code files for display in reports.\"\"\"", "12": "", "13": "    def __init__(self) -> None:", "14": "        \"\"\"Initialize the source code reader.\"\"\"", "15": "        self._cache: dict[str, dict[int, str]] = {}", "16": "", "17": "    def read_file(self, filepath: str) -> Optional[dict[int, str]]:", "18": "        \"\"\"", "19": "        Read a source file and return line-by-line content.", "20": "", "21": "        Args:", "22": "            filepath: Path to the source file", "23": "", "24": "        Returns:", "25": "            Dictionary mapping line numbers (1-indexed) to source code lines,", "26": "            or None if file cannot be read", "27": "        \"\"\"", "28": "        if filepath in self._cache:", "29": "            return self._cache[filepath]", "30": "", "31": "        try:", "32": "            file_path = Path(filepath)", "33": "            if file_path.exists() and file_path.is_file():", "34": "                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:", "35": "                    lines = f.readlines()", "36": "                    result = {", "37": "                        i + 1: line.rstrip() for i, line in enumerate(lines)", "38": "                    }", "39": "                    self._cache[filepath] = result", "40": "                    return result", "41": "        except Exception:", "42": "            pass", "43": "", "44": "        return None", "45": "", "46": "    def read_multiple(self, filepaths: list[str]) -> dict[str, dict[int, str]]:", "47": "        \"\"\"", "48": "        Read multiple source files.", "49": "", "50": "        Args:", "51": "            filepaths: List of file paths to read", "52": "", "53": "        Returns:", "54": "            Dictionary mapping filepath to line content dictionary", "55": "        \"\"\"", "56": "        result = {}", "57": "        for filepath in filepaths:", "58": "            content = self.read_file(filepath)", "59": "            if content:", "60": "                result[filepath] = content", "61": "        return result"}, "src/testiq/performance.py": {"1": "\"\"\"", "2": "Performance optimization utilities for TestIQ.", "3": "Provides parallel processing, caching, and streaming capabilities.", "4": "\"\"\"", "5": "", "6": "import hashlib", "7": "import json", "8": "import pickle", "9": "from collections.abc import Iterator", "10": "from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor, as_completed", "11": "from functools import lru_cache", "12": "from pathlib import Path", "13": "from typing import Any, Callable, Optional", "14": "", "15": "from testiq.exceptions import AnalysisError", "16": "from testiq.logging_config import get_logger", "17": "", "18": "logger = get_logger(__name__)", "19": "", "20": "", "21": "class CacheManager:", "22": "    \"\"\"Manages caching of analysis results.\"\"\"", "23": "", "24": "    def __init__(self, cache_dir: Optional[Path] = None, enabled: bool = True) -> None:", "25": "        \"\"\"", "26": "        Initialize cache manager.", "27": "", "28": "        Args:", "29": "            cache_dir: Directory for cache files (default: ~/.testiq/cache)", "30": "            enabled: Whether caching is enabled", "31": "        \"\"\"", "32": "        self.enabled = enabled", "33": "        if cache_dir:", "34": "            self.cache_dir = Path(cache_dir)", "35": "        else:", "36": "            self.cache_dir = Path.home() / \".testiq\" / \"cache\"", "37": "", "38": "        if self.enabled:", "39": "            self.cache_dir.mkdir(parents=True, exist_ok=True)", "40": "            logger.debug(f\"Cache directory: {self.cache_dir}\")", "41": "", "42": "    def _get_cache_key(self, data: Any) -> str:", "43": "        \"\"\"Generate cache key from data.\"\"\"", "44": "        if isinstance(data, dict):", "45": "            data_str = json.dumps(data, sort_keys=True)", "46": "        else:", "47": "            data_str = str(data)", "48": "        return hashlib.sha256(data_str.encode()).hexdigest()[:16]", "49": "", "50": "    def get(self, key: str) -> Optional[Any]:", "51": "        \"\"\"", "52": "        Get cached result.", "53": "", "54": "        Args:", "55": "            key: Cache key", "56": "", "57": "        Returns:", "58": "            Cached data or None if not found", "59": "        \"\"\"", "60": "        if not self.enabled:", "61": "            return None", "62": "", "63": "        cache_file = self.cache_dir / f\"{key}.cache\"", "64": "        if cache_file.exists():", "65": "            try:", "66": "                with open(cache_file, \"rb\") as f:", "67": "                    logger.debug(f\"Cache hit: {key}\")", "68": "                    return pickle.load(f)", "69": "            except Exception as e:", "70": "                logger.warning(f\"Failed to load cache {key}: {e}\")", "71": "                return None", "72": "        return None", "73": "", "74": "    def set(self, key: str, value: Any) -> None:", "75": "        \"\"\"", "76": "        Store result in cache.", "77": "", "78": "        Args:", "79": "            key: Cache key", "80": "            value: Data to cache", "81": "        \"\"\"", "82": "        if not self.enabled:", "83": "            return", "84": "", "85": "        cache_file = self.cache_dir / f\"{key}.cache\"", "86": "        try:", "87": "            with open(cache_file, \"wb\") as f:", "88": "                pickle.dump(value, f)", "89": "            logger.debug(f\"Cached result: {key}\")", "90": "        except Exception as e:", "91": "            logger.warning(f\"Failed to save cache {key}: {e}\")", "92": "", "93": "    def clear(self) -> None:", "94": "        \"\"\"Clear all cached data.\"\"\"", "95": "        if not self.enabled:", "96": "            return", "97": "", "98": "        try:", "99": "            for cache_file in self.cache_dir.glob(\"*.cache\"):", "100": "                cache_file.unlink()", "101": "            logger.info(\"Cache cleared\")", "102": "        except Exception as e:", "103": "            logger.warning(f\"Failed to clear cache: {e}\")", "104": "", "105": "", "106": "class StreamingJSONParser:", "107": "    \"\"\"Parse large JSON files in streaming fashion.\"\"\"", "108": "", "109": "    @staticmethod", "110": "    def parse_coverage_file(file_path: Path, chunk_size: int = 1024) -> Iterator[tuple[str, dict]]:", "111": "        \"\"\"", "112": "        Parse coverage JSON file in chunks.", "113": "", "114": "        Args:", "115": "            file_path: Path to JSON file", "116": "            chunk_size: Number of tests to yield at once", "117": "", "118": "        Yields:", "119": "            (test_name, coverage_data) tuples", "120": "        \"\"\"", "121": "        try:", "122": "            with open(file_path) as f:", "123": "                data = json.load(f)", "124": "", "125": "            if not isinstance(data, dict):", "126": "                raise AnalysisError(\"Coverage file must contain a dictionary\")", "127": "", "128": "            items = list(data.items())", "129": "            for i in range(0, len(items), chunk_size):", "130": "                chunk = items[i : i + chunk_size]", "131": "                yield from chunk", "132": "", "133": "        except json.JSONDecodeError as e:", "134": "            raise AnalysisError(f\"Invalid JSON in coverage file: {e}\")", "135": "        except Exception as e:", "136": "            raise AnalysisError(f\"Error reading coverage file: {e}\")", "137": "", "138": "", "139": "class ParallelProcessor:", "140": "    \"\"\"Process tests in parallel for better performance.\"\"\"", "141": "", "142": "    def __init__(", "143": "        self, max_workers: int = 4, use_processes: bool = False, enabled: bool = True", "144": "    ) -> None:", "145": "        \"\"\"", "146": "        Initialize parallel processor.", "147": "", "148": "        Args:", "149": "            max_workers: Maximum number of parallel workers", "150": "            use_processes: Use ProcessPoolExecutor instead of ThreadPoolExecutor", "151": "            enabled: Whether parallel processing is enabled", "152": "        \"\"\"", "153": "        self.max_workers = max_workers", "154": "        self.use_processes = use_processes", "155": "        self.enabled = enabled", "156": "        logger.debug(", "157": "            f\"Parallel processing: enabled={enabled}, workers={max_workers}, \"", "158": "            f\"processes={use_processes}\"", "159": "        )", "160": "", "161": "    def map(self, func: Callable, items: list[Any], desc: str = \"Processing\") -> list[Any]:", "162": "        \"\"\"", "163": "        Map function over items in parallel.", "164": "", "165": "        Args:", "166": "            func: Function to apply to each item", "167": "            items: List of items to process", "168": "            desc: Description for logging", "169": "", "170": "        Returns:", "171": "            List of results", "172": "        \"\"\"", "173": "        if not self.enabled or len(items) < 2:", "174": "            logger.debug(f\"Sequential processing: {len(items)} items\")", "175": "            return [func(item) for item in items]", "176": "", "177": "        logger.info(f\"{desc}: {len(items)} items with {self.max_workers} workers\")", "178": "", "179": "        executor_class = ProcessPoolExecutor if self.use_processes else ThreadPoolExecutor", "180": "", "181": "        try:", "182": "            with executor_class(max_workers=self.max_workers) as executor:", "183": "                futures = {executor.submit(func, item): i for i, item in enumerate(items)}", "184": "                results = [None] * len(items)", "185": "", "186": "                for future in as_completed(futures):", "187": "                    idx = futures[future]", "188": "                    try:", "189": "                        results[idx] = future.result()", "190": "                    except Exception as e:", "191": "                        logger.error(f\"Error processing item {idx}: {e}\")", "192": "                        results[idx] = None", "193": "", "194": "                return results", "195": "", "196": "        except Exception as e:", "197": "            logger.error(f\"Parallel processing failed: {e}. Falling back to sequential.\")", "198": "            return [func(item) for item in items]", "199": "", "200": "", "201": "@lru_cache(maxsize=1024)", "202": "def compute_similarity(lines1_frozen: frozenset, lines2_frozen: frozenset) -> float:", "203": "    \"\"\"", "204": "    Compute Jaccard similarity between two sets of lines (cached).", "205": "", "206": "    Args:", "207": "        lines1_frozen: First set of lines (frozenset for hashability)", "208": "        lines2_frozen: Second set of lines", "209": "", "210": "    Returns:", "211": "        Similarity score (0.0 to 1.0)", "212": "    \"\"\"", "213": "    lines1 = set(lines1_frozen)", "214": "    lines2 = set(lines2_frozen)", "215": "", "216": "    intersection = lines1 & lines2", "217": "    union = lines1 | lines2", "218": "", "219": "    if len(union) == 0:", "220": "        return 0.0", "221": "", "222": "    return len(intersection) / len(union)", "223": "", "224": "", "225": "class ProgressTracker:", "226": "    \"\"\"Track progress of long-running operations.\"\"\"", "227": "", "228": "    def __init__(self, total: int, desc: str = \"Processing\") -> None:", "229": "        \"\"\"", "230": "        Initialize progress tracker.", "231": "", "232": "        Args:", "233": "            total: Total number of items", "234": "            desc: Description of operation", "235": "        \"\"\"", "236": "        self.total = total", "237": "        self.current = 0", "238": "        self.desc = desc", "239": "        self.last_logged_percent = -1", "240": "", "241": "    def update(self, n: int = 1) -> None:", "242": "        \"\"\"", "243": "        Update progress.", "244": "", "245": "        Args:", "246": "            n: Number of items processed", "247": "        \"\"\"", "248": "        self.current += n", "249": "        percent = int((self.current / self.total) * 100)", "250": "", "251": "        # Log at 0%, 25%, 50%, 75%, 100%", "252": "        if percent >= self.last_logged_percent + 25 or percent == 100:", "253": "            logger.info(f\"{self.desc}: {percent}% ({self.current}/{self.total})\")", "254": "            self.last_logged_percent = percent", "255": "", "256": "", "257": "def batch_iterator(items: list[Any], batch_size: int) -> Iterator[list[Any]]:", "258": "    \"\"\"", "259": "    Iterate over items in batches.", "260": "", "261": "    Args:", "262": "        items: List of items", "263": "        batch_size: Size of each batch", "264": "", "265": "    Yields:", "266": "        Batches of items", "267": "    \"\"\"", "268": "    for i in range(0, len(items), batch_size):", "269": "        yield items[i : i + batch_size]"}, "src/testiq/pytest_plugin.py": {"1": "\"\"\"", "2": "Pytest plugin for generating per-test coverage data compatible with TestIQ.", "3": "", "4": "This plugin tracks which lines each test executes and generates a JSON file", "5": "in the format TestIQ expects: {test_name: {filename: [line_numbers]}}", "6": "", "7": "Installation:", "8": "    pip install pytest-cov", "9": "", "10": "Usage:", "11": "    pytest --testiq-output=testiq_coverage.json", "12": "", "13": "Or in pytest.ini:", "14": "    [pytest]", "15": "    addopts = --testiq-output=testiq_coverage.json", "16": "\"\"\"", "17": "", "18": "import json", "19": "import sys", "20": "from pathlib import Path", "21": "from typing import Any, Dict, List, Set", "22": "", "23": "import pytest", "24": "from _pytest.config import Config", "25": "from _pytest.config.argparsing import Parser", "26": "from _pytest.nodes import Item", "27": "", "28": "", "29": "class TestIQPlugin:", "30": "    \"\"\"Pytest plugin to collect per-test coverage data for TestIQ.\"\"\"", "31": "", "32": "    def __init__(self, output_file: str) -> None:", "33": "        \"\"\"Initialize the plugin.\"\"\"", "34": "        self.output_file = output_file", "35": "        self.test_coverage: Dict[str, Dict[str, List[int]]] = {}", "36": "        self.current_test: str = \"\"", "37": "        self.traced_lines: Set[tuple[str, int]] = set()", "38": "", "39": "    def pytest_runtest_protocol(self, item: Item) -> None:", "40": "        \"\"\"Called for each test item.\"\"\"", "41": "        # Get full test name (module::class::test)", "42": "        self.current_test = item.nodeid", "43": "        self.traced_lines = set()", "44": "", "45": "        # Set up trace function for this test", "46": "        sys.settrace(self._trace_lines)", "47": "", "48": "    def _trace_lines(self, frame: Any, event: str, arg: Any) -> Any:", "49": "        \"\"\"Trace function to record line execution.\"\"\"", "50": "        if event == \"line\":", "51": "            filename = frame.f_code.co_filename", "52": "            lineno = frame.f_lineno", "53": "", "54": "            # Filter to only project files (not libraries)", "55": "            if self._is_project_file(filename):", "56": "                self.traced_lines.add((filename, lineno))", "57": "", "58": "        return self._trace_lines", "59": "", "60": "    def _is_project_file(self, filename: str) -> bool:", "61": "        \"\"\"Check if file is part of the project (not a library).\"\"\"", "62": "        # Exclude standard library and site-packages", "63": "        if \"/site-packages/\" in filename or \"/lib/python\" in filename:", "64": "            return False", "65": "        if filename.startswith(\"<\"):  # <string>, <stdin>, etc.", "66": "            return False", "67": "", "68": "        # Include files in current working directory", "69": "        try:", "70": "            Path(filename).relative_to(Path.cwd())", "71": "            return True", "72": "        except ValueError:", "73": "            return False", "74": "", "75": "    def pytest_runtest_teardown(self, item: Item) -> None:", "76": "        \"\"\"Called after each test finishes.\"\"\"", "77": "        # Stop tracing", "78": "        sys.settrace(None)", "79": "", "80": "        # Convert traced lines to TestIQ format", "81": "        if self.current_test and self.traced_lines:", "82": "            coverage: Dict[str, List[int]] = {}", "83": "", "84": "            for filename, lineno in self.traced_lines:", "85": "                # Make path relative to project root", "86": "                try:", "87": "                    rel_path = str(Path(filename).relative_to(Path.cwd()))", "88": "                except ValueError:", "89": "                    rel_path = filename", "90": "", "91": "                if rel_path not in coverage:", "92": "                    coverage[rel_path] = []", "93": "                coverage[rel_path].append(lineno)", "94": "", "95": "            # Sort line numbers", "96": "            for lines in coverage.values():", "97": "                lines.sort()", "98": "", "99": "            self.test_coverage[self.current_test] = coverage", "100": "", "101": "    def pytest_sessionfinish(self, session: Any) -> None:", "102": "        \"\"\"Called after all tests complete.\"\"\"", "103": "        if self.test_coverage:", "104": "            output_path = Path(self.output_file)", "105": "            output_path.parent.mkdir(parents=True, exist_ok=True)", "106": "", "107": "            with open(output_path, \"w\") as f:", "108": "                json.dump(self.test_coverage, f, indent=2)", "109": "", "110": "            print(f\"\\n\u2713 TestIQ coverage data saved to: {output_path}\")", "111": "            print(f\"  {len(self.test_coverage)} tests tracked\")", "112": "", "113": "", "114": "def pytest_addoption(parser: Parser) -> None:", "115": "    \"\"\"Add command-line options for TestIQ plugin.\"\"\"", "116": "    group = parser.getgroup(\"testiq\")", "117": "    group.addoption(", "118": "        \"--testiq-output\",", "119": "        action=\"store\",", "120": "        default=None,", "121": "        help=\"Output file for TestIQ per-test coverage data (JSON format)\",", "122": "    )", "123": "", "124": "", "125": "def pytest_configure(config: Config) -> None:", "126": "    \"\"\"Register the TestIQ plugin if --testiq-output is specified.\"\"\"", "127": "    output_file = config.getoption(\"--testiq-output\")", "128": "    if output_file:", "129": "        plugin = TestIQPlugin(output_file)", "130": "        config.pluginmanager.register(plugin, \"testiq_plugin\")", "131": "        config.addinivalue_line(\"markers\", \"testiq: mark test for TestIQ analysis\")"}, "tests/test_analysis.py": {"1": "\"\"\"", "2": "Tests for analysis module (quality scoring and recommendations).", "3": "\"\"\"", "4": "", "5": "import pytest", "6": "", "7": "from testiq.analysis import QualityAnalyzer, RecommendationEngine, TestQualityScore", "8": "from testiq.analyzer import CoverageDuplicateFinder", "9": "", "10": "", "11": "@pytest.fixture", "12": "def high_quality_finder():", "13": "    \"\"\"Create a finder with high-quality tests (few duplicates).\"\"\"", "14": "    finder = CoverageDuplicateFinder()", "15": "", "16": "    # 20 unique tests with good coverage", "17": "    for i in range(20):", "18": "        coverage = {", "19": "            f\"file{i % 5}.py\": list(range(i * 10 + 1, (i + 1) * 10 + 1)),  # Start from 1", "20": "            \"common.py\": [1, 2],  # Small overlap", "21": "        }", "22": "        finder.add_test_coverage(f\"test_unique_{i}\", coverage)", "23": "", "24": "    return finder", "25": "", "26": "", "27": "@pytest.fixture", "28": "def low_quality_finder():", "29": "    \"\"\"Create a finder with low-quality tests (many duplicates).\"\"\"", "30": "    finder = CoverageDuplicateFinder()", "31": "", "32": "    # 10 exact duplicates", "33": "    for i in range(10):", "34": "        finder.add_test_coverage(f\"test_duplicate_{i}\", {\"file.py\": [1, 2, 3]})", "35": "", "36": "    # 5 subset duplicates", "37": "    finder.add_test_coverage(\"test_short_1\", {\"utils.py\": [1, 2]})", "38": "    finder.add_test_coverage(\"test_long_1\", {\"utils.py\": [1, 2, 3, 4, 5]})", "39": "", "40": "    return finder", "41": "", "42": "", "43": "@pytest.fixture", "44": "def medium_quality_finder():", "45": "    \"\"\"Create a finder with medium-quality tests.\"\"\"", "46": "    finder = CoverageDuplicateFinder()", "47": "", "48": "    # Mix of unique and duplicate tests", "49": "    for i in range(5):", "50": "        lines = [1, 2, 3, i + 10] if i > 0 else [1, 2, 3, 10]  # Avoid line 0", "51": "        finder.add_test_coverage(f\"test_unique_{i}\", {f\"file{i}.py\": lines})", "52": "", "53": "    # A few duplicates", "54": "    finder.add_test_coverage(\"test_dup_1\", {\"common.py\": [10, 11, 12]})", "55": "    finder.add_test_coverage(\"test_dup_2\", {\"common.py\": [10, 11, 12]})", "56": "", "57": "    return finder", "58": "", "59": "", "60": "class TestTestQualityScore:", "61": "    \"\"\"Tests for TestQualityScore dataclass.\"\"\"", "62": "", "63": "    def test_score_initialization(self):", "64": "        \"\"\"Test creating a quality score.\"\"\"", "65": "        score = TestQualityScore(", "66": "            overall_score=85.0,", "67": "            duplication_score=90.0,", "68": "            coverage_efficiency_score=80.0,", "69": "            uniqueness_score=85.0,", "70": "            grade=\"B+\",", "71": "            recommendations=[\"Sample recommendation\"],", "72": "        )", "73": "", "74": "        assert score.overall_score == 85.0", "75": "        assert score.grade == \"B+\"", "76": "", "77": "    def test_score_perfect(self):", "78": "        \"\"\"Test perfect quality score.\"\"\"", "79": "        score = TestQualityScore(", "80": "            overall_score=100.0,", "81": "            duplication_score=100.0,", "82": "            coverage_efficiency_score=100.0,", "83": "            uniqueness_score=100.0,", "84": "            grade=\"A+\",", "85": "            recommendations=[],", "86": "        )", "87": "", "88": "        assert score.overall_score == 100.0", "89": "        assert score.grade == \"A+\"", "90": "", "91": "", "92": "class TestQualityAnalyzer:", "93": "    \"\"\"Tests for QualityAnalyzer.\"\"\"", "94": "", "95": "    def test_high_quality_score(self, high_quality_finder):", "96": "        \"\"\"Test quality score for high-quality test suite.\"\"\"", "97": "        analyzer = QualityAnalyzer(high_quality_finder)", "98": "        score = analyzer.calculate_score(threshold=0.9)", "99": "", "100": "        # Should have high scores", "101": "        assert score.overall_score >= 80.0", "102": "        assert score.duplication_score >= 80.0", "103": "        assert score.grade in [\"A+\", \"A\", \"A-\", \"B+\", \"B\"]", "104": "", "105": "    def test_low_quality_score(self, low_quality_finder):", "106": "        \"\"\"Test quality score for low-quality test suite.\"\"\"", "107": "        analyzer = QualityAnalyzer(low_quality_finder)", "108": "        score = analyzer.calculate_score(threshold=0.9)", "109": "", "110": "        # Should have low scores due to many duplicates", "111": "        assert score.overall_score < 60.0", "112": "        assert score.duplication_score < 60.0", "113": "        assert score.grade in [\"D\", \"D+\", \"D-\", \"F\"]", "114": "", "115": "    def test_medium_quality_score(self, medium_quality_finder):", "116": "        \"\"\"Test quality score for medium-quality test suite.\"\"\"", "117": "        analyzer = QualityAnalyzer(medium_quality_finder)", "118": "        score = analyzer.calculate_score(threshold=0.9)", "119": "", "120": "        # Should have medium scores", "121": "        assert 60.0 <= score.overall_score <= 90.0  # Allow for scoring variations", "122": "        assert score.grade in [\"B\", \"B+\", \"B-\", \"C+\", \"C\"]", "123": "", "124": "    def test_score_components_range(self, high_quality_finder):", "125": "        \"\"\"Test that all score components are in valid range (0-100).\"\"\"", "126": "        analyzer = QualityAnalyzer(high_quality_finder)", "127": "        score = analyzer.calculate_score(threshold=0.9)", "128": "", "129": "        assert 0 <= score.overall_score <= 100", "130": "        assert 0 <= score.duplication_score <= 100", "131": "        assert 0 <= score.coverage_efficiency_score <= 100", "132": "        assert 0 <= score.uniqueness_score <= 100", "133": "", "134": "    def test_empty_finder_score(self):", "135": "        \"\"\"Test quality score for empty test suite.\"\"\"", "136": "        finder = CoverageDuplicateFinder()", "137": "        analyzer = QualityAnalyzer(finder)", "138": "        score = analyzer.calculate_score(threshold=0.9)", "139": "", "140": "        # Empty suite gets F grade with message", "141": "        assert score.overall_score == 0", "142": "        assert score.duplication_score == 0", "143": "        assert score.grade == \"F\"", "144": "        assert \"No tests found\" in score.recommendations", "145": "", "146": "    def test_grade_mapping(self):", "147": "        \"\"\"Test that scores map to correct grades.\"\"\"", "148": "        finder = CoverageDuplicateFinder()", "149": "", "150": "        # Add tests with varying quality to test grading", "151": "        # High quality (A range)", "152": "        for i in range(20):", "153": "            finder.add_test_coverage(f\"test_high_{i}\", {f\"file{i}.py\": [i + 1, i + 2]})", "154": "", "155": "        analyzer = QualityAnalyzer(finder)", "156": "        score = analyzer.calculate_score(threshold=0.9)", "157": "", "158": "        # Should get a good grade with unique tests", "159": "        assert score.grade in [\"A+\", \"A\", \"A-\", \"B+\", \"B\"]", "160": "", "161": "    def test_score_with_different_thresholds(self, medium_quality_finder):", "162": "        \"\"\"Test that threshold affects similarity scoring.\"\"\"", "163": "        analyzer = QualityAnalyzer(medium_quality_finder)", "164": "", "165": "        score_high_threshold = analyzer.calculate_score(threshold=0.95)", "166": "        score_low_threshold = analyzer.calculate_score(threshold=0.5)", "167": "", "168": "        # Lower threshold finds more similar tests, potentially lowering score", "169": "        # But the exact relationship depends on the test data", "170": "        assert score_high_threshold is not None", "171": "        assert score_low_threshold is not None", "172": "", "173": "", "174": "class TestRecommendationEngine:", "175": "    \"\"\"Tests for RecommendationEngine.\"\"\"", "176": "", "177": "    def test_recommendations_for_low_quality(self, low_quality_finder):", "178": "        \"\"\"Test recommendations for low-quality test suite.\"\"\"", "179": "        engine = RecommendationEngine(low_quality_finder)", "180": "        report = engine.generate_report(threshold=0.9)", "181": "", "182": "        # Should have recommendations", "183": "        assert len(report[\"recommendations\"]) > 0", "184": "", "185": "        # Should have high-priority recommendations due to low quality", "186": "        priorities = [r[\"priority\"] for r in report[\"recommendations\"]]", "187": "        assert \"high\" in priorities", "188": "", "189": "    def test_recommendations_for_high_quality(self, high_quality_finder):", "190": "        \"\"\"Test recommendations for high-quality test suite.\"\"\"", "191": "        engine = RecommendationEngine(high_quality_finder)", "192": "        report = engine.generate_report(threshold=0.9)", "193": "", "194": "        # May have few or no recommendations", "195": "        # High-priority recommendations should be rare or absent", "196": "        high_priority = [r for r in report[\"recommendations\"] if r[\"priority\"] == \"high\"]", "197": "        assert len(high_priority) <= 2", "198": "", "199": "    def test_report_contains_statistics(self, medium_quality_finder):", "200": "        \"\"\"Test that report contains statistics.\"\"\"", "201": "        engine = RecommendationEngine(medium_quality_finder)", "202": "        report = engine.generate_report(threshold=0.9)", "203": "", "204": "        # Should have statistics", "205": "        assert \"statistics\" in report", "206": "        stats = report[\"statistics\"]", "207": "", "208": "        assert \"total_tests\" in stats", "209": "        assert \"exact_duplicates\" in stats", "210": "        assert \"subset_duplicates\" in stats", "211": "        assert \"similar_pairs\" in stats", "212": "", "213": "    def test_recommendation_priorities(self, low_quality_finder):", "214": "        \"\"\"Test that recommendations have valid priorities.\"\"\"", "215": "        engine = RecommendationEngine(low_quality_finder)", "216": "        report = engine.generate_report(threshold=0.9)", "217": "", "218": "        # All recommendations should have valid priorities", "219": "        for rec in report[\"recommendations\"]:", "220": "            assert rec[\"priority\"] in [\"high\", \"medium\", \"low\"]", "221": "            assert \"message\" in rec", "222": "", "223": "    def test_duplicate_recommendation(self, low_quality_finder):", "224": "        \"\"\"Test that duplicate tests trigger recommendations.\"\"\"", "225": "        engine = RecommendationEngine(low_quality_finder)", "226": "        report = engine.generate_report(threshold=0.9)", "227": "", "228": "        # Should recommend removing duplicates", "229": "        messages = [r[\"message\"].lower() for r in report[\"recommendations\"]]", "230": "        assert any(\"duplicate\" in msg for msg in messages)", "231": "", "232": "    def test_recommendation_for_perfect_suite(self):", "233": "        \"\"\"Test recommendations for perfect test suite.\"\"\"", "234": "        finder = CoverageDuplicateFinder()", "235": "", "236": "        # Add 10 completely unique tests", "237": "        for i in range(10):", "238": "            finder.add_test_coverage(", "239": "                f\"test_{i}\",", "240": "                {f\"file{i}.py\": list(range(i * 100 + 1, (i + 1) * 100 + 1))},  # Start from 1", "241": "            )", "242": "", "243": "        analyzer = QualityAnalyzer(finder)", "244": "        score = analyzer.calculate_score(threshold=0.9)", "245": "", "246": "        engine = RecommendationEngine(finder)", "247": "        report = engine.generate_report(threshold=0.9)", "248": "", "249": "        # Should have minimal recommendations", "250": "        assert len(report[\"recommendations\"]) <= 1", "251": "", "252": "        # If there are recommendations, they should be low priority", "253": "        for rec in report[\"recommendations\"]:", "254": "            assert rec[\"priority\"] == \"low\"", "255": "", "256": "    def test_statistics_accuracy(self, medium_quality_finder):", "257": "        \"\"\"Test that statistics are accurate.\"\"\"", "258": "        engine = RecommendationEngine(medium_quality_finder)", "259": "        report = engine.generate_report(threshold=0.9)", "260": "", "261": "        stats = report[\"statistics\"]", "262": "", "263": "        # Verify statistics match actual counts", "264": "        assert stats[\"total_tests\"] == len(medium_quality_finder.tests)", "265": "", "266": "        exact_dups = medium_quality_finder.find_exact_duplicates()", "267": "        expected_dup_count = sum(len(g) - 1 for g in exact_dups)", "268": "        assert stats[\"exact_duplicates\"] == expected_dup_count", "269": "", "270": "    def test_empty_finder_recommendations(self):", "271": "        \"\"\"Test recommendations for empty finder.\"\"\"", "272": "        finder = CoverageDuplicateFinder()", "273": "        engine = RecommendationEngine(finder)", "274": "        report = engine.generate_report(threshold=0.9)", "275": "", "276": "        # Should handle empty finder gracefully", "277": "        assert \"recommendations\" in report", "278": "        assert \"statistics\" in report", "279": "        assert report[\"statistics\"][\"total_tests\"] == 0", "280": "", "281": "", "282": "class TestIntegration:", "283": "    \"\"\"Integration tests for analysis workflow.\"\"\"", "284": "", "285": "    def test_complete_analysis_workflow(self, medium_quality_finder):", "286": "        \"\"\"Test complete quality analysis workflow.\"\"\"", "287": "        # Step 1: Calculate quality score", "288": "        analyzer = QualityAnalyzer(medium_quality_finder)", "289": "        score = analyzer.calculate_score(threshold=0.9)", "290": "", "291": "        assert score is not None", "292": "        assert 0 <= score.overall_score <= 100", "293": "", "294": "        # Step 2: Generate recommendations", "295": "        engine = RecommendationEngine(medium_quality_finder)", "296": "        report = engine.generate_report(threshold=0.9)", "297": "", "298": "        assert \"recommendations\" in report", "299": "        assert \"statistics\" in report", "300": "", "301": "        # Step 3: Verify recommendations are actionable", "302": "        for rec in report[\"recommendations\"]:", "303": "            assert \"priority\" in rec", "304": "            assert \"message\" in rec", "305": "            assert len(rec[\"message\"]) > 0", "306": "", "307": "    def test_score_influences_recommendations(self):", "308": "        \"\"\"Test that score quality affects recommendation priorities.\"\"\"", "309": "        # High-quality finder", "310": "        high_finder = CoverageDuplicateFinder()", "311": "        for i in range(10):", "312": "            high_finder.add_test_coverage(f\"test_{i}\", {f\"file{i}.py\": [i + 1, i + 2, i + 3]})", "313": "", "314": "        high_analyzer = QualityAnalyzer(high_finder)", "315": "        high_score = high_analyzer.calculate_score(threshold=0.9)", "316": "        high_engine = RecommendationEngine(high_finder)", "317": "        high_report = high_engine.generate_report(threshold=0.9)", "318": "", "319": "        # Low-quality finder", "320": "        low_finder = CoverageDuplicateFinder()", "321": "        for i in range(10):", "322": "            low_finder.add_test_coverage(f\"test_{i}\", {\"file.py\": [1, 2, 3]})", "323": "", "324": "        low_analyzer = QualityAnalyzer(low_finder)", "325": "        low_score = low_analyzer.calculate_score(threshold=0.9)", "326": "        low_engine = RecommendationEngine(low_finder)", "327": "        low_report = low_engine.generate_report(threshold=0.9)", "328": "", "329": "        # Low quality should have more recommendations", "330": "        assert len(low_report[\"recommendations\"]) >= len(high_report[\"recommendations\"])"}, "src/testiq/exceptions.py": {"1": "\"\"\"", "2": "Custom exceptions for TestIQ.", "3": "Provides detailed error codes and categories for better error handling.", "4": "\"\"\"", "5": "", "6": "", "7": "class TestIQError(Exception):", "8": "    \"\"\"Base exception for all TestIQ errors.\"\"\"", "9": "", "10": "    def __init__(self, message: str, error_code: str = \"TESTIQ_ERROR\") -> None:", "11": "        self.message = message", "12": "        self.error_code = error_code", "13": "        super().__init__(message)", "14": "", "15": "    def __str__(self) -> str:", "16": "        return f\"[{self.error_code}] {self.message}\"", "17": "", "18": "", "19": "class ConfigurationError(TestIQError):", "20": "    \"\"\"Configuration-related errors.\"\"\"", "21": "", "22": "    def __init__(self, message: str) -> None:", "23": "        super().__init__(message, \"CONFIG_ERROR\")", "24": "", "25": "", "26": "class ValidationError(TestIQError):", "27": "    \"\"\"Input validation errors.\"\"\"", "28": "", "29": "    def __init__(self, message: str) -> None:", "30": "        super().__init__(message, \"VALIDATION_ERROR\")", "31": "", "32": "", "33": "class SecurityError(TestIQError):", "34": "    \"\"\"Security-related errors.\"\"\"", "35": "", "36": "    def __init__(self, message: str) -> None:", "37": "        super().__init__(message, \"SECURITY_ERROR\")", "38": "", "39": "", "40": "class FileOperationError(TestIQError):", "41": "    \"\"\"File operation errors.\"\"\"", "42": "", "43": "    def __init__(self, message: str, filepath: str = \"\") -> None:", "44": "        self.filepath = filepath", "45": "        super().__init__(message, \"FILE_ERROR\")", "46": "", "47": "", "48": "class ParseError(TestIQError):", "49": "    \"\"\"Data parsing errors.\"\"\"", "50": "", "51": "    def __init__(self, message: str) -> None:", "52": "        super().__init__(message, \"PARSE_ERROR\")", "53": "", "54": "", "55": "class AnalysisError(TestIQError):", "56": "    \"\"\"Analysis operation errors.\"\"\"", "57": "", "58": "    def __init__(self, message: str) -> None:", "59": "        super().__init__(message, \"ANALYSIS_ERROR\")", "60": "", "61": "", "62": "class ResourceLimitError(TestIQError):", "63": "    \"\"\"Resource limit exceeded errors.\"\"\"", "64": "", "65": "    def __init__(self, message: str, limit_type: str = \"\") -> None:", "66": "        self.limit_type = limit_type", "67": "        super().__init__(message, \"RESOURCE_LIMIT_ERROR\")"}, "src/testiq/cli.py": {"1": "\"\"\"", "2": "Command-line interface for TestIQ.", "3": "\"\"\"", "4": "", "5": "import json", "6": "import sys", "7": "from datetime import datetime", "8": "from pathlib import Path", "9": "from typing import Optional", "10": "", "11": "import click", "12": "from rich import box", "13": "from rich.console import Console", "14": "from rich.panel import Panel", "15": "from rich.table import Table", "16": "from rich.text import Text", "17": "", "18": "from testiq import __version__", "19": "from testiq.analysis import QualityAnalyzer, RecommendationEngine", "20": "from testiq.analyzer import CoverageDuplicateFinder", "21": "from testiq.cicd import BaselineManager, QualityGate, QualityGateChecker, TrendTracker, get_exit_code", "22": "from testiq.config import TestIQConfig, load_config", "23": "from testiq.exceptions import TestIQError", "24": "from testiq.logging_config import get_logger, setup_logging", "25": "from testiq.reporting import CSVReportGenerator, HTMLReportGenerator", "26": "from testiq.security import (", "27": "    check_file_size,", "28": "    sanitize_output_path,", "29": "    validate_coverage_data,", "30": "    validate_file_path,", "31": ")", "32": "", "33": "console = Console()", "34": "logger = get_logger(__name__)", "35": "", "36": "", "37": "@click.group()", "38": "@click.version_option(version=__version__, prog_name=\"testiq\")", "39": "@click.option(", "40": "    \"--config\",", "41": "    \"-c\",", "42": "    type=click.Path(exists=True, path_type=Path),", "43": "    help=\"Path to configuration file (.yaml, .yml, .toml)\",", "44": ")", "45": "@click.option(", "46": "    \"--log-level\",", "47": "    type=click.Choice([\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]),", "48": "    help=\"Set logging level\",", "49": ")", "50": "@click.option(", "51": "    \"--log-file\",", "52": "    type=click.Path(path_type=Path),", "53": "    help=\"Log file path\",", "54": ")", "55": "@click.pass_context", "56": "def main(", "57": "    ctx: click.Context, config: Optional[Path], log_level: Optional[str], log_file: Optional[Path]", "58": ") -> None:", "59": "    \"\"\"", "60": "    TestIQ - Intelligent Test Analysis", "61": "", "62": "    Find duplicate and redundant tests using coverage analysis.", "63": "    \"\"\"", "64": "    # Load configuration", "65": "    try:", "66": "        cfg = load_config(config)", "67": "", "68": "        # Override with CLI options", "69": "        if log_level:", "70": "            cfg.log.level = log_level", "71": "        if log_file:", "72": "            cfg.log.file = str(log_file)", "73": "", "74": "        # Setup logging", "75": "        setup_logging(", "76": "            level=cfg.log.level,", "77": "            log_file=Path(cfg.log.file) if cfg.log.file else None,", "78": "            enable_rotation=cfg.log.enable_rotation,", "79": "            max_bytes=cfg.log.max_bytes,", "80": "            backup_count=cfg.log.backup_count,", "81": "        )", "82": "", "83": "        # Store config in context", "84": "        ctx.ensure_object(dict)", "85": "        ctx.obj[\"config\"] = cfg", "86": "", "87": "        logger.debug(f\"TestIQ v{__version__} initialized\")", "88": "        if config:", "89": "            logger.info(f\"Loaded configuration from: {config}\")", "90": "", "91": "    except Exception as e:", "92": "        console.print(f\"[red]Configuration error: {e}[/red]\")", "93": "        sys.exit(1)", "94": "", "95": "", "96": "@main.command()", "97": "@click.argument(\"coverage_file\", type=click.Path(exists=True, path_type=Path))", "98": "@click.option(", "99": "    \"--threshold\",", "100": "    \"-t\",", "101": "    type=float,", "102": "    help=\"Similarity threshold (0.0-1.0) for detecting similar tests\",", "103": ")", "104": "@click.option(", "105": "    \"--output\",", "106": "    \"-o\",", "107": "    type=click.Path(path_type=Path),", "108": "    help=\"Output file for the report (default: stdout)\",", "109": ")", "110": "@click.option(", "111": "    \"--format\",", "112": "    \"-f\",", "113": "    type=click.Choice([\"markdown\", \"json\", \"text\", \"html\", \"csv\"]),", "114": "    default=\"text\",", "115": "    help=\"Output format (html and csv require --output)\",", "116": ")", "117": "@click.option(", "118": "    \"--quality-gate\",", "119": "    is_flag=True,", "120": "    help=\"Enable quality gate checking (exits with code 2 if failed)\",", "121": ")", "122": "@click.option(", "123": "    \"--max-duplicates\",", "124": "    type=int,", "125": "    help=\"Maximum allowed exact duplicates (for quality gate)\",", "126": ")", "127": "@click.option(", "128": "    \"--baseline\",", "129": "    type=click.Path(path_type=Path),", "130": "    help=\"Baseline file for comparison (for quality gate)\",", "131": ")", "132": "@click.option(", "133": "    \"--save-baseline\",", "134": "    type=click.Path(path_type=Path),", "135": "    help=\"Save results as baseline for future comparisons\",", "136": ")", "137": "@click.pass_context", "138": "def analyze(", "139": "    ctx: click.Context,", "140": "    coverage_file: Path,", "141": "    threshold: Optional[float],", "142": "    output: Optional[Path],", "143": "    format: str,", "144": "    quality_gate: bool,", "145": "    max_duplicates: Optional[int],", "146": "    baseline: Optional[Path],", "147": "    save_baseline: Optional[Path],", "148": ") -> None:", "149": "    \"\"\"", "150": "    Analyze test coverage data to find duplicates.", "151": "", "152": "    COVERAGE_FILE: JSON file containing per-test coverage data", "153": "    \"\"\"", "154": "    cfg: TestIQConfig = ctx.obj[\"config\"]", "155": "", "156": "    # Use config threshold if not provided", "157": "    if threshold is None:", "158": "        threshold = cfg.analysis.similarity_threshold", "159": "", "160": "    logger.info(f\"Analyzing coverage file: {coverage_file}\")", "161": "", "162": "    try:", "163": "        # Security: Validate and check file", "164": "        validated_path = validate_file_path(coverage_file)", "165": "        check_file_size(validated_path, cfg.security.max_file_size)", "166": "", "167": "        # Load coverage data", "168": "        with open(validated_path) as f:", "169": "            coverage_data = json.load(f)", "170": "", "171": "        # Security: Validate coverage data", "172": "        validate_coverage_data(coverage_data, cfg.security.max_tests)", "173": "", "174": "        logger.info(f\"Loaded {len(coverage_data)} tests from coverage file\")", "175": "", "176": "        # Create analyzer with config", "177": "        finder = CoverageDuplicateFinder(", "178": "            enable_parallel=cfg.performance.enable_parallel,", "179": "            max_workers=cfg.performance.max_workers,", "180": "            enable_caching=cfg.performance.enable_caching,", "181": "            cache_dir=cfg.performance.cache_dir,", "182": "        )", "183": "", "184": "        # Add test coverage", "185": "        for test_name, test_coverage in coverage_data.items():", "186": "            finder.add_test_coverage(test_name, test_coverage)", "187": "", "188": "        # Quality gate checking", "189": "        exit_code = 0", "190": "        if quality_gate:", "191": "            gate = QualityGate(", "192": "                max_duplicates=max_duplicates,", "193": "                fail_on_increase=baseline is not None,", "194": "            )", "195": "            checker = QualityGateChecker(gate)", "196": "", "197": "            # Load baseline if provided", "198": "            baseline_result = None", "199": "            if baseline:", "200": "                baseline_mgr = BaselineManager(Path.home() / \".testiq\" / \"baselines\")", "201": "                baseline_result = baseline_mgr.load(baseline.stem)", "202": "", "203": "            passed, details = checker.check(finder, threshold, baseline_result)", "204": "", "205": "            if not passed:", "206": "                console.print(\"\\n[red]\u2717 Quality Gate FAILED[/red]\")", "207": "                for failure in details[\"failures\"]:", "208": "                    console.print(f\"  \u2022 {failure}\")", "209": "                exit_code = 2", "210": "            else:", "211": "                console.print(\"\\n[green]\u2713 Quality Gate PASSED[/green]\")", "212": "", "213": "        # Save baseline if requested", "214": "        if save_baseline:", "215": "            from testiq.cicd import AnalysisResult", "216": "", "217": "            exact_dups = finder.find_exact_duplicates()", "218": "            duplicate_count = sum(len(g) - 1 for g in exact_dups)", "219": "            total_tests = len(finder.tests)", "220": "", "221": "            result = AnalysisResult(", "222": "                timestamp=datetime.now().isoformat(),", "223": "                total_tests=total_tests,", "224": "                exact_duplicates=duplicate_count,", "225": "                duplicate_groups=len(exact_dups),", "226": "                subset_duplicates=len(finder.find_subset_duplicates()),", "227": "                similar_pairs=len(finder.find_similar_coverage(threshold)),", "228": "                duplicate_percentage=(duplicate_count / total_tests * 100) if total_tests > 0 else 0,", "229": "                threshold=threshold,", "230": "            )", "231": "", "232": "            baseline_mgr = BaselineManager(Path.home() / \".testiq\" / \"baselines\")", "233": "            baseline_mgr.save(result, save_baseline.stem)", "234": "            console.print(f\"[green]\u2713 Baseline saved: {save_baseline}[/green]\")", "235": "", "236": "        # Generate output based on format", "237": "        if format == \"html\":", "238": "            if not output:", "239": "                console.print(\"[red]Error: HTML format requires --output[/red]\")", "240": "                sys.exit(1)", "241": "            html_gen = HTMLReportGenerator(finder)", "242": "            html_gen.generate(output, threshold=threshold)", "243": "            console.print(f\"[green]\u2713 HTML report saved to {output}[/green]\")", "244": "", "245": "        elif format == \"csv\":", "246": "            if not output:", "247": "                console.print(\"[red]Error: CSV format requires --output[/red]\")", "248": "                sys.exit(1)", "249": "            csv_gen = CSVReportGenerator(finder)", "250": "            csv_gen.generate_summary(output, threshold=threshold)", "251": "            console.print(f\"[green]\u2713 CSV report saved to {output}[/green]\")", "252": "", "253": "        elif format == \"json\":", "254": "            result = {", "255": "                \"exact_duplicates\": finder.find_exact_duplicates(),", "256": "                \"subset_duplicates\": [", "257": "                    {\"subset\": s, \"superset\": sup, \"ratio\": r}", "258": "                    for s, sup, r in finder.find_subset_duplicates()", "259": "                ],", "260": "                \"similar_tests\": [", "261": "                    {\"test1\": t1, \"test2\": t2, \"similarity\": sim}", "262": "                    for t1, t2, sim in finder.find_similar_coverage(threshold)", "263": "                ],", "264": "            }", "265": "            output_text = json.dumps(result, indent=2)", "266": "", "267": "            if output:", "268": "                validated_output = sanitize_output_path(output)", "269": "                validated_output.write_text(output_text)", "270": "                console.print(f\"[green]\u2713 Report saved to {validated_output}[/green]\")", "271": "            else:", "272": "                console.print(output_text)", "273": "", "274": "        elif format == \"markdown\":", "275": "            output_text = finder.generate_report()", "276": "", "277": "            if output:", "278": "                validated_output = sanitize_output_path(output)", "279": "                validated_output.write_text(output_text)", "280": "                console.print(f\"[green]\u2713 Report saved to {validated_output}[/green]\")", "281": "            else:", "282": "                console.print(output_text)", "283": "", "284": "        else:  # text format with rich", "285": "            if output:", "286": "                console.print(\"[yellow]Warning: --output ignored for text format[/yellow]\")", "287": "            display_results(finder, threshold)", "288": "", "289": "        sys.exit(exit_code)", "290": "", "291": "    except TestIQError as e:", "292": "        console.print(f\"[red]Error: {e}[/red]\")", "293": "        logger.error(str(e))", "294": "        sys.exit(1)", "295": "    except json.JSONDecodeError as e:", "296": "        console.print(f\"[red]Invalid JSON in {coverage_file}: {e}[/red]\")", "297": "        logger.error(f\"JSON decode error: {e}\")", "298": "        sys.exit(1)", "299": "    except Exception as e:", "300": "        console.print(f\"[red]Unexpected error: {e}[/red]\")", "301": "        logger.exception(\"Unexpected error during analysis\")", "302": "        sys.exit(1)", "303": "", "304": "", "305": "def display_results(finder: CoverageDuplicateFinder, threshold: float) -> None:", "306": "    \"\"\"Display results in rich formatted text.\"\"\"", "307": "    console.print(", "308": "        Panel(", "309": "            \"[bold cyan]TestIQ Analysis Results[/bold cyan]\",", "310": "            box=box.DOUBLE,", "311": "        )", "312": "    )", "313": "", "314": "    # Exact duplicates", "315": "    exact_dups = finder.find_exact_duplicates()", "316": "    if exact_dups:", "317": "        table = Table(title=\"\ud83c\udfaf Exact Duplicates (Identical Coverage)\", show_header=True)", "318": "        table.add_column(\"Group\", style=\"cyan\", width=10)", "319": "        table.add_column(\"Tests\", style=\"yellow\", no_wrap=False, overflow=\"fold\")", "320": "        table.add_column(\"Action\", style=\"green\", width=20)", "321": "", "322": "        for i, group in enumerate(exact_dups, 1):", "323": "            tests_str = \"\\n\".join(group)", "324": "            action = f\"Remove {len(group) - 1} duplicate(s)\"", "325": "            table.add_row(f\"Group {i}\", tests_str, action)", "326": "", "327": "        console.print(table)", "328": "        console.print()", "329": "", "330": "    # Subset duplicates", "331": "    subsets = finder.find_subset_duplicates()", "332": "    if subsets:", "333": "        table = Table(title=\"\ud83d\udcca Subset Duplicates\", show_header=True)", "334": "        table.add_column(\"Subset Test\", style=\"yellow\", no_wrap=False, overflow=\"fold\")", "335": "        table.add_column(\"Superset Test\", style=\"cyan\", no_wrap=False, overflow=\"fold\")", "336": "        table.add_column(\"Coverage Ratio\", style=\"magenta\", width=15)", "337": "", "338": "        for subset_test, superset_test, ratio in subsets[:10]:", "339": "            table.add_row(subset_test, superset_test, f\"{ratio:.1%}\")", "340": "", "341": "        console.print(table)", "342": "        console.print()", "343": "", "344": "    # Similar tests", "345": "    similar = finder.find_similar_coverage(threshold)", "346": "    if similar:", "347": "        table = Table(title=f\"\ud83d\udd0d Similar Tests (\u2265{threshold:.0%} overlap)\", show_header=True)", "348": "        table.add_column(\"Test 1\", style=\"yellow\", no_wrap=False, overflow=\"fold\")", "349": "        table.add_column(\"Test 2\", style=\"cyan\", no_wrap=False, overflow=\"fold\")", "350": "        table.add_column(\"Similarity\", style=\"magenta\", width=12)", "351": "", "352": "        for test1, test2, similarity in similar[:10]:", "353": "            table.add_row(test1, test2, f\"{similarity:.1%}\")", "354": "", "355": "        console.print(table)", "356": "        console.print()", "357": "", "358": "    # Summary", "359": "    summary_table = Table(title=\"\ud83d\udcc8 Summary\", show_header=True, box=box.ROUNDED)", "360": "    summary_table.add_column(\"Metric\", style=\"cyan\")", "361": "    summary_table.add_column(\"Count\", style=\"bold green\")", "362": "", "363": "    summary_table.add_row(\"Total tests analyzed\", str(len(finder.tests)))", "364": "    summary_table.add_row(\"Exact duplicates (can remove)\", str(sum(len(g) - 1 for g in exact_dups)))", "365": "    summary_table.add_row(\"Subset duplicates\", str(len(subsets)))", "366": "    summary_table.add_row(\"Similar test pairs\", str(len(similar)))", "367": "", "368": "    console.print(summary_table)", "369": "", "370": "", "371": "@main.command()", "372": "def demo() -> None:", "373": "    \"\"\"Run a demonstration with sample data.\"\"\"", "374": "    console.print(\"[cyan]Running TestIQ demo with sample data...[/cyan]\\n\")", "375": "", "376": "    finder = CoverageDuplicateFinder()", "377": "", "378": "    # Add sample test data", "379": "    finder.add_test_coverage(", "380": "        \"test_user_login_success_1\",", "381": "        {\"auth.py\": [10, 11, 12, 15, 20, 25], \"user.py\": [5, 6, 7]},", "382": "    )", "383": "", "384": "    finder.add_test_coverage(", "385": "        \"test_user_login_success_2\",", "386": "        {\"auth.py\": [10, 11, 12, 15, 20, 25], \"user.py\": [5, 6, 7]},", "387": "    )", "388": "", "389": "    finder.add_test_coverage(\"test_user_login_minimal\", {\"auth.py\": [10, 11, 12]})", "390": "", "391": "    finder.add_test_coverage(", "392": "        \"test_user_login_complete\",", "393": "        {", "394": "            \"auth.py\": [10, 11, 12, 15, 20, 25, 30, 35],", "395": "            \"user.py\": [5, 6, 7],", "396": "            \"db.py\": [100, 101],", "397": "        },", "398": "    )", "399": "", "400": "    finder.add_test_coverage(", "401": "        \"test_admin_login\",", "402": "        {\"auth.py\": [10, 11, 12, 15, 20, 25, 40], \"user.py\": [5, 6, 7], \"admin.py\": [50]},", "403": "    )", "404": "", "405": "    finder.add_test_coverage(", "406": "        \"test_password_reset\", {\"password.py\": [1, 2, 3, 4, 5], \"email.py\": [10, 20]}", "407": "    )", "408": "", "409": "    display_results(finder, threshold=0.7)", "410": "", "411": "", "412": "if __name__ == \"__main__\":", "413": "    main()", "414": "", "415": "", "416": "@main.command(name=\"quality-score\")", "417": "@click.argument(\"coverage_file\", type=click.Path(exists=True, path_type=Path))", "418": "@click.option(", "419": "    \"--threshold\",", "420": "    \"-t\",", "421": "    type=float,", "422": "    help=\"Similarity threshold (0.0-1.0) for detecting similar tests\",", "423": ")", "424": "@click.option(", "425": "    \"--output\",", "426": "    \"-o\",", "427": "    type=click.Path(path_type=Path),", "428": "    help=\"Output file for the report (default: stdout)\",", "429": ")", "430": "@click.pass_context", "431": "def quality_score(", "432": "    ctx: click.Context,", "433": "    coverage_file: Path,", "434": "    threshold: Optional[float],", "435": "    output: Optional[Path],", "436": ") -> None:", "437": "    \"\"\"", "438": "    Analyze test quality and get actionable recommendations.", "439": "", "440": "    COVERAGE_FILE: JSON file containing per-test coverage data", "441": "    \"\"\"", "442": "    cfg: TestIQConfig = ctx.obj[\"config\"]", "443": "", "444": "    if threshold is None:", "445": "        threshold = cfg.analysis.similarity_threshold", "446": "", "447": "    try:", "448": "        # Load and validate coverage data", "449": "        validated_path = validate_file_path(coverage_file)", "450": "        check_file_size(validated_path, cfg.security.max_file_size)", "451": "", "452": "        with open(validated_path) as f:", "453": "            coverage_data = json.load(f)", "454": "", "455": "        validate_coverage_data(coverage_data, cfg.security.max_tests)", "456": "", "457": "        # Create analyzer", "458": "        finder = CoverageDuplicateFinder(", "459": "            enable_parallel=cfg.performance.enable_parallel,", "460": "            max_workers=cfg.performance.max_workers,", "461": "        )", "462": "", "463": "        for test_name, test_coverage in coverage_data.items():", "464": "            finder.add_test_coverage(test_name, test_coverage)", "465": "", "466": "        # Calculate quality score", "467": "        analyzer = QualityAnalyzer(finder)", "468": "        score = analyzer.calculate_score(threshold)", "469": "", "470": "        # Display score with rich formatting", "471": "        console.print(", "472": "            Panel(", "473": "                f\"[bold cyan]Test Quality Score[/bold cyan]\\n\\n\"", "474": "                f\"Overall Score: [bold yellow]{score.overall_score:.1f}/100[/bold yellow]\\n\"", "475": "                f\"Grade: [bold {'green' if score.grade[0] == 'A' else 'yellow' if score.grade[0] == 'B' else 'red'}]{score.grade}[/bold]\\n\\n\"", "476": "                f\"Duplication Score: {score.duplication_score:.1f}/100\\n\"", "477": "                f\"Coverage Efficiency: {score.coverage_efficiency_score:.1f}/100\\n\"", "478": "                f\"Uniqueness Score: {score.uniqueness_score:.1f}/100\",", "479": "                box=box.DOUBLE,", "480": "            )", "481": "        )", "482": "", "483": "        # Generate recommendations", "484": "        engine = RecommendationEngine(finder)", "485": "        report = engine.generate_report(threshold)", "486": "", "487": "        # Display recommendations", "488": "        if report[\"recommendations\"]:", "489": "            console.print(\"\\n[bold cyan]\ud83d\udccb Recommendations:[/bold cyan]\\n\")", "490": "            for rec in report[\"recommendations\"]:", "491": "                priority_color = {\"high\": \"red\", \"medium\": \"yellow\", \"low\": \"green\"}[rec[\"priority\"]]", "492": "                console.print(f\"[{priority_color}]\u2022 [{rec['priority'].upper()}][/{priority_color}] {rec['message']}\")", "493": "", "494": "        # Save to file if requested", "495": "        if output:", "496": "            validated_output = sanitize_output_path(output)", "497": "            output_data = {", "498": "                \"score\": {", "499": "                    \"overall\": score.overall_score,", "500": "                    \"grade\": score.grade,", "501": "                    \"duplication\": score.duplication_score,", "502": "                    \"efficiency\": score.coverage_efficiency_score,", "503": "                    \"uniqueness\": score.uniqueness_score,", "504": "                },", "505": "                \"recommendations\": report[\"recommendations\"],", "506": "                \"statistics\": report[\"statistics\"],", "507": "            }", "508": "            validated_output.write_text(json.dumps(output_data, indent=2))", "509": "            console.print(f\"\\n[green]\u2713 Quality report saved to {validated_output}[/green]\")", "510": "", "511": "    except TestIQError as e:", "512": "        console.print(f\"[red]Error: {e}[/red]\")", "513": "        sys.exit(1)", "514": "    except Exception as e:", "515": "        console.print(f\"[red]Unexpected error: {e}[/red]\")", "516": "        logger.exception(\"Error calculating quality score\")", "517": "        sys.exit(1)", "518": "", "519": "", "520": "@main.group(name=\"baseline\")", "521": "def baseline() -> None:", "522": "    \"\"\"Manage analysis baselines for comparison.\"\"\"", "523": "    pass", "524": "", "525": "", "526": "@baseline.command(name=\"list\")", "527": "def baseline_list() -> None:", "528": "    \"\"\"List all saved baselines.\"\"\"", "529": "    baseline_mgr = BaselineManager(Path.home() / \".testiq\" / \"baselines\")", "530": "    baselines = baseline_mgr.list_baselines()", "531": "", "532": "    if not baselines:", "533": "        console.print(\"[yellow]No baselines found[/yellow]\")", "534": "        return", "535": "", "536": "    table = Table(title=\"Saved Baselines\", show_header=True)", "537": "    table.add_column(\"Name\", style=\"cyan\")", "538": "    table.add_column(\"Tests\", style=\"yellow\")", "539": "    table.add_column(\"Duplicates\", style=\"red\")", "540": "    table.add_column(\"Date\", style=\"green\")", "541": "", "542": "    for bl in baselines:", "543": "        table.add_row(", "544": "            bl[\"name\"],", "545": "            str(bl[\"result\"].total_tests),", "546": "            str(bl[\"result\"].exact_duplicates),", "547": "            bl[\"result\"].timestamp[:10],", "548": "        )", "549": "", "550": "    console.print(table)", "551": "", "552": "", "553": "@baseline.command(name=\"show\")", "554": "@click.argument(\"name\")", "555": "def baseline_show(name: str) -> None:", "556": "    \"\"\"Show details of a specific baseline.\"\"\"", "557": "    baseline_mgr = BaselineManager(Path.home() / \".testiq\" / \"baselines\")", "558": "    result = baseline_mgr.load(name)", "559": "", "560": "    if not result:", "561": "        console.print(f\"[red]Baseline '{name}' not found[/red]\")", "562": "        sys.exit(1)", "563": "", "564": "    console.print(", "565": "        Panel(", "566": "            f\"[bold cyan]Baseline: {name}[/bold cyan]\\n\\n\"", "567": "            f\"Date: {result.timestamp[:10]}\\n\"", "568": "            f\"Total Tests: {result.total_tests}\\n\"", "569": "            f\"Exact Duplicates: {result.exact_duplicates}\\n\"", "570": "            f\"Duplicate Groups: {result.duplicate_groups}\\n\"", "571": "            f\"Subset Duplicates: {result.subset_duplicates}\\n\"", "572": "            f\"Similar Pairs: {result.similar_pairs}\\n\"", "573": "            f\"Duplicate %: {result.duplicate_percentage:.2f}%\\n\"", "574": "            f\"Threshold: {result.threshold}\",", "575": "            box=box.DOUBLE,", "576": "        )", "577": "    )", "578": "", "579": "", "580": "@baseline.command(name=\"delete\")", "581": "@click.argument(\"name\")", "582": "@click.option(\"--force\", \"-f\", is_flag=True, help=\"Don't ask for confirmation\")", "583": "def baseline_delete(name: str, force: bool) -> None:", "584": "    \"\"\"Delete a baseline.\"\"\"", "585": "    if not force:", "586": "        if not click.confirm(f\"Delete baseline '{name}'?\"):", "587": "            console.print(\"[yellow]Cancelled[/yellow]\")", "588": "            return", "589": "", "590": "    baseline_mgr = BaselineManager(Path.home() / \".testiq\" / \"baselines\")", "591": "    baseline_dir = baseline_mgr.baseline_dir / f\"{name}.json\"", "592": "", "593": "    if baseline_dir.exists():", "594": "        baseline_dir.unlink()", "595": "        console.print(f\"[green]\u2713 Baseline '{name}' deleted[/green]\")", "596": "    else:", "597": "        console.print(f\"[red]Baseline '{name}' not found[/red]\")", "598": "        sys.exit(1)"}, "tests/test_performance.py": {"1": "\"\"\"", "2": "Tests for performance module.", "3": "\"\"\"", "4": "", "5": "import json", "6": "import tempfile", "7": "from pathlib import Path", "8": "", "9": "import pytest", "10": "", "11": "from testiq.exceptions import AnalysisError", "12": "from testiq.performance import (", "13": "    CacheManager,", "14": "    ParallelProcessor,", "15": "    ProgressTracker,", "16": "    StreamingJSONParser,", "17": "    batch_iterator,", "18": "    compute_similarity,", "19": ")", "20": "", "21": "", "22": "class TestCacheManager:", "23": "    \"\"\"Test CacheManager class.\"\"\"", "24": "", "25": "    def test_init_with_custom_dir(self, tmp_path):", "26": "        \"\"\"Test initialization with custom cache directory.\"\"\"", "27": "        cache_dir = tmp_path / \"custom_cache\"", "28": "        manager = CacheManager(cache_dir=cache_dir, enabled=True)", "29": "        assert manager.cache_dir == cache_dir", "30": "        assert cache_dir.exists()", "31": "        assert manager.enabled", "32": "", "33": "    def test_init_with_default_dir(self):", "34": "        \"\"\"Test initialization with default cache directory.\"\"\"", "35": "        manager = CacheManager(enabled=True)", "36": "        assert manager.cache_dir == Path.home() / \".testiq\" / \"cache\"", "37": "        assert manager.enabled", "38": "", "39": "    def test_init_disabled(self):", "40": "        \"\"\"Test initialization with caching disabled.\"\"\"", "41": "        manager = CacheManager(enabled=False)", "42": "        assert not manager.enabled", "43": "", "44": "    def test_get_cache_key_dict(self):", "45": "        \"\"\"Test cache key generation from dict.\"\"\"", "46": "        manager = CacheManager(enabled=False)", "47": "        data = {\"key\": \"value\", \"num\": 123}", "48": "        key1 = manager._get_cache_key(data)", "49": "        key2 = manager._get_cache_key(data)", "50": "        assert key1 == key2", "51": "        assert len(key1) == 16  # SHA-256 truncated to 16 chars", "52": "", "53": "    def test_get_cache_key_string(self):", "54": "        \"\"\"Test cache key generation from string.\"\"\"", "55": "        manager = CacheManager(enabled=False)", "56": "        key1 = manager._get_cache_key(\"test string\")", "57": "        key2 = manager._get_cache_key(\"test string\")", "58": "        assert key1 == key2", "59": "        assert len(key1) == 16", "60": "", "61": "    def test_get_cache_key_consistency(self):", "62": "        \"\"\"Test cache key is consistent for same data.\"\"\"", "63": "        manager = CacheManager(enabled=False)", "64": "        data = {\"b\": 2, \"a\": 1}  # Different order", "65": "        key1 = manager._get_cache_key({\"a\": 1, \"b\": 2})", "66": "        key2 = manager._get_cache_key(data)", "67": "        assert key1 == key2  # Should be same due to sort_keys=True", "68": "", "69": "    def test_get_miss(self, tmp_path):", "70": "        \"\"\"Test cache miss.\"\"\"", "71": "        manager = CacheManager(cache_dir=tmp_path, enabled=True)", "72": "        result = manager.get(\"nonexistent_key\")", "73": "        assert result is None", "74": "", "75": "    def test_set_and_get(self, tmp_path):", "76": "        \"\"\"Test setting and getting cached value.\"\"\"", "77": "        manager = CacheManager(cache_dir=tmp_path, enabled=True)", "78": "        data = {\"test\": \"value\", \"number\": 42}", "79": "        manager.set(\"test_key\", data)", "80": "        result = manager.get(\"test_key\")", "81": "        assert result == data", "82": "", "83": "    def test_get_disabled(self, tmp_path):", "84": "        \"\"\"Test get when caching is disabled.\"\"\"", "85": "        manager = CacheManager(cache_dir=tmp_path, enabled=False)", "86": "        result = manager.get(\"any_key\")", "87": "        assert result is None", "88": "", "89": "    def test_set_disabled(self, tmp_path):", "90": "        \"\"\"Test set when caching is disabled.\"\"\"", "91": "        manager = CacheManager(cache_dir=tmp_path, enabled=False)", "92": "        manager.set(\"key\", {\"value\": 123})", "93": "        # Check that no cache file was created", "94": "        cache_files = list(tmp_path.glob(\"*.cache\"))", "95": "        assert len(cache_files) == 0", "96": "", "97": "    def test_get_corrupted_cache(self, tmp_path):", "98": "        \"\"\"Test handling of corrupted cache file.\"\"\"", "99": "        manager = CacheManager(cache_dir=tmp_path, enabled=True)", "100": "        # Create a corrupted cache file", "101": "        cache_file = tmp_path / \"test_key.cache\"", "102": "        cache_file.write_text(\"corrupted data\")", "103": "        result = manager.get(\"test_key\")", "104": "        assert result is None  # Should return None on error", "105": "", "106": "    def test_clear_cache(self, tmp_path):", "107": "        \"\"\"Test clearing all cached data.\"\"\"", "108": "        manager = CacheManager(cache_dir=tmp_path, enabled=True)", "109": "        manager.set(\"key1\", {\"value\": 1})", "110": "        manager.set(\"key2\", {\"value\": 2})", "111": "        manager.set(\"key3\", {\"value\": 3})", "112": "", "113": "        # Verify files exist", "114": "        assert len(list(tmp_path.glob(\"*.cache\"))) == 3", "115": "", "116": "        # Clear cache", "117": "        manager.clear()", "118": "", "119": "        # Verify files are gone", "120": "        assert len(list(tmp_path.glob(\"*.cache\"))) == 0", "121": "", "122": "    def test_clear_disabled(self, tmp_path):", "123": "        \"\"\"Test clear when caching is disabled.\"\"\"", "124": "        manager = CacheManager(cache_dir=tmp_path, enabled=False)", "125": "        # Should not raise", "126": "        manager.clear()", "127": "", "128": "", "129": "class TestStreamingJSONParser:", "130": "    \"\"\"Test StreamingJSONParser class.\"\"\"", "131": "", "132": "    def test_parse_coverage_file(self, tmp_path):", "133": "        \"\"\"Test parsing a valid coverage JSON file.\"\"\"", "134": "        coverage_data = {", "135": "            \"test1\": {\"file1.py\": [1, 2, 3]},", "136": "            \"test2\": {\"file2.py\": [10, 20]},", "137": "            \"test3\": {\"file3.py\": [5, 6]},", "138": "        }", "139": "", "140": "        json_file = tmp_path / \"coverage.json\"", "141": "        json_file.write_text(json.dumps(coverage_data))", "142": "", "143": "        parser = StreamingJSONParser()", "144": "        results = list(parser.parse_coverage_file(json_file))", "145": "", "146": "        assert len(results) == 3", "147": "        assert results[0][0] in coverage_data", "148": "        assert results[1][0] in coverage_data", "149": "        assert results[2][0] in coverage_data", "150": "", "151": "    def test_parse_coverage_file_chunked(self, tmp_path):", "152": "        \"\"\"Test parsing with custom chunk size.\"\"\"", "153": "        coverage_data = {f\"test{i}\": {\"file.py\": [i]} for i in range(10)}", "154": "", "155": "        json_file = tmp_path / \"coverage.json\"", "156": "        json_file.write_text(json.dumps(coverage_data))", "157": "", "158": "        parser = StreamingJSONParser()", "159": "        results = list(parser.parse_coverage_file(json_file, chunk_size=3))", "160": "", "161": "        assert len(results) == 10", "162": "", "163": "    def test_parse_invalid_json(self, tmp_path):", "164": "        \"\"\"Test parsing invalid JSON.\"\"\"", "165": "        json_file = tmp_path / \"invalid.json\"", "166": "        json_file.write_text(\"{ invalid json }\")", "167": "", "168": "        parser = StreamingJSONParser()", "169": "        with pytest.raises(AnalysisError, match=\"Invalid JSON\"):", "170": "            list(parser.parse_coverage_file(json_file))", "171": "", "172": "    def test_parse_non_dict_json(self, tmp_path):", "173": "        \"\"\"Test parsing JSON that's not a dict.\"\"\"", "174": "        json_file = tmp_path / \"list.json\"", "175": "        json_file.write_text(\"[1, 2, 3]\")", "176": "", "177": "        parser = StreamingJSONParser()", "178": "        with pytest.raises(AnalysisError, match=\"must contain a dictionary\"):", "179": "            list(parser.parse_coverage_file(json_file))", "180": "", "181": "    def test_parse_empty_file(self, tmp_path):", "182": "        \"\"\"Test parsing empty coverage data.\"\"\"", "183": "        json_file = tmp_path / \"empty.json\"", "184": "        json_file.write_text(\"{}\")", "185": "", "186": "        parser = StreamingJSONParser()", "187": "        results = list(parser.parse_coverage_file(json_file))", "188": "", "189": "        assert len(results) == 0", "190": "", "191": "", "192": "class TestParallelProcessor:", "193": "    \"\"\"Test ParallelProcessor class.\"\"\"", "194": "", "195": "    def test_init_enabled(self):", "196": "        \"\"\"Test initialization with parallel processing enabled.\"\"\"", "197": "        processor = ParallelProcessor(max_workers=4, enabled=True)", "198": "        assert processor.max_workers == 4", "199": "        assert processor.enabled", "200": "", "201": "    def test_init_disabled(self):", "202": "        \"\"\"Test initialization with parallel processing disabled.\"\"\"", "203": "        processor = ParallelProcessor(enabled=False)", "204": "        assert not processor.enabled", "205": "", "206": "    def test_map_sequential(self):", "207": "        \"\"\"Test sequential processing when disabled.\"\"\"", "208": "        processor = ParallelProcessor(enabled=False)", "209": "        items = [1, 2, 3, 4, 5]", "210": "", "211": "        def square(x):", "212": "            return x * x", "213": "", "214": "        results = processor.map(square, items)", "215": "        assert results == [1, 4, 9, 16, 25]", "216": "", "217": "    def test_map_parallel_thread(self):", "218": "        \"\"\"Test parallel processing with threads.\"\"\"", "219": "        processor = ParallelProcessor(max_workers=2, use_processes=False, enabled=True)", "220": "        items = [1, 2, 3, 4, 5]", "221": "", "222": "        def square(x):", "223": "            return x * x", "224": "", "225": "        results = processor.map(square, items)", "226": "        assert sorted(results) == [1, 4, 9, 16, 25]", "227": "", "228": "    def test_map_parallel_process(self):", "229": "        \"\"\"Test parallel processing with processes.\"\"\"", "230": "        # Note: ProcessPoolExecutor requires picklable functions", "231": "        # Using lambda or nested functions won't work, so we skip this test", "232": "        # or use a module-level function. For coverage, we'll test with threads instead", "233": "        processor = ParallelProcessor(max_workers=2, use_processes=True, enabled=True)", "234": "        items = [1, 2, 3, 4, 5]", "235": "", "236": "        # For process pool testing, we'd need a top-level function", "237": "        # Instead, test that it falls back gracefully", "238": "        def local_square(x):", "239": "            return x * x", "240": "", "241": "        results = processor.map(local_square, items)", "242": "        # May fail and fall back to sequential, so just check it completes", "243": "        assert results is not None", "244": "        assert len(results) == 5", "245": "", "246": "    def test_map_with_error(self):", "247": "        \"\"\"Test handling errors in parallel processing.\"\"\"", "248": "        processor = ParallelProcessor(max_workers=2, enabled=True)", "249": "        items = [1, 2, 3, 4, 5]", "250": "", "251": "        def failing_func(x):", "252": "            if x == 3:", "253": "                raise ValueError(\"Test error\")", "254": "            return x * x", "255": "", "256": "        results = processor.map(failing_func, items)", "257": "        # Should have None for failed item", "258": "        assert None in results", "259": "        assert 1 in results", "260": "        assert 4 in results", "261": "", "262": "    def test_map_empty_list(self):", "263": "        \"\"\"Test processing empty list.\"\"\"", "264": "        processor = ParallelProcessor(enabled=True)", "265": "        results = processor.map(lambda x: x, [])", "266": "        assert results == []", "267": "", "268": "    def test_map_single_item(self):", "269": "        \"\"\"Test processing single item (uses sequential).\"\"\"", "270": "        processor = ParallelProcessor(enabled=True)", "271": "        results = processor.map(lambda x: x * 2, [5])", "272": "        assert results == [10]", "273": "", "274": "", "275": "class TestComputeSimilarity:", "276": "    \"\"\"Test compute_similarity function.\"\"\"", "277": "", "278": "    def test_identical_sets(self):", "279": "        \"\"\"Test similarity of identical sets.\"\"\"", "280": "        set1 = frozenset([1, 2, 3, 4])", "281": "        set2 = frozenset([1, 2, 3, 4])", "282": "        similarity = compute_similarity(set1, set2)", "283": "        assert similarity == 1.0", "284": "", "285": "    def test_no_overlap(self):", "286": "        \"\"\"Test similarity of disjoint sets.\"\"\"", "287": "        set1 = frozenset([1, 2, 3])", "288": "        set2 = frozenset([4, 5, 6])", "289": "        similarity = compute_similarity(set1, set2)", "290": "        assert similarity == 0.0", "291": "", "292": "    def test_partial_overlap(self):", "293": "        \"\"\"Test similarity of partially overlapping sets.\"\"\"", "294": "        set1 = frozenset([1, 2, 3, 4])", "295": "        set2 = frozenset([3, 4, 5, 6])", "296": "        similarity = compute_similarity(set1, set2)", "297": "        # Intersection: {3, 4} = 2 elements", "298": "        # Union: {1, 2, 3, 4, 5, 6} = 6 elements", "299": "        # Similarity: 2/6 = 0.333...", "300": "        assert abs(similarity - 0.333) < 0.01", "301": "", "302": "    def test_subset(self):", "303": "        \"\"\"Test similarity when one set is subset of another.\"\"\"", "304": "        set1 = frozenset([1, 2])", "305": "        set2 = frozenset([1, 2, 3, 4])", "306": "        similarity = compute_similarity(set1, set2)", "307": "        # Intersection: {1, 2} = 2 elements", "308": "        # Union: {1, 2, 3, 4} = 4 elements", "309": "        # Similarity: 2/4 = 0.5", "310": "        assert similarity == 0.5", "311": "", "312": "    def test_empty_sets(self):", "313": "        \"\"\"Test similarity of empty sets.\"\"\"", "314": "        set1 = frozenset()", "315": "        set2 = frozenset()", "316": "        similarity = compute_similarity(set1, set2)", "317": "        assert similarity == 0.0", "318": "", "319": "    def test_caching(self):", "320": "        \"\"\"Test that similarity computation is cached.\"\"\"", "321": "        set1 = frozenset([1, 2, 3])", "322": "        set2 = frozenset([2, 3, 4])", "323": "", "324": "        # First call", "325": "        result1 = compute_similarity(set1, set2)", "326": "        # Second call should use cache", "327": "        result2 = compute_similarity(set1, set2)", "328": "", "329": "        assert result1 == result2", "330": "", "331": "", "332": "class TestProgressTracker:", "333": "    \"\"\"Test ProgressTracker class.\"\"\"", "334": "", "335": "    def test_init(self):", "336": "        \"\"\"Test initialization.\"\"\"", "337": "        tracker = ProgressTracker(total=100, desc=\"Testing\")", "338": "        assert tracker.total == 100", "339": "        assert tracker.current == 0", "340": "        assert tracker.desc == \"Testing\"", "341": "        assert tracker.last_logged_percent == -1", "342": "", "343": "    def test_update_progress(self):", "344": "        \"\"\"Test updating progress.\"\"\"", "345": "        tracker = ProgressTracker(total=100)", "346": "        tracker.update(10)", "347": "        assert tracker.current == 10", "348": "        tracker.update(15)", "349": "        assert tracker.current == 25", "350": "", "351": "    def test_update_default_increment(self):", "352": "        \"\"\"Test update with default increment.\"\"\"", "353": "        tracker = ProgressTracker(total=100)", "354": "        tracker.update()", "355": "        assert tracker.current == 1", "356": "        tracker.update()", "357": "        assert tracker.current == 2", "358": "", "359": "    def test_progress_percentage(self):", "360": "        \"\"\"Test progress percentage calculation.\"\"\"", "361": "        tracker = ProgressTracker(total=100)", "362": "        tracker.update(25)", "363": "        percent = (tracker.current / tracker.total) * 100", "364": "        assert percent == 25.0", "365": "", "366": "    def test_complete_progress(self):", "367": "        \"\"\"Test completing 100% progress.\"\"\"", "368": "        tracker = ProgressTracker(total=10)", "369": "        tracker.update(10)", "370": "        assert tracker.current == 10", "371": "        percent = (tracker.current / tracker.total) * 100", "372": "        assert percent == 100.0", "373": "", "374": "", "375": "class TestBatchIterator:", "376": "    \"\"\"Test batch_iterator function.\"\"\"", "377": "", "378": "    def test_exact_batches(self):", "379": "        \"\"\"Test batching with exact multiples.\"\"\"", "380": "        items = list(range(10))", "381": "        batches = list(batch_iterator(items, batch_size=2))", "382": "        assert len(batches) == 5", "383": "        assert batches[0] == [0, 1]", "384": "        assert batches[4] == [8, 9]", "385": "", "386": "    def test_uneven_batches(self):", "387": "        \"\"\"Test batching with remainder.\"\"\"", "388": "        items = list(range(10))", "389": "        batches = list(batch_iterator(items, batch_size=3))", "390": "        assert len(batches) == 4", "391": "        assert batches[0] == [0, 1, 2]", "392": "        assert batches[3] == [9]  # Last batch has only 1 item", "393": "", "394": "    def test_single_batch(self):", "395": "        \"\"\"Test when batch size >= item count.\"\"\"", "396": "        items = [1, 2, 3]", "397": "        batches = list(batch_iterator(items, batch_size=10))", "398": "        assert len(batches) == 1", "399": "        assert batches[0] == [1, 2, 3]", "400": "", "401": "    def test_empty_list(self):", "402": "        \"\"\"Test batching empty list.\"\"\"", "403": "        items = []", "404": "        batches = list(batch_iterator(items, batch_size=5))", "405": "        assert len(batches) == 0", "406": "", "407": "    def test_batch_size_one(self):", "408": "        \"\"\"Test batch size of 1.\"\"\"", "409": "        items = [1, 2, 3]", "410": "        batches = list(batch_iterator(items, batch_size=1))", "411": "        assert len(batches) == 3", "412": "        assert batches[0] == [1]", "413": "        assert batches[1] == [2]", "414": "        assert batches[2] == [3]"}, "src/testiq/reporting.py": {"1": "\"\"\"", "2": "Advanced reporting formats for TestIQ.", "3": "Generates HTML, CSV, and enhanced reports.", "4": "\"\"\"", "5": "", "6": "import csv", "7": "import json", "8": "from datetime import datetime", "9": "from pathlib import Path", "10": "from typing import Any, Optional", "11": "", "12": "from testiq.analyzer import CoverageDuplicateFinder", "13": "from testiq.logging_config import get_logger", "14": "from testiq.source_reader import SourceCodeReader", "15": "", "16": "logger = get_logger(__name__)", "17": "", "18": "", "19": "class HTMLReportGenerator:", "20": "    \"\"\"Generate beautiful HTML reports with charts and styling.\"\"\"", "21": "", "22": "    def __init__(self, finder: CoverageDuplicateFinder) -> None:", "23": "        \"\"\"Initialize HTML report generator.\"\"\"", "24": "        self.finder = finder", "25": "", "26": "    def _build_coverage_data_js(self) -> str:", "27": "        \"\"\"Build JavaScript code to populate coverage data.\"\"\"", "28": "        # Group lines by file", "29": "        file_coverage = {}", "30": "        for test in self.finder.tests:", "31": "            for filename, line in test.covered_lines:", "32": "                if filename not in file_coverage:", "33": "                    file_coverage[filename] = {'lines': set(), 'tests': set()}", "34": "                file_coverage[filename]['lines'].add(line)", "35": "                file_coverage[filename]['tests'].add(test.test_name)", "36": "", "37": "        # Build JS code", "38": "        js_lines = []", "39": "        for filename, data in sorted(file_coverage.items()):", "40": "            lines_count = len(data['lines'])", "41": "            tests_count = len(data['tests'])", "42": "            js_lines.append(f\"coverageByFile[{json.dumps(filename)}] = {{lines: {lines_count}, tests: {tests_count}}};\")", "43": "", "44": "        return '\\n        '.join(js_lines)", "45": "", "46": "    def generate(", "47": "        self,", "48": "        output_path: Path,", "49": "        title: str = \"TestIQ Analysis Report\",", "50": "        threshold: float = 0.7,", "51": "    ) -> None:", "52": "        \"\"\"", "53": "        Generate HTML report.", "54": "", "55": "        Args:", "56": "            output_path: Path to save HTML file", "57": "            title: Report title", "58": "            threshold: Similarity threshold for analysis", "59": "        \"\"\"", "60": "        logger.info(f\"Generating HTML report: {output_path}\")", "61": "", "62": "        exact_dups = self.finder.find_exact_duplicates()", "63": "        subset_dups = self.finder.find_subset_duplicates()", "64": "        # Sort subset duplicates by coverage ratio in descending order", "65": "        subset_dups = sorted(subset_dups, key=lambda x: x[2], reverse=True)", "66": "        similar = self.finder.find_similar_coverage(threshold)", "67": "", "68": "        html = self._generate_html(title, exact_dups, subset_dups, similar, threshold)", "69": "", "70": "        output_path.write_text(html)", "71": "        logger.info(f\"HTML report saved: {output_path}\")", "72": "", "73": "    def _generate_html(", "74": "        self,", "75": "        title: str,", "76": "        exact_dups: list[list[str]],", "77": "        subset_dups: list[tuple[str, str, float]],", "78": "        similar: list[tuple[str, str, float]],", "79": "        threshold: float,", "80": "    ) -> str:", "81": "        \"\"\"Generate HTML content.\"\"\"", "82": "        total_tests = len(self.finder.tests)", "83": "        duplicate_count = sum(len(g) - 1 for g in exact_dups)", "84": "", "85": "        # Calculate statistics", "86": "        duplicate_percentage = (", "87": "            (duplicate_count / total_tests * 100) if total_tests > 0 else 0", "88": "        )", "89": "", "90": "        # Collect and read source files for the split-screen view", "91": "        source_reader = SourceCodeReader()", "92": "        all_files = set()", "93": "        unique_lines_covered = set()", "94": "        for test in self.finder.tests:", "95": "            for filename, line in test.covered_lines:", "96": "                all_files.add(filename)", "97": "                unique_lines_covered.add((filename, line))", "98": "", "99": "        source_code_map = source_reader.read_multiple(list(all_files))", "100": "", "101": "        # Calculate total lines in all files", "102": "        total_lines_in_files = sum(len(lines) for lines in source_code_map.values())", "103": "        lines_covered = len(unique_lines_covered)", "104": "        files_covered = len(all_files)", "105": "", "106": "        coverage_percentage = (lines_covered / total_lines_in_files * 100) if total_lines_in_files > 0 else 0", "107": "        uncovered_percentage = 100 - coverage_percentage if total_lines_in_files > 0 else 0", "108": "", "109": "        html = f\"\"\"<!DOCTYPE html>", "110": "<html lang=\"en\">", "111": "<head>", "112": "    <meta charset=\"UTF-8\">", "113": "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">", "114": "    <title>{title}</title>", "115": "    <style>", "116": "        * {{", "117": "            margin: 0;", "118": "            padding: 0;", "119": "            box-sizing: border-box;", "120": "        }}", "121": "        body {{", "122": "            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;", "123": "            line-height: 1.6;", "124": "            color: #333;", "125": "            background: #f5f7fa;", "126": "            padding: 20px;", "127": "        }}", "128": "        .container {{", "129": "            max-width: 1600px;", "130": "            margin: 0 auto;", "131": "            background: white;", "132": "            border-radius: 8px;", "133": "            box-shadow: 0 2px 8px rgba(0,0,0,0.1);", "134": "            padding: 40px;", "135": "        }}", "136": "        h1 {{", "137": "            color: #2c3e50;", "138": "            margin-bottom: 10px;", "139": "            font-size: 2.5em;", "140": "        }}", "141": "        .timestamp {{", "142": "            color: #7f8c8d;", "143": "            font-size: 0.9em;", "144": "            margin-bottom: 30px;", "145": "        }}", "146": "        .stats {{", "147": "            display: grid;", "148": "            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));", "149": "            gap: 20px;", "150": "            margin-bottom: 40px;", "151": "        }}", "152": "        .stat-card {{", "153": "            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);", "154": "            color: white;", "155": "            padding: 20px;", "156": "            border-radius: 8px;", "157": "            box-shadow: 0 4px 6px rgba(0,0,0,0.1);", "158": "            cursor: pointer;", "159": "            transition: transform 0.2s ease, box-shadow 0.2s ease;", "160": "        }}", "161": "        .stat-card:hover {{", "162": "            transform: translateY(-3px);", "163": "            box-shadow: 0 6px 12px rgba(0,0,0,0.15);", "164": "        }}", "165": "        .stat-card.danger {{", "166": "            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);", "167": "        }}", "168": "        .stat-card.success {{", "169": "            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);", "170": "        }}", "171": "        .stat-card.warning {{", "172": "            background: linear-gradient(135deg, #f7971e 0%, #ffd200 100%);", "173": "        }}", "174": "        .stat-card.info {{", "175": "            background: linear-gradient(135deg, #00c6ff 0%, #0072ff 100%);", "176": "        }}", "177": "        .stat-value {{", "178": "            font-size: 2.5em;", "179": "            font-weight: bold;", "180": "            margin-bottom: 5px;", "181": "        }}", "182": "        .stat-label {{", "183": "            font-size: 0.9em;", "184": "            opacity: 0.9;", "185": "        }}", "186": "        h2 {{", "187": "            color: #2c3e50;", "188": "            margin-top: 40px;", "189": "            margin-bottom: 20px;", "190": "            padding-bottom: 10px;", "191": "            border-bottom: 3px solid #00c6ff;", "192": "        }}", "193": "        table {{", "194": "            width: 100%;", "195": "            border-collapse: collapse;", "196": "            margin-bottom: 30px;", "197": "            background: white;", "198": "        }}", "199": "        th {{", "200": "            background: #00c6ff;", "201": "            color: white;", "202": "            padding: 12px;", "203": "            text-align: left;", "204": "            font-weight: 600;", "205": "        }}", "206": "        td {{", "207": "            padding: 12px;", "208": "            border-bottom: 1px solid #ecf0f1;", "209": "            word-break: break-word;", "210": "            overflow-wrap: break-word;", "211": "            max-width: 400px;", "212": "        }}", "213": "        tr:hover {{", "214": "            background: #f8f9fa;", "215": "        }}", "216": "        .badge {{", "217": "            display: inline-block;", "218": "            padding: 4px 12px;", "219": "            border-radius: 12px;", "220": "            font-size: 0.85em;", "221": "            font-weight: 600;", "222": "        }}", "223": "        .badge-danger {{", "224": "            background: #fee;", "225": "            color: #c33;", "226": "        }}", "227": "        .badge-warning {{", "228": "            background: #ffeaa7;", "229": "            color: #d63031;", "230": "        }}", "231": "        .badge-info {{", "232": "            background: #dfe6e9;", "233": "            color: #2d3436;", "234": "        }}", "235": "        .test-group {{", "236": "            background: #f8f9fa;", "237": "            padding: 15px;", "238": "            border-radius: 6px;", "239": "            margin-bottom: 15px;", "240": "            border-left: 4px solid #00c6ff;", "241": "        }}", "242": "        .test-name {{", "243": "            font-family: 'Courier New', monospace;", "244": "            font-size: 0.9em;", "245": "            background: #ecf0f1;", "246": "            padding: 2px 6px;", "247": "            border-radius: 3px;", "248": "            display: inline-block;", "249": "            max-width: 100%;", "250": "            line-height: 1.6;", "251": "        }}", "252": "        .test-name .test-part {{", "253": "            display: inline;", "254": "        }}", "255": "        .test-name .test-separator {{", "256": "            color: #3498db;", "257": "            font-weight: bold;", "258": "            margin: 0 2px;", "259": "        }}", "260": "        .action {{", "261": "            color: #27ae60;", "262": "            font-weight: 600;", "263": "        }}", "264": "        .footer {{", "265": "            margin-top: 60px;", "266": "            padding-top: 20px;", "267": "            border-top: 1px solid #ecf0f1;", "268": "            text-align: center;", "269": "            color: #7f8c8d;", "270": "            font-size: 0.9em;", "271": "        }}", "272": "        .clickable-row {{", "273": "            cursor: pointer;", "274": "            transition: all 0.2s ease;", "275": "        }}", "276": "        .clickable-row:hover {{", "277": "            background: #e8f4f8 !important;", "278": "            transform: translateX(3px);", "279": "        }}", "280": "        .modal {{", "281": "            display: none;", "282": "            position: fixed;", "283": "            z-index: 1000;", "284": "            left: 0;", "285": "            top: 0;", "286": "            width: 100%;", "287": "            height: 100%;", "288": "            background-color: rgba(0,0,0,0.7);", "289": "            animation: fadeIn 0.3s;", "290": "        }}", "291": "        .modal-content {{", "292": "            background-color: white;", "293": "            margin: 10px auto;", "294": "            padding: 0;", "295": "            width: calc(100% - 20px);", "296": "            height: calc(100vh - 20px);", "297": "            border-radius: 8px;", "298": "            box-shadow: 0 4px 20px rgba(0,0,0,0.3);", "299": "            display: flex;", "300": "            flex-direction: column;", "301": "            overflow: hidden;", "302": "        }}", "303": "        .modal-header {{", "304": "            padding: 20px;", "305": "            background: linear-gradient(135deg, #00c6ff 0%, #764ba2 100%);", "306": "            color: white;", "307": "            border-radius: 8px 8px 0 0;", "308": "            display: flex;", "309": "            justify-content: space-between;", "310": "            align-items: center;", "311": "            flex-shrink: 0;", "312": "        }}", "313": "        .close {{", "314": "            color: white;", "315": "            font-size: 32px;", "316": "            font-weight: bold;", "317": "            cursor: pointer;", "318": "            line-height: 1;", "319": "            transition: transform 0.2s;", "320": "        }}", "321": "        .close:hover {{", "322": "            transform: scale(1.2);", "323": "        }}", "324": "        .split-view {{", "325": "            display: flex;", "326": "            flex: 1;", "327": "            overflow-y: auto;", "328": "            overflow-x: hidden;", "329": "            min-height: 0;", "330": "        }}", "331": "        .split-view.independent {{", "332": "            overflow: hidden;", "333": "        }}", "334": "        .file-panel {{", "335": "            flex: 1;", "336": "            display: flex;", "337": "            flex-direction: column;", "338": "            border-right: 2px solid #ecf0f1;", "339": "            min-width: 0;", "340": "        }}", "341": "        .file-panel.independent {{", "342": "            overflow-y: auto;", "343": "        }}", "344": "        .file-panel:last-child {{", "345": "            border-right: none;", "346": "        }}", "347": "        .panel-header {{", "348": "            padding: 15px;", "349": "            background: #f8f9fa;", "350": "            border-bottom: 2px solid #ecf0f1;", "351": "            font-weight: 600;", "352": "            color: #2c3e50;", "353": "            position: sticky;", "354": "            top: 0;", "355": "            z-index: 10;", "356": "            flex-shrink: 0;", "357": "        }}", "358": "        .file-content {{", "359": "            padding: 20px;", "360": "            font-family: 'Courier New', monospace;", "361": "            font-size: 0.9em;", "362": "            line-height: 1.8;", "363": "            background: #fafafa;", "364": "        }}", "365": "        .code-line {{", "366": "            padding: 2px 8px;", "367": "            border-radius: 3px;", "368": "            margin: 1px 0;", "369": "            white-space: pre;", "370": "        }}", "371": "        .covered {{", "372": "            background: #d4edda;", "373": "            border-left: 3px solid #28a745;", "374": "            font-weight: 600;", "375": "        }}", "376": "        .not-covered {{", "377": "            opacity: 0.6;", "378": "        }}", "379": "        .file-path {{", "380": "            font-family: 'Courier New', monospace;", "381": "            font-size: 0.85em;", "382": "            color: #7f8c8d;", "383": "            font-weight: bold;", "384": "            margin-bottom: 10px;", "385": "        }}", "386": "        .coverage-info {{", "387": "            background: #e8f4f8;", "388": "            padding: 15px;", "389": "            margin: 10px 20px;", "390": "            border-left: 4px solid #00c6ff;", "391": "            border-radius: 4px;", "392": "            display: flex;", "393": "            align-items: center;", "394": "            gap: 20px;", "395": "            flex-wrap: wrap;", "396": "            flex-shrink: 0;", "397": "        }}", "398": "        .filter-section {{", "399": "            display: flex;", "400": "            align-items: center;", "401": "            gap: 5px;", "402": "        }}", "403": "        .filter-select {{", "404": "            padding: 6px 10px;", "405": "            border: 1px solid rgba(255,255,255,0.5);", "406": "            border-radius: 4px;", "407": "            font-size: 0.85em;", "408": "            background: rgba(255,255,255,0.95);", "409": "            cursor: pointer;", "410": "            min-width: 180px;", "411": "            color: #2c3e50;", "412": "        }}", "413": "        .filter-select:hover {{", "414": "            background: white;", "415": "            border-color: white;", "416": "        }}", "417": "        .sync-toggle {{", "418": "            display: flex;", "419": "            align-items: center;", "420": "            gap: 6px;", "421": "            padding: 6px 12px;", "422": "            background: rgba(255,255,255,0.95);", "423": "            border: 1px solid rgba(255,255,255,0.5);", "424": "            border-radius: 4px;", "425": "            cursor: pointer;", "426": "            transition: all 0.2s;", "427": "            font-size: 0.85em;", "428": "            color: #2c3e50;", "429": "        }}", "430": "        .sync-toggle:hover {{", "431": "            background: white;", "432": "            border-color: white;", "433": "            background: #f0f0ff;", "434": "        }}", "435": "        .sync-toggle.active {{", "436": "            background: #00c6ff;", "437": "            color: white;", "438": "        }}", "439": "        .sync-checkbox {{", "440": "            width: 18px;", "441": "            height: 18px;", "442": "            cursor: pointer;", "443": "        }}", "444": "            border-left: 4px solid #00c6ff;", "445": "            border-radius: 4px;", "446": "        }}", "447": "        @keyframes fadeIn {{", "448": "            from {{ opacity: 0; }}", "449": "            to {{ opacity: 1; }}", "450": "        }}", "451": "        .progress-bar {{", "452": "            height: 30px;", "453": "            background: #ecf0f1;", "454": "            border-radius: 15px;", "455": "            overflow: hidden;", "456": "            margin: 20px 0;", "457": "        }}", "458": "        .progress-fill {{", "459": "            height: 100%;", "460": "            background: linear-gradient(90deg, #00c6ff 0%, #0072ff 100%);", "461": "            display: flex;", "462": "            align-items: center;", "463": "            justify-content: center;", "464": "            color: white;", "465": "            font-weight: 600;", "466": "            transition: width 0.3s ease;", "467": "        }}", "468": "        .tabs {{", "469": "            display: flex;", "470": "            gap: 10px;", "471": "            margin: 30px 0 20px 0;", "472": "            border-bottom: 2px solid #ecf0f1;", "473": "        }}", "474": "        .tab {{", "475": "            padding: 12px 24px;", "476": "            background: #f8f9fa;", "477": "            border: none;", "478": "            border-radius: 8px 8px 0 0;", "479": "            cursor: pointer;", "480": "            font-weight: 600;", "481": "            font-size: 16px;", "482": "            color: #7f8c8d;", "483": "            transition: all 0.3s ease;", "484": "            position: relative;", "485": "            bottom: -2px;", "486": "        }}", "487": "        .tab:hover {{", "488": "            background: #e9ecef;", "489": "            color: #495057;", "490": "        }}", "491": "        .tab.active {{", "492": "            background: white;", "493": "            color: #00c6ff;", "494": "            border-bottom: 2px solid #00c6ff;", "495": "        }}", "496": "        .tab-content {{", "497": "            display: none;", "498": "            animation: fadeIn 0.3s;", "499": "        }}", "500": "        .tab-content.active {{", "501": "            display: block;", "502": "        }}", "503": "        .pagination {{", "504": "            display: flex;", "505": "            justify-content: center;", "506": "            align-items: center;", "507": "            gap: 10px;", "508": "            margin: 20px 0;", "509": "        }}", "510": "        .page-btn {{", "511": "            padding: 8px 12px;", "512": "            background: #00c6ff;", "513": "            color: white;", "514": "            border: none;", "515": "            border-radius: 4px;", "516": "            cursor: pointer;", "517": "            font-weight: 600;", "518": "            transition: all 0.2s ease;", "519": "        }}", "520": "        .page-btn:hover:not(:disabled) {{", "521": "            background: #0088cc;", "522": "            transform: translateY(-2px);", "523": "        }}", "524": "        .page-btn:disabled {{", "525": "            background: #bdc3c7;", "526": "            cursor: not-allowed;", "527": "            opacity: 0.6;", "528": "        }}", "529": "        .page-info {{", "530": "            color: #7f8c8d;", "531": "            font-weight: 600;", "532": "        }}", "533": "        .loading {{", "534": "            text-align: center;", "535": "            padding: 20px;", "536": "            color: #00c6ff;", "537": "        }}", "538": "        .spinner {{", "539": "            border: 3px solid #f3f3f3;", "540": "            border-top: 3px solid #00c6ff;", "541": "            border-radius: 50%;", "542": "            width: 40px;", "543": "            height: 40px;", "544": "            animation: spin 1s linear infinite;", "545": "            margin: 20px auto;", "546": "        }}", "547": "        @keyframes spin {{", "548": "            0% {{ transform: rotate(0deg); }}", "549": "            100% {{ transform: rotate(360deg); }}", "550": "        }}", "551": "    </style>", "552": "</head>", "553": "<body>", "554": "    <div class=\"container\">", "555": "        <h1>\ud83e\uddea {title}</h1>", "556": "        <div class=\"timestamp\">Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</div>", "557": "", "558": "        <div class=\"stats\">", "559": "            <div class=\"stat-card\" onclick=\"switchTab('exact')\">", "560": "                <div class=\"stat-value\">{total_tests}</div>", "561": "                <div class=\"stat-label\">Total Test Methods</div>", "562": "            </div>", "563": "            <div class=\"stat-card danger\" onclick=\"switchTab('exact')\">", "564": "                <div class=\"stat-value\">{duplicate_count}</div>", "565": "                <div class=\"stat-label\">Duplicates</div>", "566": "            </div>", "567": "            <div class=\"stat-card info\" onclick=\"switchTab('similar')\">", "568": "                <div class=\"stat-value\">{len(similar)}</div>", "569": "                <div class=\"stat-label\">Similar Test Pairs</div>", "570": "            </div>", "571": "            <div class=\"stat-card warning\" onclick=\"switchTab('subset')\">", "572": "                <div class=\"stat-value\">{len(subset_dups)}</div>", "573": "                <div class=\"stat-label\">Subset Duplicates</div>", "574": "            </div>", "575": "            <div class=\"stat-card success\">", "576": "                <div class=\"stat-value\">{coverage_percentage:.1f}%</div>", "577": "                <div class=\"stat-label\">Lines Covered</div>", "578": "            </div>", "579": "            <div class=\"stat-card warning\">", "580": "                <div class=\"stat-value\">{uncovered_percentage:.1f}%</div>", "581": "                <div class=\"stat-label\">Lines Uncovered</div>", "582": "            </div>", "583": "        </div>", "584": "", "585": "        <div class=\"progress-bar\">", "586": "            <div class=\"progress-fill\" style=\"width: {duplicate_percentage:.1f}%\">", "587": "                {duplicate_percentage:.1f}%", "588": "            </div>", "589": "        </div>", "590": "", "591": "        <div class=\"tabs\">", "592": "            <button class=\"tab active\" onclick=\"switchTab('exact')\">\ud83c\udfaf Exact Duplicates ({len(exact_dups)})</button>", "593": "            <button class=\"tab\" onclick=\"switchTab('similar')\">\ud83d\udd0d Similar Tests ({len(similar)})</button>", "594": "            <button class=\"tab\" onclick=\"switchTab('subset')\">\ud83d\udcca Subset Duplicates ({len(subset_dups)})</button>", "595": "        </div>", "596": "", "597": "        <div id=\"exact-content\" class=\"tab-content active\">", "598": "            <h2>\ud83c\udfaf Exact Duplicates</h2>", "599": "            <p>Tests with identical code coverage that can be safely removed.</p>", "600": "            <div id=\"exact-table\"></div>", "601": "            <div id=\"exact-pagination\" class=\"pagination\"></div>", "602": "        </div>", "603": "", "604": "        <div id=\"similar-content\" class=\"tab-content\">", "605": "            <h2>\ud83d\udd0d Similar Tests (\u2265{threshold:.0%} overlap)</h2>", "606": "            <p>Test pairs with significant code coverage overlap that may indicate redundancy.</p>", "607": "            <div id=\"similar-table\"></div>", "608": "            <div id=\"similar-pagination\" class=\"pagination\"></div>", "609": "        </div>", "610": "", "611": "        <div id=\"subset-content\" class=\"tab-content\">", "612": "            <h2>\ud83d\udcca Subset Duplicates</h2>", "613": "            <p>Tests that are subsets of other tests and may be redundant.</p>", "614": "            <div id=\"subset-table\"></div>", "615": "            <div id=\"subset-pagination\" class=\"pagination\"></div>", "616": "        </div>", "617": "", "618": "        <script>", "619": "        // Utility function for escaping HTML to prevent XSS", "620": "        function escapeHtml(text) {{", "621": "            const div = document.createElement('div');", "622": "            div.textContent = text;", "623": "            return div.innerHTML;", "624": "        }}", "625": "", "626": "        // Utility function to format test names with separators", "627": "        function formatTestName(testName) {{", "628": "            // Split test name at :: for better readability", "629": "            const parts = testName.split('::');", "630": "            if (parts.length === 1) return testName;", "631": "", "632": "            return parts.map((part, idx) => {{", "633": "                if (idx === parts.length - 1) {{", "634": "                    return '<span class=\"test-part\">' + part + '</span>';", "635": "                }}", "636": "                return '<span class=\"test-part\">' + part + '</span><span class=\"test-separator\">::</span><wbr>';", "637": "            }}).join('');", "638": "        }}", "639": "", "640": "        // Data for pagination", "641": "        const exactDupsData = {json.dumps([[list(group), i-1] for i, group in enumerate(exact_dups, 1)])};", "642": "        const similarData = {json.dumps([[test1, test2, similarity, len(exact_dups) + idx] for idx, (test1, test2, similarity) in enumerate(similar)])};", "643": "        const subsetData = {json.dumps([[subset_test, superset_test, ratio, len(exact_dups) + len(similar) + i] for i, (subset_test, superset_test, ratio) in enumerate(subset_dups)])};", "644": "", "645": "        // Build coverage data per file", "646": "        const coverageByFile = {{}};", "647": "        {self._build_coverage_data_js()}", "648": "", "649": "        const itemsPerPage = 20;", "650": "        let currentPages = {{ exact: 1, similar: 1, subset: 1, coverage: 1 }};", "651": "", "652": "        function truncateTestName(testName) {{", "653": "            if (!testName || typeof testName !== 'string') {{", "654": "                return '';", "655": "            }}", "656": "", "657": "            // Extract just the meaningful parts of the test name", "658": "            const parts = testName.split('::');", "659": "            if (parts.length <= 2) {{", "660": "                return testName;", "661": "            }}", "662": "", "663": "            try {{", "664": "                // Get the file name (without path)", "665": "                const filePart = parts[0].split('/').pop() || parts[0];", "666": "                // Get the class name (if exists) and test name", "667": "                const classPart = parts.length > 2 ? parts[parts.length - 2] : '';", "668": "                const testPart = parts[parts.length - 1];", "669": "", "670": "                // Format: FileName::Class::test_name", "671": "                if (classPart) {{", "672": "                    return filePart + '::' + classPart + '::' + testPart;", "673": "                }} else {{", "674": "                    return filePart + '::' + testPart;", "675": "                }}", "676": "            }} catch (e) {{", "677": "                console.error('Error truncating test name:', e);", "678": "                return testName;", "679": "            }}", "680": "        }}", "681": "", "682": "        function switchTab(tabName) {{", "683": "            // Hide all tabs", "684": "            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));", "685": "            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));", "686": "", "687": "            // Show selected tab", "688": "            event.target.classList.add('active');", "689": "            document.getElementById(tabName + '-content').classList.add('active');", "690": "        }}", "691": "", "692": "        function renderExactDuplicates(page) {{", "693": "            const start = (page - 1) * itemsPerPage;", "694": "            const end = start + itemsPerPage;", "695": "            const pageData = exactDupsData.slice(start, end);", "696": "", "697": "            let html = '';", "698": "            if (pageData.length === 0) {{", "699": "                html = '<p style=\"color: #27ae60; text-align: center; padding: 20px;\">\u2713 No exact duplicates found!</p>';", "700": "            }} else {{", "701": "                html = `", "702": "                <table>", "703": "                    <thead>", "704": "                        <tr>", "705": "                            <th>Group</th>", "706": "                            <th>Tests</th>", "707": "                            <th>Count</th>", "708": "                            <th>Action</th>", "709": "                        </tr>", "710": "                    </thead>", "711": "                    <tbody>`;", "712": "", "713": "                pageData.forEach(([group, coverageIdx], idx) => {{", "714": "                    const groupNum = start + idx + 1;", "715": "                    const testList = group.map(test => {{", "716": "                        if (!test) return '';", "717": "                        const truncated = truncateTestName(test);", "718": "                        return `<span class=\"test-name\" title=\"${{escapeHtml(test)}}\" style=\"cursor: help;\">${{escapeHtml(truncated)}}</span>`;", "719": "                    }}).filter(t => t).join('<br>');", "720": "                    html += `", "721": "                        <tr class=\"clickable-row\" onclick=\"showComparison(${{coverageIdx}})\">", "722": "                            <td><strong>Group ${{groupNum}}</strong></td>", "723": "                            <td>${{testList}}</td>", "724": "                            <td><span class=\"badge badge-danger\">${{group.length}} tests</span></td>", "725": "                            <td><span style=\"color: #00c6ff; font-weight: 600;\">\ud83d\udd0d View Coverage</span></td>", "726": "                        </tr>`;", "727": "                }});", "728": "", "729": "                html += '</tbody></table>';", "730": "            }}", "731": "", "732": "            document.getElementById('exact-table').innerHTML = html;", "733": "            renderPagination('exact', exactDupsData.length, page);", "734": "            formatTestNames();", "735": "        }}", "736": "", "737": "        function renderSimilarTests(page) {{", "738": "            const start = (page - 1) * itemsPerPage;", "739": "            const end = start + itemsPerPage;", "740": "            const pageData = similarData.slice(start, end);", "741": "", "742": "            let html = '';", "743": "            if (pageData.length === 0) {{", "744": "                html = '<p style=\"color: #27ae60; text-align: center; padding: 20px;\">\u2713 No similar tests found!</p>';", "745": "            }} else {{", "746": "                html = `", "747": "                <table>", "748": "                    <thead>", "749": "                        <tr>", "750": "                            <th>Test 1</th>", "751": "                            <th>Test 2</th>", "752": "                            <th>Similarity</th>", "753": "                            <th>Action</th>", "754": "                        </tr>", "755": "                    </thead>", "756": "                    <tbody>`;", "757": "", "758": "                pageData.forEach(([test1, test2, similarity, coverageIdx]) => {{", "759": "                    if (!test1 || !test2) return;", "760": "                    const t1 = escapeHtml(truncateTestName(test1));", "761": "                    const t2 = escapeHtml(truncateTestName(test2));", "762": "                    const simPercent = (similarity * 100).toFixed(1);", "763": "                    html += `", "764": "                        <tr class=\"clickable-row\" onclick=\"showComparison(${{coverageIdx}})\">", "765": "                            <td><span class=\"test-name\" title=\"${{escapeHtml(test1)}}\" style=\"cursor: help;\">${{t1}}</span></td>", "766": "                            <td><span class=\"test-name\" title=\"${{escapeHtml(test2)}}\" style=\"cursor: help;\">${{t2}}</span></td>", "767": "                            <td><span class=\"badge badge-info\">${{simPercent}}%</span></td>", "768": "                            <td><span style=\"color: #00c6ff; font-weight: 600;\">\ud83d\udd0d View Coverage</span></td>", "769": "                        </tr>`;", "770": "                }});", "771": "", "772": "                html += '</tbody></table>';", "773": "            }}", "774": "", "775": "            document.getElementById('similar-table').innerHTML = html;", "776": "            renderPagination('similar', similarData.length, page);", "777": "            formatTestNames();", "778": "        }}", "779": "", "780": "        function renderSubsetDuplicates(page) {{", "781": "            const start = (page - 1) * itemsPerPage;", "782": "            const end = start + itemsPerPage;", "783": "            const pageData = subsetData.slice(start, end);", "784": "", "785": "            let html = '';", "786": "            if (pageData.length === 0) {{", "787": "                html = '<p style=\"color: #27ae60; text-align: center; padding: 20px;\">\u2713 No subset duplicates found!</p>';", "788": "            }} else {{", "789": "                html = `", "790": "                <table>", "791": "                    <thead>", "792": "                        <tr>", "793": "                            <th>Subset Test</th>", "794": "                            <th>Superset Test</th>", "795": "                            <th>Coverage Ratio</th>", "796": "                            <th>Action</th>", "797": "                        </tr>", "798": "                    </thead>", "799": "                    <tbody>`;", "800": "", "801": "                pageData.forEach(([subsetTest, supersetTest, ratio, coverageIdx]) => {{", "802": "                    if (!subsetTest || !supersetTest) return;", "803": "                    const sub = escapeHtml(truncateTestName(subsetTest));", "804": "                    const sup = escapeHtml(truncateTestName(supersetTest));", "805": "                    const ratioPercent = (ratio * 100).toFixed(1);", "806": "                    html += `", "807": "                        <tr class=\"clickable-row\" onclick=\"showComparison(${{coverageIdx}})\">", "808": "                            <td><span class=\"test-name\" title=\"${{escapeHtml(subsetTest)}}\" style=\"cursor: help;\">${{sub}}</span></td>", "809": "                            <td><span class=\"test-name\" title=\"${{escapeHtml(supersetTest)}}\" style=\"cursor: help;\">${{sup}}</span></td>", "810": "                            <td><span class=\"badge badge-warning\">${{ratioPercent}}%</span></td>", "811": "                            <td><span style=\"color: #00c6ff; font-weight: 600;\">\ud83d\udd0d View Coverage</span></td>", "812": "                        </tr>`;", "813": "                }});", "814": "", "815": "                html += '</tbody></table>';", "816": "            }}", "817": "", "818": "            document.getElementById('subset-table').innerHTML = html;", "819": "            renderPagination('subset', subsetData.length, page);", "820": "            formatTestNames();", "821": "        }}", "822": "", "823": "        function renderPagination(type, totalItems, currentPage) {{", "824": "            const totalPages = Math.ceil(totalItems / itemsPerPage);", "825": "", "826": "            if (totalPages <= 1) {{", "827": "                document.getElementById(type + '-pagination').innerHTML = '';", "828": "                return;", "829": "            }}", "830": "", "831": "            const start = (currentPage - 1) * itemsPerPage + 1;", "832": "            const end = Math.min(currentPage * itemsPerPage, totalItems);", "833": "", "834": "            let html = '<button class=\"page-btn\" onclick=\"changePage(\\\\'' + type + '\\\\', ' + (currentPage - 1) + ')\" ' +", "835": "                (currentPage === 1 ? 'disabled' : '') + '>\u2190 Previous</button>' +", "836": "                '<span class=\"page-info\">' + start + '-' + end + ' of ' + totalItems + ' | Page ' + currentPage + '/' + totalPages + '</span>' +", "837": "                '<button class=\"page-btn\" onclick=\"changePage(\\\\'' + type + '\\\\', ' + (currentPage + 1) + ')\" ' +", "838": "                (currentPage === totalPages ? 'disabled' : '') + '>Next \u2192</button>';", "839": "", "840": "            document.getElementById(type + '-pagination').innerHTML = html;", "841": "        }}", "842": "", "843": "        function changePage(type, newPage) {{", "844": "            currentPages[type] = newPage;", "845": "", "846": "            if (type === 'exact') {{", "847": "                renderExactDuplicates(newPage);", "848": "            }} else if (type === 'similar') {{", "849": "                renderSimilarTests(newPage);", "850": "            }} else if (type === 'subset') {{", "851": "                renderSubsetDuplicates(newPage);", "852": "            }}", "853": "", "854": "            // Scroll to top of table", "855": "            document.getElementById(type + '-content').scrollIntoView({{ behavior: 'smooth', block: 'start' }});", "856": "        }}", "857": "", "858": "        function formatTestNames() {{", "859": "            const testNames = document.querySelectorAll('.test-name');", "860": "            testNames.forEach(el => {{", "861": "                const originalText = el.textContent;", "862": "                if (originalText.includes('::')) {{", "863": "                    el.innerHTML = formatTestName(originalText);", "864": "                }}", "865": "            }});", "866": "        }}", "867": "", "868": "        // Initial render", "869": "        renderExactDuplicates(1);", "870": "        renderSimilarTests(1);", "871": "        renderSubsetDuplicates(1);", "872": "        </script>", "873": "\"\"\"", "874": "", "875": "        # Add modal and JavaScript for split-screen view", "876": "        test_coverage_map = {test.test_name: test.covered_lines for test in self.finder.tests}", "877": "", "878": "        coverage_data = []", "879": "", "880": "        # Add exact duplicates data (first in order)", "881": "        for group in exact_dups:", "882": "            if len(group) < 2:", "883": "                continue", "884": "            # Compare first test with second test in group", "885": "            test1 = group[0]", "886": "            test2 = group[1]", "887": "            test1_cov = test_coverage_map.get(test1, set())", "888": "            test2_cov = test_coverage_map.get(test2, set())", "889": "", "890": "            # Convert to dict format", "891": "            test1_dict = {}", "892": "            for filename, line in test1_cov:", "893": "                if filename not in test1_dict:", "894": "                    test1_dict[filename] = []", "895": "                test1_dict[filename].append(line)", "896": "", "897": "            test2_dict = {}", "898": "            for filename, line in test2_cov:", "899": "                if filename not in test2_dict:", "900": "                    test2_dict[filename] = []", "901": "                test2_dict[filename].append(line)", "902": "", "903": "            # Sort line numbers", "904": "            for lines in test1_dict.values():", "905": "                lines.sort()", "906": "            for lines in test2_dict.values():", "907": "                lines.sort()", "908": "", "909": "            coverage_data.append({", "910": "                \"subset\": test1_dict,", "911": "                \"superset\": test2_dict,", "912": "                \"ratio\": 1.0,", "913": "                \"subsetName\": test1,", "914": "                \"supersetName\": test2", "915": "            })", "916": "", "917": "        # Add similar tests data (second in order)", "918": "        for test1, test2, similarity in similar[:20]:", "919": "            test1_cov = test_coverage_map.get(test1, set())", "920": "            test2_cov = test_coverage_map.get(test2, set())", "921": "", "922": "            # Convert to dict format", "923": "            test1_dict = {}", "924": "            for filename, line in test1_cov:", "925": "                if filename not in test1_dict:", "926": "                    test1_dict[filename] = []", "927": "                test1_dict[filename].append(line)", "928": "", "929": "            test2_dict = {}", "930": "            for filename, line in test2_cov:", "931": "                if filename not in test2_dict:", "932": "                    test2_dict[filename] = []", "933": "                test2_dict[filename].append(line)", "934": "", "935": "            # Sort line numbers", "936": "            for lines in test1_dict.values():", "937": "                lines.sort()", "938": "            for lines in test2_dict.values():", "939": "                lines.sort()", "940": "", "941": "            coverage_data.append({", "942": "                \"subset\": test1_dict,", "943": "                \"superset\": test2_dict,", "944": "                \"ratio\": similarity,", "945": "                \"subsetName\": test1,", "946": "                \"supersetName\": test2", "947": "            })", "948": "", "949": "        # Add subset duplicates data (third in order)", "950": "        for subset_test, superset_test, ratio in subset_dups[:20]:", "951": "            subset_cov = test_coverage_map.get(subset_test, set())", "952": "            superset_cov = test_coverage_map.get(superset_test, set())", "953": "", "954": "            # Convert to dict format", "955": "            subset_dict = {}", "956": "            for filename, line in subset_cov:", "957": "                if filename not in subset_dict:", "958": "                    subset_dict[filename] = []", "959": "                subset_dict[filename].append(line)", "960": "", "961": "            superset_dict = {}", "962": "            for filename, line in superset_cov:", "963": "                if filename not in superset_dict:", "964": "                    superset_dict[filename] = []", "965": "                superset_dict[filename].append(line)", "966": "", "967": "            # Sort line numbers", "968": "            for lines in subset_dict.values():", "969": "                lines.sort()", "970": "            for lines in superset_dict.values():", "971": "                lines.sort()", "972": "", "973": "            coverage_data.append({", "974": "                \"subset\": subset_dict,", "975": "                \"superset\": superset_dict,", "976": "                \"ratio\": ratio,", "977": "                \"subsetName\": subset_test,", "978": "                \"supersetName\": superset_test", "979": "            })", "980": "", "981": "        html += f\"\"\"", "982": "        <!-- Modal for split-screen coverage view -->", "983": "        <div id=\"comparisonModal\" class=\"modal\">", "984": "            <div class=\"modal-content\">", "985": "                <div class=\"modal-header\">", "986": "                    <h2 style=\"margin: 0;\">\ud83d\udcca Coverage Comparison</h2>", "987": "                    <div style=\"display: flex; align-items: center; gap: 15px;\">", "988": "                        <div class=\"filter-section\">", "989": "                            <label for=\"fileFilter\" style=\"font-weight: 600; margin-right: 8px;\">\ud83d\udcc1</label>", "990": "                            <select id=\"fileFilter\" class=\"filter-select\" onchange=\"applyFileFilter()\">", "991": "                                <option value=\"\">All Files</option>", "992": "                            </select>", "993": "                        </div>", "994": "                        <div class=\"sync-toggle\" id=\"syncToggle\" onclick=\"toggleSync()\">", "995": "                            <input type=\"checkbox\" id=\"syncCheckbox\" class=\"sync-checkbox\" checked>", "996": "                            <label for=\"syncCheckbox\" style=\"cursor: pointer; user-select: none;\">\ud83d\udd17 Sync Scroll</label>", "997": "                        </div>", "998": "                        <span class=\"close\" onclick=\"closeModal()\">&times;</span>", "999": "                    </div>", "1000": "                </div>", "1001": "                <div class=\"coverage-info\">", "1002": "                    <div>", "1003": "                        <strong>Subset Test:</strong> <span id=\"subsetName\" class=\"test-name\"></span>", "1004": "                        &nbsp;&nbsp;|&nbsp;&nbsp;", "1005": "                        <strong>Superset Test:</strong> <span id=\"supersetName\" class=\"test-name\"></span>", "1006": "                        &nbsp;&nbsp;|&nbsp;&nbsp;", "1007": "                        <strong>Coverage Ratio:</strong> <span id=\"coverageRatio\" class=\"badge badge-warning\"></span>", "1008": "                    </div>", "1009": "                </div>", "1010": "                <div class=\"split-view\">", "1011": "                    <div class=\"file-panel\">", "1012": "                        <div class=\"panel-header\">\ud83d\udcc4 Subset Test Coverage</div>", "1013": "                        <div id=\"subsetContent\" class=\"file-content\"></div>", "1014": "                    </div>", "1015": "                    <div class=\"file-panel\">", "1016": "                        <div class=\"panel-header\">\ud83d\udcc4 Superset Test Coverage</div>", "1017": "                        <div id=\"supersetContent\" class=\"file-content\"></div>", "1018": "                    </div>", "1019": "                </div>", "1020": "            </div>", "1021": "        </div>", "1022": "", "1023": "        <script>", "1024": "        const coverageData = {json.dumps(coverage_data, ensure_ascii=True)};", "1025": "        const sourceCode = {json.dumps(source_code_map, ensure_ascii=True)};", "1026": "        let currentData = null;", "1027": "        let syncEnabled = true;", "1028": "        let isScrolling = false;", "1029": "", "1030": "        function showComparison(index) {{", "1031": "            const data = coverageData[index];", "1032": "            if (!data) return;", "1033": "", "1034": "            currentData = data;", "1035": "", "1036": "            document.getElementById('subsetName').innerHTML = formatTestName(data.subsetName);", "1037": "            document.getElementById('supersetName').innerHTML = formatTestName(data.supersetName);", "1038": "            document.getElementById('coverageRatio').textContent = (data.ratio * 100).toFixed(1) + '%';", "1039": "", "1040": "            // Populate file filter", "1041": "            const allFiles = new Set([...Object.keys(data.subset), ...Object.keys(data.superset)]);", "1042": "            const fileFilter = document.getElementById('fileFilter');", "1043": "            fileFilter.innerHTML = '<option value=\"\">All Files</option>';", "1044": "            Array.from(allFiles).sort().forEach(file => {{", "1045": "                const option = document.createElement('option');", "1046": "                option.value = file;", "1047": "                option.textContent = file;", "1048": "                fileFilter.appendChild(option);", "1049": "            }});", "1050": "", "1051": "            renderBothPanels();", "1052": "", "1053": "            document.getElementById('comparisonModal').style.display = 'block';", "1054": "", "1055": "            // Scroll to top of the modal", "1056": "            const splitView = document.querySelector('.split-view');", "1057": "            if (splitView) {{", "1058": "                splitView.scrollTop = 0;", "1059": "            }}", "1060": "        }}", "1061": "", "1062": "        function renderBothPanels() {{", "1063": "            const selectedFile = document.getElementById('fileFilter').value;", "1064": "", "1065": "            // Get all unique files from both sides", "1066": "            const subsetFiles = Object.keys(currentData.subset).sort();", "1067": "            const supersetFiles = Object.keys(currentData.superset).sort();", "1068": "            const allFiles = [...new Set([...subsetFiles, ...supersetFiles])].sort();", "1069": "", "1070": "            // Apply file filter", "1071": "            const filesToRender = selectedFile ? [selectedFile] : allFiles;", "1072": "", "1073": "            let subsetHtml = '';", "1074": "            let supersetHtml = '';", "1075": "", "1076": "            for (const file of filesToRender) {{", "1077": "                const subsetLines = currentData.subset[file] || [];", "1078": "                const supersetLines = currentData.superset[file] || [];", "1079": "", "1080": "                // Get all unique line numbers from both sides", "1081": "                let allLineNums = [...new Set([...subsetLines, ...supersetLines])].sort((a, b) => a - b);", "1082": "", "1083": "                if (allLineNums.length === 0) continue;", "1084": "", "1085": "                const subsetLineSet = new Set(subsetLines);", "1086": "                const supersetLineSet = new Set(supersetLines);", "1087": "                const fileSource = sourceCode[file] || {{}};", "1088": "", "1089": "                // Find and include method/class definitions for context", "1090": "                const minLine = Math.min(...allLineNums);", "1091": "                const maxLine = Math.max(...allLineNums);", "1092": "                const contextLines = new Set(allLineNums);", "1093": "", "1094": "                // Scan backwards from each covered line to find def/class", "1095": "                for (const lineNum of allLineNums) {{", "1096": "                    for (let i = lineNum - 1; i >= Math.max(1, minLine - 20); i--) {{", "1097": "                        const line = fileSource[i] || '';", "1098": "                        const trimmed = line.trim();", "1099": "                        if (trimmed.startsWith('def ') || trimmed.startsWith('class ') || trimmed.startsWith('async def ')) {{", "1100": "                            contextLines.add(i);", "1101": "                            break;", "1102": "                        }}", "1103": "                        // Stop if we hit another definition or empty line followed by def", "1104": "                        if (trimmed === '' && i < lineNum - 5) break;", "1105": "                    }}", "1106": "                }}", "1107": "", "1108": "                // Convert back to sorted array", "1109": "                allLineNums = Array.from(contextLines).sort((a, b) => a - b);", "1110": "", "1111": "                // Add file headers", "1112": "                subsetHtml += '<div class=\\\"file-section\\\" style=\\\"margin-bottom: 30px;\\\">';", "1113": "                subsetHtml += '<div class=\\\"file-path\\\">\ud83d\udcc4 ' + escapeHtml(file) + '</div>';", "1114": "", "1115": "                supersetHtml += '<div class=\\\"file-section\\\" style=\\\"margin-bottom: 30px;\\\">';", "1116": "                supersetHtml += '<div class=\\\"file-path\\\">\ud83d\udcc4 ' + escapeHtml(file) + '</div>';", "1117": "", "1118": "                // Render each line with gap detection", "1119": "                let prevLineNum = null;", "1120": "                for (let idx = 0; idx < allLineNums.length; idx++) {{", "1121": "                    const lineNum = allLineNums[idx];", "1122": "                    const sourceLine = fileSource[lineNum] || '';", "1123": "                    const trimmed = sourceLine.trim();", "1124": "", "1125": "                    // Skip docstrings", "1126": "                    if (trimmed.startsWith('\\\"\\\"\\\"') || trimmed.startsWith(\"'''\")) {{", "1127": "                        continue;", "1128": "                    }}", "1129": "", "1130": "                    // Handle gap between lines", "1131": "                    if (prevLineNum !== null && lineNum - prevLineNum > 1) {{", "1132": "                        const gap = lineNum - prevLineNum - 1;", "1133": "                        const gapStart = prevLineNum + 1;", "1134": "                        const gapEnd = lineNum - 1;", "1135": "", "1136": "                        if (gap > 3) {{", "1137": "                            // Show collapsible gap for >3 lines", "1138": "                            const gapId = 'gap_' + file.replace(/[^a-zA-Z0-9]/g, '_') + '_' + gapStart + '_' + gapEnd;", "1139": "                            const gapText = '\u22ee (' + gap + ' line' + (gap > 1 ? 's' : '') + ') \u22ee Click to expand';", "1140": "", "1141": "                            subsetHtml += '<div class=\\\"code-line gap-line\\\" style=\\\"color: #00c6ff; text-align: center; font-style: italic; background: #f0f0f0; cursor: pointer; padding: 8px;\\\" ';", "1142": "                            subsetHtml += 'data-gap-id=\\\"' + gapId + '\\\" data-gap-start=\\\"' + gapStart + '\\\" data-gap-end=\\\"' + gapEnd + '\\\" data-file=\\\"' + escapeHtml(file) + '\\\" ';", "1143": "                            subsetHtml += 'onclick=\\\"toggleGap(this, \\\\'subset\\\\')\\\" title=\\\"Click to view hidden lines\\\">';", "1144": "                            subsetHtml += '<strong>' + gapText + '</strong>';", "1145": "                            subsetHtml += '</div>';", "1146": "", "1147": "                            supersetHtml += '<div class=\\\"code-line gap-line\\\" style=\\\"color: #00c6ff; text-align: center; font-style: italic; background: #f0f0f0; cursor: pointer; padding: 8px;\\\" ';", "1148": "                            supersetHtml += 'data-gap-id=\\\"' + gapId + '\\\" data-gap-start=\\\"' + gapStart + '\\\" data-gap-end=\\\"' + gapEnd + '\\\" data-file=\\\"' + escapeHtml(file) + '\\\" ';", "1149": "                            supersetHtml += 'onclick=\\\"toggleGap(this, \\\\'superset\\\\')\\\" title=\\\"Click to view hidden lines\\\">';", "1150": "                            supersetHtml += '<strong>' + gapText + '</strong>';", "1151": "                            supersetHtml += '</div>';", "1152": "                        }} else {{", "1153": "                            // Show lines if gap is 3 or less", "1154": "                            for (let gapLine = gapStart; gapLine <= gapEnd; gapLine++) {{", "1155": "                                const gapSource = fileSource[gapLine] || '';", "1156": "                                const gapLineNumStr = String(gapLine).padStart(4, ' ');", "1157": "", "1158": "                                subsetHtml += '<div class=\\\"code-line\\\" style=\\\"opacity: 0.4; background: #fafafa;\\\">';", "1159": "                                subsetHtml += '<span style=\\\"color: #bbb; margin-right: 10px;\\\">' + gapLineNumStr + '</span>';", "1160": "                                subsetHtml += '<span style=\\\"color: #aaa;\\\">' + escapeHtml(gapSource) + '</span>';", "1161": "                                subsetHtml += '</div>';", "1162": "", "1163": "                                supersetHtml += '<div class=\\\"code-line\\\" style=\\\"opacity: 0.4; background: #fafafa;\\\">';", "1164": "                                supersetHtml += '<span style=\\\"color: #bbb; margin-right: 10px;\\\">' + gapLineNumStr + '</span>';", "1165": "                                supersetHtml += '<span style=\\\"color: #aaa;\\\">' + escapeHtml(gapSource) + '</span>';", "1166": "                                supersetHtml += '</div>';", "1167": "                            }}", "1168": "                        }}", "1169": "                    }}", "1170": "", "1171": "                    prevLineNum = lineNum;", "1172": "                    const lineNumStr = String(lineNum).padStart(4, ' ');", "1173": "                    const isDefLine = trimmed.startsWith('def ') || trimmed.startsWith('class ') || trimmed.startsWith('async def ');", "1174": "", "1175": "                    // Render left side (subset)", "1176": "                    if (subsetLineSet.has(lineNum)) {{", "1177": "                        subsetHtml += '<div class=\\\"code-line covered\\\">';", "1178": "                        subsetHtml += '<span style=\\\"color: #999; margin-right: 10px;\\\">' + lineNumStr + '</span>';", "1179": "                        subsetHtml += escapeHtml(sourceLine) || '\u258c Covered line';", "1180": "                        subsetHtml += '</div>';", "1181": "                    }} else if (isDefLine) {{", "1182": "                        // Show def/class lines as context", "1183": "                        subsetHtml += '<div class=\\\"code-line\\\" style=\\\"background: #e8f4f8; font-weight: 600;\\\">';", "1184": "                        subsetHtml += '<span style=\\\"color: #999; margin-right: 10px;\\\">' + lineNumStr + '</span>';", "1185": "                        subsetHtml += escapeHtml(sourceLine);", "1186": "                        subsetHtml += '</div>';", "1187": "                    }} else {{", "1188": "                        // Show blank line to maintain alignment", "1189": "                        subsetHtml += '<div class=\\\"code-line\\\" style=\\\"opacity: 0.3;\\\">';", "1190": "                        subsetHtml += '<span style=\\\"color: #999; margin-right: 10px;\\\">' + lineNumStr + '</span>';", "1191": "                        subsetHtml += '<span style=\\\"color: #ccc;\\\">\u2014</span>';", "1192": "                        subsetHtml += '</div>';", "1193": "                    }}", "1194": "", "1195": "                    // Render right side (superset)", "1196": "                    if (supersetLineSet.has(lineNum)) {{", "1197": "                        supersetHtml += '<div class=\\\"code-line covered\\\">';", "1198": "                        supersetHtml += '<span style=\\\"color: #999; margin-right: 10px;\\\">' + lineNumStr + '</span>';", "1199": "                        supersetHtml += escapeHtml(sourceLine) || '\u258c Covered line';", "1200": "                        supersetHtml += '</div>';", "1201": "                    }} else if (isDefLine) {{", "1202": "                        // Show def/class lines as context", "1203": "                        supersetHtml += '<div class=\\\"code-line\\\" style=\\\"background: #e8f4f8; font-weight: 600;\\\">';", "1204": "                        supersetHtml += '<span style=\\\"color: #999; margin-right: 10px;\\\">' + lineNumStr + '</span>';", "1205": "                        supersetHtml += escapeHtml(sourceLine);", "1206": "                        supersetHtml += '</div>';", "1207": "                    }} else {{", "1208": "                        // Show blank line to maintain alignment", "1209": "                        supersetHtml += '<div class=\\\"code-line\\\" style=\\\"opacity: 0.3;\\\">';", "1210": "                        supersetHtml += '<span style=\\\"color: #999; margin-right: 10px;\\\">' + lineNumStr + '</span>';", "1211": "                        supersetHtml += '<span style=\\\"color: #ccc;\\\">\u2014</span>';", "1212": "                        supersetHtml += '</div>';", "1213": "                    }}", "1214": "                }}", "1215": "", "1216": "                subsetHtml += '</div>';", "1217": "                supersetHtml += '</div>';", "1218": "            }}", "1219": "", "1220": "            document.getElementById('subsetContent').innerHTML = subsetHtml || '<p style=\\\"padding: 20px; color: #7f8c8d;\\\">No coverage data</p>';", "1221": "            document.getElementById('supersetContent').innerHTML = supersetHtml || '<p style=\\\"padding: 20px; color: #7f8c8d;\\\">No coverage data</p>';", "1222": "        }}", "1223": "", "1224": "        function applyFileFilter() {{", "1225": "            renderBothPanels();", "1226": "        }}", "1227": "", "1228": "        function toggleSync() {{", "1229": "            syncEnabled = !syncEnabled;", "1230": "            const checkbox = document.getElementById('syncCheckbox');", "1231": "            const toggle = document.getElementById('syncToggle');", "1232": "            const splitView = document.querySelector('.split-view');", "1233": "            const filePanels = document.querySelectorAll('.file-panel');", "1234": "", "1235": "            checkbox.checked = syncEnabled;", "1236": "            if (syncEnabled) {{", "1237": "                toggle.classList.add('active');", "1238": "                // Use single scroll - both panels scroll together", "1239": "                splitView.classList.remove('independent');", "1240": "                filePanels.forEach(panel => panel.classList.remove('independent'));", "1241": "            }} else {{", "1242": "                toggle.classList.remove('active');", "1243": "                // Enable independent scrolling for each panel", "1244": "                splitView.classList.add('independent');", "1245": "                filePanels.forEach(panel => panel.classList.add('independent'));", "1246": "            }}", "1247": "        }}", "1248": "", "1249": "        function toggleGap(element, side) {{", "1250": "            const gapId = element.getAttribute('data-gap-id');", "1251": "            const gapStart = parseInt(element.getAttribute('data-gap-start'));", "1252": "            const gapEnd = parseInt(element.getAttribute('data-gap-end'));", "1253": "            const file = element.getAttribute('data-file');", "1254": "", "1255": "            // Find the corresponding gap in the other panel", "1256": "            const otherSide = side === 'subset' ? 'superset' : 'subset';", "1257": "            const otherContent = document.getElementById(otherSide + 'Content');", "1258": "            const otherGap = otherContent.querySelector('.gap-line[data-gap-id=\"' + gapId + '\"]');", "1259": "", "1260": "            // Check if already expanded", "1261": "            const isExpanded = element.classList.contains('expanded');", "1262": "", "1263": "            if (isExpanded) {{", "1264": "                // Collapse both sides", "1265": "                const expandedLines = element.parentElement.querySelectorAll('.expanded-line[data-gap-id=\"' + gapId + '\"]');", "1266": "                expandedLines.forEach(line => line.remove());", "1267": "                element.classList.remove('expanded');", "1268": "                element.innerHTML = '<strong>\u22ee (' + (gapEnd - gapStart + 1) + ' line' + (gapEnd - gapStart > 0 ? 's' : '') + ') \u22ee Click to expand</strong>';", "1269": "", "1270": "                // Collapse other side", "1271": "                if (otherGap) {{", "1272": "                    const otherExpandedLines = otherGap.parentElement.querySelectorAll('.expanded-line[data-gap-id=\"' + gapId + '\"]');", "1273": "                    otherExpandedLines.forEach(line => line.remove());", "1274": "                    otherGap.classList.remove('expanded');", "1275": "                    otherGap.innerHTML = '<strong>\u22ee (' + (gapEnd - gapStart + 1) + ' line' + (gapEnd - gapStart > 0 ? 's' : '') + ') \u22ee Click to expand</strong>';", "1276": "                }}", "1277": "            }} else {{", "1278": "                // Expand both sides", "1279": "                const fileSource = sourceCode[file] || {{}};", "1280": "                element.classList.add('expanded');", "1281": "                element.innerHTML = '<strong>\u22ee Click to collapse \u22ee</strong>';", "1282": "", "1283": "                let insertHtml = '';", "1284": "                for (let lineNum = gapStart; lineNum <= gapEnd; lineNum++) {{", "1285": "                    const sourceLine = fileSource[lineNum] || '';", "1286": "                    const lineNumStr = String(lineNum).padStart(4, ' ');", "1287": "", "1288": "                    insertHtml += '<div class=\"code-line expanded-line\" data-gap-id=\"' + gapId + '\" style=\"opacity: 0.6; background: #f9f9f9; border-left: 3px solid #00c6ff;\">';", "1289": "                    insertHtml += '<span style=\"color: #aaa; margin-right: 10px;\">' + lineNumStr + '</span>';", "1290": "                    insertHtml += '<span style=\"color: #666;\">' + escapeHtml(sourceLine) + '</span>';", "1291": "                    insertHtml += '</div>';", "1292": "                }}", "1293": "", "1294": "                // Insert after the gap element on current side", "1295": "                const tempDiv = document.createElement('div');", "1296": "                tempDiv.innerHTML = insertHtml;", "1297": "                while (tempDiv.firstChild) {{", "1298": "                    element.parentNode.insertBefore(tempDiv.firstChild, element.nextSibling);", "1299": "                }}", "1300": "", "1301": "                // Expand other side", "1302": "                if (otherGap) {{", "1303": "                    otherGap.classList.add('expanded');", "1304": "                    otherGap.innerHTML = '<strong>\u22ee Click to collapse \u22ee</strong>';", "1305": "", "1306": "                    const tempDiv2 = document.createElement('div');", "1307": "                    tempDiv2.innerHTML = insertHtml;", "1308": "                    while (tempDiv2.firstChild) {{", "1309": "                        otherGap.parentNode.insertBefore(tempDiv2.firstChild, otherGap.nextSibling);", "1310": "                    }}", "1311": "                }}", "1312": "            }}", "1313": "        }}", "1314": "", "1315": "        function closeModal() {{", "1316": "            document.getElementById('comparisonModal').style.display = 'none';", "1317": "            currentData = null;", "1318": "        }}", "1319": "", "1320": "        window.onclick = function(event) {{", "1321": "            const modal = document.getElementById('comparisonModal');", "1322": "            if (event.target == modal) {{", "1323": "                closeModal();", "1324": "            }}", "1325": "        }}", "1326": "", "1327": "        document.addEventListener('keydown', function(event) {{", "1328": "            if (event.key === 'Escape') {{", "1329": "                closeModal();", "1330": "            }}", "1331": "        }});", "1332": "", "1333": "        // Format all test names on page load", "1334": "        document.addEventListener('DOMContentLoaded', function() {{", "1335": "            const testNames = document.querySelectorAll('.test-name');", "1336": "            testNames.forEach(el => {{", "1337": "                const originalText = el.textContent;", "1338": "                if (originalText.includes('::')) {{", "1339": "                    el.innerHTML = formatTestName(originalText);", "1340": "                }}", "1341": "            }});", "1342": "        }});", "1343": "        </script>", "1344": "", "1345": "        <div class=\"footer\">", "1346": "            <p>Generated by <strong>TestIQ</strong> - Intelligent Test Analysis</p>", "1347": "            <p>\ud83d\udd17 <a href=\"https://github.com/pydevtools/TestIQ\" style=\"color: #00c6ff;\">github.com/pydevtools/TestIQ</a></p>", "1348": "        </div>", "1349": "    </div>", "1350": "</body>", "1351": "</html>", "1352": "\"\"\"", "1353": "        return html", "1354": "", "1355": "", "1356": "class CSVReportGenerator:", "1357": "    \"\"\"Generate CSV reports for data analysis and spreadsheets.\"\"\"", "1358": "", "1359": "    def __init__(self, finder: CoverageDuplicateFinder) -> None:", "1360": "        \"\"\"Initialize CSV report generator.\"\"\"", "1361": "        self.finder = finder", "1362": "", "1363": "    def generate_exact_duplicates(self, output_path: Path) -> None:", "1364": "        \"\"\"Generate CSV of exact duplicates.\"\"\"", "1365": "        logger.info(f\"Generating exact duplicates CSV: {output_path}\")", "1366": "", "1367": "        exact_dups = self.finder.find_exact_duplicates()", "1368": "", "1369": "        with open(output_path, \"w\", newline=\"\") as f:", "1370": "            writer = csv.writer(f)", "1371": "            writer.writerow([\"Group\", \"Test Name\", \"Action\"])", "1372": "", "1373": "            for i, group in enumerate(exact_dups, 1):", "1374": "                for j, test in enumerate(group):", "1375": "                    action = \"Keep\" if j == 0 else \"Remove\"", "1376": "                    writer.writerow([f\"Group {i}\", test, action])", "1377": "", "1378": "        logger.info(f\"CSV report saved: {output_path}\")", "1379": "", "1380": "    def generate_subset_duplicates(self, output_path: Path) -> None:", "1381": "        \"\"\"Generate CSV of subset duplicates.\"\"\"", "1382": "        logger.info(f\"Generating subset duplicates CSV: {output_path}\")", "1383": "", "1384": "        subsets = self.finder.find_subset_duplicates()", "1385": "", "1386": "        with open(output_path, \"w\", newline=\"\") as f:", "1387": "            writer = csv.writer(f)", "1388": "            writer.writerow([\"Subset Test\", \"Superset Test\", \"Coverage Ratio\", \"Action\"])", "1389": "", "1390": "            for subset_test, superset_test, ratio in subsets:", "1391": "                writer.writerow(", "1392": "                    [", "1393": "                        subset_test,", "1394": "                        superset_test,", "1395": "                        f\"{ratio:.2%}\",", "1396": "                        \"Review for removal\",", "1397": "                    ]", "1398": "                )", "1399": "", "1400": "        logger.info(f\"CSV report saved: {output_path}\")", "1401": "", "1402": "    def generate_similar_tests(self, output_path: Path, threshold: float = 0.7) -> None:", "1403": "        \"\"\"Generate CSV of similar tests.\"\"\"", "1404": "        logger.info(f\"Generating similar tests CSV: {output_path}\")", "1405": "", "1406": "        similar = self.finder.find_similar_coverage(threshold)", "1407": "", "1408": "        with open(output_path, \"w\", newline=\"\") as f:", "1409": "            writer = csv.writer(f)", "1410": "            writer.writerow([\"Test 1\", \"Test 2\", \"Similarity\", \"Action\"])", "1411": "", "1412": "            for test1, test2, similarity in similar:", "1413": "                writer.writerow(", "1414": "                    [test1, test2, f\"{similarity:.2%}\", \"Review for merge\"]", "1415": "                )", "1416": "", "1417": "        logger.info(f\"CSV report saved: {output_path}\")", "1418": "", "1419": "    def generate_summary(self, output_path: Path, threshold: float = 0.7) -> None:", "1420": "        \"\"\"Generate summary CSV with all data.\"\"\"", "1421": "        logger.info(f\"Generating summary CSV: {output_path}\")", "1422": "", "1423": "        exact_dups = self.finder.find_exact_duplicates()", "1424": "        subsets = self.finder.find_subset_duplicates()", "1425": "        similar = self.finder.find_similar_coverage(threshold)", "1426": "", "1427": "        with open(output_path, \"w\", newline=\"\") as f:", "1428": "            writer = csv.writer(f)", "1429": "", "1430": "            # Summary statistics", "1431": "            writer.writerow([\"Metric\", \"Value\"])", "1432": "            writer.writerow([\"Total Tests\", len(self.finder.tests)])", "1433": "            writer.writerow(", "1434": "                [\"Exact Duplicates\", sum(len(g) - 1 for g in exact_dups)]", "1435": "            )", "1436": "            writer.writerow([\"Subset Duplicates\", len(subsets)])", "1437": "            writer.writerow([\"Similar Test Pairs\", len(similar)])", "1438": "            writer.writerow([])", "1439": "", "1440": "            # Exact duplicates section", "1441": "            writer.writerow([\"EXACT DUPLICATES\"])", "1442": "            writer.writerow([\"Group\", \"Test Name\", \"Action\"])", "1443": "            for i, group in enumerate(exact_dups, 1):", "1444": "                for j, test in enumerate(group):", "1445": "                    action = \"Keep\" if j == 0 else \"Remove\"", "1446": "                    writer.writerow([f\"Group {i}\", test, action])", "1447": "            writer.writerow([])", "1448": "", "1449": "            # Subset duplicates section", "1450": "            writer.writerow([\"SUBSET DUPLICATES\"])", "1451": "            writer.writerow([\"Subset Test\", \"Superset Test\", \"Coverage Ratio\"])", "1452": "            for subset_test, superset_test, ratio in subsets[:50]:", "1453": "                writer.writerow([subset_test, superset_test, f\"{ratio:.2%}\"])", "1454": "            writer.writerow([])", "1455": "", "1456": "            # Similar tests section", "1457": "            writer.writerow([\"SIMILAR TESTS\"])", "1458": "            writer.writerow([\"Test 1\", \"Test 2\", \"Similarity\"])", "1459": "            for test1, test2, similarity in similar[:50]:", "1460": "                writer.writerow([test1, test2, f\"{similarity:.2%}\"])", "1461": "", "1462": "        logger.info(f\"CSV report saved: {output_path}\")"}, "src/testiq/analysis.py": {"1": "\"\"\"", "2": "Advanced analysis features for TestIQ.", "3": "Provides test quality scoring and intelligent recommendations.", "4": "\"\"\"", "5": "", "6": "from dataclasses import dataclass", "7": "from typing import Any, Optional", "8": "", "9": "from testiq.analyzer import CoverageDuplicateFinder", "10": "from testiq.logging_config import get_logger", "11": "", "12": "logger = get_logger(__name__)", "13": "", "14": "", "15": "@dataclass", "16": "class TestQualityScore:", "17": "    \"\"\"Quality score for test suite.\"\"\"", "18": "", "19": "    overall_score: float  # 0-100", "20": "    duplication_score: float  # 0-100 (100 = no duplicates)", "21": "    coverage_efficiency_score: float  # 0-100", "22": "    uniqueness_score: float  # 0-100", "23": "    grade: str  # A+, A, B, C, D, F", "24": "    recommendations: list[str]", "25": "", "26": "    def __str__(self) -> str:", "27": "        \"\"\"String representation.\"\"\"", "28": "        return f\"Quality Score: {self.overall_score:.1f}/100 (Grade: {self.grade})\"", "29": "", "30": "", "31": "class QualityAnalyzer:", "32": "    \"\"\"", "33": "    Analyze test suite quality and calculate quality scores.", "34": "", "35": "    Responsibilities:", "36": "    - Calculate quality metrics (duplication, efficiency, uniqueness)", "37": "    - Assign letter grades (A+ to F)", "38": "    - Generate text recommendations", "39": "", "40": "    For structured action items and detailed reports, use RecommendationEngine.", "41": "    \"\"\"", "42": "", "43": "    def __init__(self, finder: CoverageDuplicateFinder) -> None:", "44": "        \"\"\"Initialize quality analyzer.\"\"\"", "45": "        self.finder = finder", "46": "", "47": "    def calculate_score(self, threshold: float = 0.7) -> TestQualityScore:", "48": "        \"\"\"", "49": "        Calculate comprehensive quality score.", "50": "", "51": "        Args:", "52": "            threshold: Similarity threshold for analysis", "53": "", "54": "        Returns:", "55": "            TestQualityScore with detailed metrics", "56": "        \"\"\"", "57": "        logger.info(\"Calculating test quality score\")", "58": "", "59": "        exact_dups = self.finder.find_exact_duplicates()", "60": "        subset_dups = self.finder.find_subset_duplicates()", "61": "        similar = self.finder.find_similar_coverage(threshold)", "62": "", "63": "        total_tests = len(self.finder.tests)", "64": "        if total_tests == 0:", "65": "            return TestQualityScore(", "66": "                overall_score=0,", "67": "                duplication_score=0,", "68": "                coverage_efficiency_score=0,", "69": "                uniqueness_score=0,", "70": "                grade=\"F\",", "71": "                recommendations=[\"No tests found\"],", "72": "            )", "73": "", "74": "        duplicate_count = sum(len(g) - 1 for g in exact_dups)", "75": "", "76": "        # Calculate duplication score (100 = no duplicates)", "77": "        duplicate_percentage = (duplicate_count / total_tests) * 100", "78": "        duplication_score = max(0, 100 - (duplicate_percentage * 2))", "79": "", "80": "        # Calculate coverage efficiency score (penalize subsets)", "81": "        subset_percentage = (len(subset_dups) / total_tests) * 100 if total_tests > 0 else 0", "82": "        coverage_efficiency_score = max(0, 100 - subset_percentage)", "83": "", "84": "        # Calculate uniqueness score (penalize similar tests)", "85": "        similar_percentage = (len(similar) / (total_tests * (total_tests - 1) / 2)) * 100 if total_tests > 1 else 0", "86": "        uniqueness_score = max(0, 100 - (similar_percentage * 0.5))", "87": "", "88": "        # Overall score (weighted average)", "89": "        overall_score = (", "90": "            duplication_score * 0.5", "91": "            + coverage_efficiency_score * 0.3", "92": "            + uniqueness_score * 0.2", "93": "        )", "94": "", "95": "        # Determine grade", "96": "        if overall_score >= 95:", "97": "            grade = \"A+\"", "98": "        elif overall_score >= 90:", "99": "            grade = \"A\"", "100": "        elif overall_score >= 80:", "101": "            grade = \"B\"", "102": "        elif overall_score >= 70:", "103": "            grade = \"C\"", "104": "        elif overall_score >= 60:", "105": "            grade = \"D\"", "106": "        else:", "107": "            grade = \"F\"", "108": "", "109": "        # Generate recommendations", "110": "        recommendations = self._generate_recommendations(", "111": "            duplicate_count, len(subset_dups), len(similar), total_tests", "112": "        )", "113": "", "114": "        score = TestQualityScore(", "115": "            overall_score=overall_score,", "116": "            duplication_score=duplication_score,", "117": "            coverage_efficiency_score=coverage_efficiency_score,", "118": "            uniqueness_score=uniqueness_score,", "119": "            grade=grade,", "120": "            recommendations=recommendations,", "121": "        )", "122": "", "123": "        logger.info(f\"Quality score: {score.overall_score:.1f}/100 (Grade: {grade})\")", "124": "        return score", "125": "", "126": "    def _generate_recommendations(", "127": "        self,", "128": "        duplicate_count: int,", "129": "        subset_count: int,", "130": "        similar_count: int,", "131": "        total_tests: int,", "132": "    ) -> list[str]:", "133": "        \"\"\"Generate actionable recommendations based on analysis.\"\"\"", "134": "        recommendations = []", "135": "", "136": "        # Recommendations for exact duplicates", "137": "        if duplicate_count > 0:", "138": "            percentage = (duplicate_count / total_tests) * 100", "139": "            if percentage > 20:", "140": "                recommendations.append(", "141": "                    f\"\u26a0\ufe0f CRITICAL: Remove {duplicate_count} exact duplicate tests ({percentage:.1f}% of total)\"", "142": "                )", "143": "            elif percentage > 10:", "144": "                recommendations.append(", "145": "                    f\"\u26a0\ufe0f HIGH: Remove {duplicate_count} exact duplicate tests ({percentage:.1f}% of total)\"", "146": "                )", "147": "            else:", "148": "                recommendations.append(", "149": "                    f\"\ud83d\udccb Remove {duplicate_count} exact duplicate tests to improve maintainability\"", "150": "                )", "151": "", "152": "        # Recommendations for subset duplicates", "153": "        if subset_count > 0:", "154": "            percentage = (subset_count / total_tests) * 100", "155": "            if percentage > 15:", "156": "                recommendations.append(", "157": "                    f\"\u26a0\ufe0f Review {subset_count} subset duplicates - many tests may be redundant\"", "158": "                )", "159": "            else:", "160": "                recommendations.append(", "161": "                    f\"\ud83d\udccb Review {subset_count} subset duplicates for potential consolidation\"", "162": "                )", "163": "", "164": "        # Recommendations for similar tests", "165": "        if similar_count > 0:", "166": "            if similar_count > total_tests:", "167": "                recommendations.append(", "168": "                    f\"\u26a0\ufe0f Consider refactoring {similar_count} similar test pairs - high overlap detected\"", "169": "                )", "170": "            elif similar_count > total_tests // 2:", "171": "                recommendations.append(", "172": "                    f\"\ud83d\udccb Review {similar_count} similar test pairs for possible merging\"", "173": "                )", "174": "", "175": "        # Positive feedback", "176": "        if not recommendations:", "177": "            recommendations.append(\"\u2705 Excellent! No significant test duplication detected\")", "178": "            recommendations.append(\"\ud83d\udca1 Continue maintaining this high quality standard\")", "179": "", "180": "        # Best practices", "181": "        if total_tests > 100 and duplicate_count == 0:", "182": "            recommendations.append(\"\ud83c\udf1f Great job maintaining a large test suite without duplicates!\")", "183": "", "184": "        if subset_count > 10:", "185": "            recommendations.append(", "186": "                \"\ud83d\udca1 Consider using test parametrization to reduce subset duplicates\"", "187": "            )", "188": "", "189": "        if similar_count > 20:", "190": "            recommendations.append(", "191": "                \"\ud83d\udca1 Use shared test fixtures and helper functions to reduce code duplication\"", "192": "            )", "193": "", "194": "        return recommendations", "195": "", "196": "", "197": "class RecommendationEngine:", "198": "    \"\"\"", "199": "    Generate intelligent, actionable recommendations for test improvement.", "200": "", "201": "    Responsibilities:", "202": "    - Create priority-based action items (high/medium/low)", "203": "    - Generate structured reports with statistics", "204": "    - Provide specific remediation steps", "205": "", "206": "    Uses QualityAnalyzer internally for score calculation.", "207": "    \"\"\"", "208": "", "209": "    def __init__(self, finder: CoverageDuplicateFinder) -> None:", "210": "        \"\"\"Initialize recommendation engine.\"\"\"", "211": "        self.finder = finder", "212": "        self.quality_analyzer = QualityAnalyzer(finder)", "213": "", "214": "    def generate_report(self, threshold: float = 0.7) -> dict[str, Any]:", "215": "        \"\"\"", "216": "        Generate comprehensive recommendation report.", "217": "", "218": "        Args:", "219": "            threshold: Similarity threshold", "220": "", "221": "        Returns:", "222": "            Dictionary with score, recommendations, and action items", "223": "        \"\"\"", "224": "        logger.info(\"Generating recommendations report\")", "225": "", "226": "        score = self.quality_analyzer.calculate_score(threshold)", "227": "        exact_dups = self.finder.find_exact_duplicates()", "228": "        subset_dups = self.finder.find_subset_duplicates()", "229": "        similar = self.finder.find_similar_coverage(threshold)", "230": "        total_tests = len(self.finder.tests)", "231": "", "232": "        # Priority action items", "233": "        action_items = []", "234": "", "235": "        # High priority: exact duplicates", "236": "        if exact_dups:", "237": "            for i, group in enumerate(exact_dups[:5], 1):", "238": "                action_items.append(", "239": "                    {", "240": "                        \"priority\": \"high\",", "241": "                        \"type\": \"remove_duplicate\",", "242": "                        \"description\": f\"Remove duplicate tests in group {i}\",", "243": "                        \"message\": f\"Remove duplicate tests in group {i}\",", "244": "                        \"tests\": group,", "245": "                        \"impact\": f\"Reduce test count by {len(group) - 1}\",", "246": "                    }", "247": "                )", "248": "", "249": "        # Medium priority: subset duplicates", "250": "        if subset_dups:", "251": "            for subset_test, superset_test, ratio in subset_dups[:5]:", "252": "                action_items.append(", "253": "                    {", "254": "                        \"priority\": \"medium\",", "255": "                        \"type\": \"review_subset\",", "256": "                        \"description\": f\"Review if '{subset_test}' is needed\",", "257": "                        \"message\": f\"Review if '{subset_test}' is needed\",", "258": "                        \"tests\": [subset_test, superset_test],", "259": "                        \"details\": f\"{ratio:.1%} covered by superset\",", "260": "                    }", "261": "                )", "262": "", "263": "        # Low priority: similar tests", "264": "        if similar and len(similar) > total_tests // 2:", "265": "            action_items.append(", "266": "                {", "267": "                    \"priority\": \"low\",", "268": "                    \"type\": \"refactor_similar\",", "269": "                    \"description\": \"Consider refactoring similar test pairs\",", "270": "                    \"message\": \"Consider refactoring similar test pairs\",", "271": "                    \"count\": len(similar),", "272": "                    \"suggestion\": \"Use test parametrization or shared fixtures\",", "273": "                }", "274": "            )", "275": "", "276": "        return {", "277": "            \"quality_score\": {", "278": "                \"overall\": score.overall_score,", "279": "                \"duplication\": score.duplication_score,", "280": "                \"efficiency\": score.coverage_efficiency_score,", "281": "                \"uniqueness\": score.uniqueness_score,", "282": "                \"grade\": score.grade,", "283": "            },", "284": "            \"recommendations\": action_items,  # Priority-based action items", "285": "            \"suggestions\": score.recommendations,  # Text recommendations", "286": "            \"action_items\": action_items,  # Keep for backward compatibility", "287": "            \"statistics\": {", "288": "                \"total_tests\": len(self.finder.tests),", "289": "                \"exact_duplicates\": sum(len(g) - 1 for g in exact_dups),", "290": "                \"subset_duplicates\": len(subset_dups),", "291": "                \"similar_pairs\": len(similar),", "292": "            },", "293": "        }"}, "tests/test_security.py": {"1": "\"\"\"", "2": "Tests for security module.", "3": "\"\"\"", "4": "", "5": "import tempfile", "6": "from pathlib import Path", "7": "", "8": "import pytest", "9": "", "10": "from testiq.exceptions import SecurityError, ValidationError", "11": "from testiq.security import (", "12": "    ALLOWED_EXTENSIONS,", "13": "    DANGEROUS_PATTERNS,", "14": "    MAX_FILE_SIZE,", "15": "    MAX_LINES_PER_FILE,", "16": "    MAX_TESTS,", "17": "    check_file_size,", "18": "    compute_file_hash,", "19": "    sanitize_output_path,", "20": "    validate_coverage_data,", "21": "    validate_file_path,", "22": ")", "23": "", "24": "", "25": "class TestValidateFilePath:", "26": "    \"\"\"Test validate_file_path function.\"\"\"", "27": "", "28": "    def test_valid_json_file(self, tmp_path):", "29": "        \"\"\"Test valid JSON file path.\"\"\"", "30": "        test_file = tmp_path / \"test.json\"", "31": "        test_file.write_text(\"{}\")", "32": "        result = validate_file_path(test_file, check_exists=True)", "33": "        assert result.exists()", "34": "        assert result.suffix == \".json\"", "35": "", "36": "    def test_valid_yaml_file(self, tmp_path):", "37": "        \"\"\"Test valid YAML file path.\"\"\"", "38": "        test_file = tmp_path / \"test.yaml\"", "39": "        test_file.write_text(\"key: value\")", "40": "        result = validate_file_path(test_file, check_exists=True)", "41": "        assert result.exists()", "42": "        assert result.suffix == \".yaml\"", "43": "", "44": "    def test_valid_yml_file(self, tmp_path):", "45": "        \"\"\"Test valid YML file path.\"\"\"", "46": "        test_file = tmp_path / \"test.yml\"", "47": "        test_file.write_text(\"key: value\")", "48": "        result = validate_file_path(test_file, check_exists=True)", "49": "        assert result.exists()", "50": "        assert result.suffix == \".yml\"", "51": "", "52": "    def test_nonexistent_file_with_check(self, tmp_path):", "53": "        \"\"\"Test nonexistent file with check_exists=True.\"\"\"", "54": "        test_file = tmp_path / \"missing.json\"", "55": "        with pytest.raises(ValidationError, match=\"File does not exist\"):", "56": "            validate_file_path(test_file, check_exists=True)", "57": "", "58": "    def test_nonexistent_file_without_check(self, tmp_path):", "59": "        \"\"\"Test nonexistent file with check_exists=False.\"\"\"", "60": "        test_file = tmp_path / \"missing.json\"", "61": "        result = validate_file_path(test_file, check_exists=False)", "62": "        assert result.suffix == \".json\"", "63": "", "64": "    def test_path_traversal_attack(self, tmp_path):", "65": "        \"\"\"Test detection of path traversal patterns.\"\"\"", "66": "        dangerous_file = tmp_path / \"../../../etc/passwd.json\"", "67": "        with pytest.raises(SecurityError, match=\"Dangerous path pattern detected\"):", "68": "            validate_file_path(dangerous_file, check_exists=False)", "69": "", "70": "    def test_invalid_extension(self, tmp_path):", "71": "        \"\"\"Test rejection of invalid file extensions.\"\"\"", "72": "        test_file = tmp_path / \"test.txt\"", "73": "        test_file.write_text(\"content\")", "74": "        with pytest.raises(SecurityError, match=\"File extension not allowed\"):", "75": "            validate_file_path(test_file, check_exists=True)", "76": "", "77": "    def test_dangerous_pattern_windows_backslash(self, tmp_path):", "78": "        \"\"\"Test detection of Windows-style path traversal.\"\"\"", "79": "        # Create a file with backslash in name (Unix allows this)", "80": "        try:", "81": "            dangerous_file = tmp_path / \"..\\\\test.json\"", "82": "            with pytest.raises(SecurityError, match=\"Dangerous path pattern detected\"):", "83": "                validate_file_path(dangerous_file, check_exists=False)", "84": "        except (OSError, ValueError):", "85": "            # Some filesystems don't allow backslashes in filenames", "86": "            pytest.skip(\"Filesystem doesn't support backslashes in filenames\")", "87": "", "88": "    def test_tilde_expansion(self, tmp_path):", "89": "        \"\"\"Test detection of tilde expansion pattern.\"\"\"", "90": "        dangerous_file = Path(\"~/test.json\")", "91": "        with pytest.raises(SecurityError, match=\"Dangerous path pattern detected\"):", "92": "            validate_file_path(dangerous_file, check_exists=False)", "93": "", "94": "", "95": "class TestCheckFileSize:", "96": "    \"\"\"Test check_file_size function.\"\"\"", "97": "", "98": "    def test_file_within_limit(self, tmp_path):", "99": "        \"\"\"Test file within size limit.\"\"\"", "100": "        test_file = tmp_path / \"small.json\"", "101": "        test_file.write_text(\"x\" * 1000)", "102": "        # Should not raise", "103": "        check_file_size(test_file, max_size=10000)", "104": "", "105": "    def test_file_exceeds_limit(self, tmp_path):", "106": "        \"\"\"Test file exceeding size limit.\"\"\"", "107": "        test_file = tmp_path / \"large.json\"", "108": "        test_file.write_bytes(b\"x\" * 10000)", "109": "        with pytest.raises(SecurityError, match=\"File too large\"):", "110": "            check_file_size(test_file, max_size=1000)", "111": "", "112": "    def test_file_at_exact_limit(self, tmp_path):", "113": "        \"\"\"Test file at exact size limit.\"\"\"", "114": "        test_file = tmp_path / \"exact.json\"", "115": "        test_file.write_bytes(b\"x\" * 1000)", "116": "        # Should not raise", "117": "        check_file_size(test_file, max_size=1000)", "118": "", "119": "    def test_default_max_size(self, tmp_path):", "120": "        \"\"\"Test default MAX_FILE_SIZE limit.\"\"\"", "121": "        test_file = tmp_path / \"test.json\"", "122": "        test_file.write_text(\"small\")", "123": "        # Should not raise with default", "124": "        check_file_size(test_file)", "125": "", "126": "    def test_nonexistent_file(self, tmp_path):", "127": "        \"\"\"Test checking size of nonexistent file.\"\"\"", "128": "        test_file = tmp_path / \"missing.json\"", "129": "        with pytest.raises(ValidationError, match=\"Cannot check file size\"):", "130": "            check_file_size(test_file)", "131": "", "132": "", "133": "class TestValidateCoverageData:", "134": "    \"\"\"Test validate_coverage_data function.\"\"\"", "135": "", "136": "    def test_valid_coverage_data(self):", "137": "        \"\"\"Test valid coverage data.\"\"\"", "138": "        data = {", "139": "            \"test_one\": {\"file1.py\": [1, 2, 3], \"file2.py\": [10, 20]},", "140": "            \"test_two\": {\"file1.py\": [4, 5], \"file3.py\": [1, 2]},", "141": "        }", "142": "        # Should not raise", "143": "        validate_coverage_data(data)", "144": "", "145": "    def test_empty_coverage_data(self):", "146": "        \"\"\"Test empty coverage data.\"\"\"", "147": "        with pytest.raises(ValidationError, match=\"Coverage data is empty\"):", "148": "            validate_coverage_data({})", "149": "", "150": "    def test_non_dict_coverage_data(self):", "151": "        \"\"\"Test non-dict coverage data.\"\"\"", "152": "        with pytest.raises(ValidationError, match=\"Coverage data must be a dictionary\"):", "153": "            validate_coverage_data([])", "154": "", "155": "    def test_too_many_tests(self):", "156": "        \"\"\"Test exceeding max tests limit.\"\"\"", "157": "        data = {f\"test_{i}\": {\"file.py\": [1, 2]} for i in range(100)}", "158": "        with pytest.raises(SecurityError, match=\"Too many tests\"):", "159": "            validate_coverage_data(data, max_tests=50)", "160": "", "161": "    def test_non_string_test_name(self):", "162": "        \"\"\"Test non-string test name.\"\"\"", "163": "        data = {123: {\"file.py\": [1, 2]}}", "164": "        with pytest.raises(ValidationError, match=\"Test name must be string\"):", "165": "            validate_coverage_data(data)", "166": "", "167": "    def test_empty_test_name(self):", "168": "        \"\"\"Test empty test name.\"\"\"", "169": "        data = {\"   \": {\"file.py\": [1, 2]}}", "170": "        with pytest.raises(ValidationError, match=\"Test name cannot be empty\"):", "171": "            validate_coverage_data(data)", "172": "", "173": "    def test_non_dict_coverage(self):", "174": "        \"\"\"Test non-dict coverage for a test.\"\"\"", "175": "        data = {\"test_one\": [1, 2, 3]}", "176": "        with pytest.raises(ValidationError, match=\"must be a dictionary\"):", "177": "            validate_coverage_data(data)", "178": "", "179": "    def test_non_string_file_name(self):", "180": "        \"\"\"Test non-string file name.\"\"\"", "181": "        data = {\"test_one\": {123: [1, 2]}}", "182": "        with pytest.raises(ValidationError, match=\"File name must be string\"):", "183": "            validate_coverage_data(data)", "184": "", "185": "    def test_non_list_lines(self):", "186": "        \"\"\"Test non-list lines.\"\"\"", "187": "        data = {\"test_one\": {\"file.py\": \"not a list\"}}", "188": "        with pytest.raises(ValidationError, match=\"must be a list\"):", "189": "            validate_coverage_data(data)", "190": "", "191": "    def test_non_integer_line_number(self):", "192": "        \"\"\"Test non-integer line number.\"\"\"", "193": "        data = {\"test_one\": {\"file.py\": [1, 2, \"3\"]}}", "194": "        with pytest.raises(ValidationError, match=\"Line number must be integer\"):", "195": "            validate_coverage_data(data)", "196": "", "197": "    def test_invalid_line_number(self):", "198": "        \"\"\"Test invalid line number (< 1).\"\"\"", "199": "        data = {\"test_one\": {\"file.py\": [1, 2, 0]}}", "200": "        with pytest.raises(ValidationError, match=\"Invalid line number: 0\"):", "201": "            validate_coverage_data(data)", "202": "", "203": "    def test_negative_line_number(self):", "204": "        \"\"\"Test negative line number.\"\"\"", "205": "        data = {\"test_one\": {\"file.py\": [1, 2, -5]}}", "206": "        with pytest.raises(ValidationError, match=\"Invalid line number: -5\"):", "207": "            validate_coverage_data(data)", "208": "", "209": "    def test_too_many_lines(self):", "210": "        \"\"\"Test exceeding max lines limit.\"\"\"", "211": "        # Create coverage with many lines", "212": "        large_lines = list(range(1, 101000))", "213": "        data = {\"test_one\": {\"file.py\": large_lines}}", "214": "        with pytest.raises(SecurityError, match=\"covers too many lines\"):", "215": "            validate_coverage_data(data)", "216": "", "217": "    def test_valid_at_line_limit(self):", "218": "        \"\"\"Test valid coverage at line limit.\"\"\"", "219": "        lines = list(range(1, MAX_LINES_PER_FILE + 1))", "220": "        data = {\"test_one\": {\"file.py\": lines}}", "221": "        # Should not raise", "222": "        validate_coverage_data(data)", "223": "", "224": "", "225": "class TestSanitizeOutputPath:", "226": "    \"\"\"Test sanitize_output_path function.\"\"\"", "227": "", "228": "    def test_valid_output_path(self, tmp_path):", "229": "        \"\"\"Test valid output path.\"\"\"", "230": "        output_path = tmp_path / \"output.html\"", "231": "        result = sanitize_output_path(output_path)", "232": "        assert result.is_absolute()", "233": "", "234": "    def test_dangerous_pattern_in_path(self, tmp_path):", "235": "        \"\"\"Test detection of dangerous patterns.\"\"\"", "236": "        output_path = tmp_path / \"../../../etc/output.html\"", "237": "        with pytest.raises(SecurityError, match=\"Dangerous path pattern detected\"):", "238": "            sanitize_output_path(output_path)", "239": "", "240": "    def test_allowed_directory(self, tmp_path):", "241": "        \"\"\"Test path within allowed directory.\"\"\"", "242": "        allowed_dir = tmp_path / \"allowed\"", "243": "        allowed_dir.mkdir()", "244": "        output_path = allowed_dir / \"output.html\"", "245": "        result = sanitize_output_path(output_path, allowed_dirs=[allowed_dir])", "246": "        assert result.is_absolute()", "247": "", "248": "    def test_disallowed_directory(self, tmp_path):", "249": "        \"\"\"Test path outside allowed directories.\"\"\"", "250": "        allowed_dir = tmp_path / \"allowed\"", "251": "        allowed_dir.mkdir()", "252": "        disallowed_dir = tmp_path / \"disallowed\"", "253": "        disallowed_dir.mkdir()", "254": "        output_path = disallowed_dir / \"output.html\"", "255": "        with pytest.raises(SecurityError, match=\"not in allowed directories\"):", "256": "            sanitize_output_path(output_path, allowed_dirs=[allowed_dir])", "257": "", "258": "    def test_no_allowed_dirs_restriction(self, tmp_path):", "259": "        \"\"\"Test path when no allowed_dirs restriction is set.\"\"\"", "260": "        output_path = tmp_path / \"anywhere\" / \"output.html\"", "261": "        result = sanitize_output_path(output_path, allowed_dirs=None)", "262": "        assert result.is_absolute()", "263": "", "264": "    def test_multiple_allowed_directories(self, tmp_path):", "265": "        \"\"\"Test path with multiple allowed directories.\"\"\"", "266": "        dir1 = tmp_path / \"dir1\"", "267": "        dir2 = tmp_path / \"dir2\"", "268": "        dir1.mkdir()", "269": "        dir2.mkdir()", "270": "        output_path = dir2 / \"output.html\"", "271": "        result = sanitize_output_path(output_path, allowed_dirs=[dir1, dir2])", "272": "        assert result.is_absolute()", "273": "", "274": "", "275": "class TestComputeFileHash:", "276": "    \"\"\"Test compute_file_hash function.\"\"\"", "277": "", "278": "    def test_hash_small_file(self, tmp_path):", "279": "        \"\"\"Test hash computation for small file.\"\"\"", "280": "        test_file = tmp_path / \"test.txt\"", "281": "        test_file.write_text(\"test content\")", "282": "        hash1 = compute_file_hash(test_file)", "283": "        assert len(hash1) == 64  # SHA-256 produces 64 hex characters", "284": "        assert isinstance(hash1, str)", "285": "", "286": "    def test_hash_consistency(self, tmp_path):", "287": "        \"\"\"Test hash is consistent for same content.\"\"\"", "288": "        test_file = tmp_path / \"test.txt\"", "289": "        test_file.write_text(\"test content\")", "290": "        hash1 = compute_file_hash(test_file)", "291": "        hash2 = compute_file_hash(test_file)", "292": "        assert hash1 == hash2", "293": "", "294": "    def test_hash_different_content(self, tmp_path):", "295": "        \"\"\"Test different content produces different hash.\"\"\"", "296": "        file1 = tmp_path / \"file1.txt\"", "297": "        file2 = tmp_path / \"file2.txt\"", "298": "        file1.write_text(\"content1\")", "299": "        file2.write_text(\"content2\")", "300": "        hash1 = compute_file_hash(file1)", "301": "        hash2 = compute_file_hash(file2)", "302": "        assert hash1 != hash2", "303": "", "304": "    def test_hash_large_file(self, tmp_path):", "305": "        \"\"\"Test hash computation for large file (> 4KB chunks).\"\"\"", "306": "        test_file = tmp_path / \"large.txt\"", "307": "        test_file.write_bytes(b\"x\" * 10000)", "308": "        hash_result = compute_file_hash(test_file)", "309": "        assert len(hash_result) == 64", "310": "", "311": "    def test_hash_empty_file(self, tmp_path):", "312": "        \"\"\"Test hash computation for empty file.\"\"\"", "313": "        test_file = tmp_path / \"empty.txt\"", "314": "        test_file.write_text(\"\")", "315": "        hash_result = compute_file_hash(test_file)", "316": "        assert len(hash_result) == 64", "317": "        # Empty file should have a specific known hash", "318": "        assert hash_result == \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"", "319": "", "320": "", "321": "class TestConstants:", "322": "    \"\"\"Test security constants.\"\"\"", "323": "", "324": "    def test_max_file_size(self):", "325": "        \"\"\"Test MAX_FILE_SIZE constant.\"\"\"", "326": "        assert MAX_FILE_SIZE == 100 * 1024 * 1024", "327": "        assert MAX_FILE_SIZE == 104857600  # 100MB", "328": "", "329": "    def test_max_tests(self):", "330": "        \"\"\"Test MAX_TESTS constant.\"\"\"", "331": "        assert MAX_TESTS == 50000", "332": "", "333": "    def test_max_lines_per_file(self):", "334": "        \"\"\"Test MAX_LINES_PER_FILE constant.\"\"\"", "335": "        assert MAX_LINES_PER_FILE == 100000", "336": "", "337": "    def test_allowed_extensions(self):", "338": "        \"\"\"Test ALLOWED_EXTENSIONS constant.\"\"\"", "339": "        assert \".json\" in ALLOWED_EXTENSIONS", "340": "        assert \".yaml\" in ALLOWED_EXTENSIONS", "341": "        assert \".yml\" in ALLOWED_EXTENSIONS", "342": "        assert len(ALLOWED_EXTENSIONS) == 3", "343": "", "344": "    def test_dangerous_patterns(self):", "345": "        \"\"\"Test DANGEROUS_PATTERNS constant.\"\"\"", "346": "        assert \"../\" in DANGEROUS_PATTERNS", "347": "        assert \"..\\\\\" in DANGEROUS_PATTERNS", "348": "        assert \"~\" in DANGEROUS_PATTERNS"}, "src/testiq/cicd.py": {"1": "\"\"\"", "2": "CI/CD integration features for TestIQ.", "3": "Provides quality gates, baseline comparison, and trend tracking.", "4": "\"\"\"", "5": "", "6": "import json", "7": "from dataclasses import dataclass, field", "8": "from datetime import datetime", "9": "from pathlib import Path", "10": "from typing import Any, Optional", "11": "", "12": "from testiq.analyzer import CoverageDuplicateFinder", "13": "from testiq.exceptions import ValidationError", "14": "from testiq.logging_config import get_logger", "15": "", "16": "logger = get_logger(__name__)", "17": "", "18": "", "19": "@dataclass", "20": "class QualityGate:", "21": "    \"\"\"Define quality gate thresholds for CI/CD.\"\"\"", "22": "", "23": "    max_duplicates: Optional[int] = None", "24": "    max_duplicate_percentage: Optional[float] = None", "25": "    max_subset_duplicates: Optional[int] = None", "26": "    max_similar_pairs: Optional[int] = None", "27": "    fail_on_increase: bool = True", "28": "", "29": "    def __post_init__(self) -> None:", "30": "        \"\"\"Validate quality gate configuration.\"\"\"", "31": "        if self.max_duplicate_percentage is not None:", "32": "            if not 0.0 <= self.max_duplicate_percentage <= 100.0:", "33": "                raise ValidationError(", "34": "                    f\"max_duplicate_percentage must be 0-100, got {self.max_duplicate_percentage}\"", "35": "                )", "36": "", "37": "", "38": "@dataclass", "39": "class AnalysisResult:", "40": "    \"\"\"Results from TestIQ analysis.\"\"\"", "41": "", "42": "    timestamp: str", "43": "    total_tests: int", "44": "    exact_duplicates: int", "45": "    duplicate_groups: int", "46": "    subset_duplicates: int", "47": "    similar_pairs: int", "48": "    duplicate_percentage: float", "49": "    threshold: float", "50": "    metadata: dict[str, Any] = field(default_factory=dict)", "51": "", "52": "    def to_dict(self) -> dict[str, Any]:", "53": "        \"\"\"Convert to dictionary.\"\"\"", "54": "        return {", "55": "            \"timestamp\": self.timestamp,", "56": "            \"total_tests\": self.total_tests,", "57": "            \"exact_duplicates\": self.exact_duplicates,", "58": "            \"duplicate_groups\": self.duplicate_groups,", "59": "            \"subset_duplicates\": self.subset_duplicates,", "60": "            \"similar_pairs\": self.similar_pairs,", "61": "            \"duplicate_percentage\": self.duplicate_percentage,", "62": "            \"threshold\": self.threshold,", "63": "            \"metadata\": self.metadata,", "64": "        }", "65": "", "66": "    @classmethod", "67": "    def from_dict(cls, data: dict[str, Any]) -> \"AnalysisResult\":", "68": "        \"\"\"Create from dictionary.\"\"\"", "69": "        return cls(", "70": "            timestamp=data[\"timestamp\"],", "71": "            total_tests=data[\"total_tests\"],", "72": "            exact_duplicates=data[\"exact_duplicates\"],", "73": "            duplicate_groups=data[\"duplicate_groups\"],", "74": "            subset_duplicates=data[\"subset_duplicates\"],", "75": "            similar_pairs=data[\"similar_pairs\"],", "76": "            duplicate_percentage=data[\"duplicate_percentage\"],", "77": "            threshold=data[\"threshold\"],", "78": "            metadata=data.get(\"metadata\", {}),", "79": "        )", "80": "", "81": "", "82": "class QualityGateChecker:", "83": "    \"\"\"Check if analysis results pass quality gates.\"\"\"", "84": "", "85": "    def __init__(self, gate: QualityGate) -> None:", "86": "        \"\"\"Initialize quality gate checker.\"\"\"", "87": "        self.gate = gate", "88": "        logger.info(f\"Initialized quality gate: {gate}\")", "89": "", "90": "    def check(", "91": "        self,", "92": "        finder: CoverageDuplicateFinder,", "93": "        threshold: float = 0.7,", "94": "        baseline: Optional[AnalysisResult] = None,", "95": "    ) -> tuple[bool, dict[str, Any]]:", "96": "        \"\"\"", "97": "        Check if analysis passes quality gates.", "98": "", "99": "        Args:", "100": "            finder: CoverageDuplicateFinder instance", "101": "            threshold: Similarity threshold", "102": "            baseline: Optional baseline results for comparison", "103": "", "104": "        Returns:", "105": "            (passed, details) tuple where passed is bool and details contains information", "106": "        \"\"\"", "107": "        logger.info(\"Checking quality gates\")", "108": "", "109": "        exact_dups = finder.find_exact_duplicates()", "110": "        subset_dups = finder.find_subset_duplicates()", "111": "        similar = finder.find_similar_coverage(threshold)", "112": "", "113": "        total_tests = len(finder.tests)", "114": "        duplicate_count = sum(len(g) - 1 for g in exact_dups)", "115": "        duplicate_percentage = (", "116": "            (duplicate_count / total_tests * 100) if total_tests > 0 else 0", "117": "        )", "118": "", "119": "        current = AnalysisResult(", "120": "            timestamp=datetime.now().isoformat(),", "121": "            total_tests=total_tests,", "122": "            exact_duplicates=duplicate_count,", "123": "            duplicate_groups=len(exact_dups),", "124": "            subset_duplicates=len(subset_dups),", "125": "            similar_pairs=len(similar),", "126": "            duplicate_percentage=duplicate_percentage,", "127": "            threshold=threshold,", "128": "        )", "129": "", "130": "        failures = []", "131": "        passed = True", "132": "", "133": "        # Check absolute thresholds", "134": "        if (", "135": "            self.gate.max_duplicates is not None", "136": "            and duplicate_count > self.gate.max_duplicates", "137": "        ):", "138": "            failures.append(", "139": "                f\"Exact duplicates ({duplicate_count}) exceeds limit ({self.gate.max_duplicates})\"", "140": "            )", "141": "            passed = False", "142": "", "143": "        if (", "144": "            self.gate.max_duplicate_percentage is not None", "145": "            and duplicate_percentage > self.gate.max_duplicate_percentage", "146": "        ):", "147": "            failures.append(", "148": "                f\"Duplicate percentage ({duplicate_percentage:.1f}%) exceeds limit ({self.gate.max_duplicate_percentage:.1f}%)\"", "149": "            )", "150": "            passed = False", "151": "", "152": "        if (", "153": "            self.gate.max_subset_duplicates is not None", "154": "            and len(subset_dups) > self.gate.max_subset_duplicates", "155": "        ):", "156": "            failures.append(", "157": "                f\"Subset duplicates ({len(subset_dups)}) exceeds limit ({self.gate.max_subset_duplicates})\"", "158": "            )", "159": "            passed = False", "160": "", "161": "        if (", "162": "            self.gate.max_similar_pairs is not None", "163": "            and len(similar) > self.gate.max_similar_pairs", "164": "        ):", "165": "            failures.append(", "166": "                f\"Similar pairs ({len(similar)}) exceeds limit ({self.gate.max_similar_pairs})\"", "167": "            )", "168": "            passed = False", "169": "", "170": "        # Check against baseline", "171": "        if baseline and self.gate.fail_on_increase:", "172": "            if current.exact_duplicates > baseline.exact_duplicates:", "173": "                failures.append(", "174": "                    f\"Exact duplicates increased from {baseline.exact_duplicates} to {current.exact_duplicates}\"", "175": "                )", "176": "                passed = False", "177": "", "178": "            if current.subset_duplicates > baseline.subset_duplicates:", "179": "                failures.append(", "180": "                    f\"Subset duplicates increased from {baseline.subset_duplicates} to {current.subset_duplicates}\"", "181": "                )", "182": "                passed = False", "183": "", "184": "        details = {", "185": "            \"passed\": passed,", "186": "            \"current\": current.to_dict(),", "187": "            \"baseline\": baseline.to_dict() if baseline else None,", "188": "            \"failures\": failures,", "189": "            \"gate_config\": {", "190": "                \"max_duplicates\": self.gate.max_duplicates,", "191": "                \"max_duplicate_percentage\": self.gate.max_duplicate_percentage,", "192": "                \"max_subset_duplicates\": self.gate.max_subset_duplicates,", "193": "                \"max_similar_pairs\": self.gate.max_similar_pairs,", "194": "                \"fail_on_increase\": self.gate.fail_on_increase,", "195": "            },", "196": "        }", "197": "", "198": "        if passed:", "199": "            logger.info(\"\u2713 Quality gates passed\")", "200": "        else:", "201": "            logger.warning(f\"\u2717 Quality gates failed: {failures}\")", "202": "", "203": "        return passed, details", "204": "", "205": "", "206": "class BaselineManager:", "207": "    \"\"\"Manage baseline results for comparison.\"\"\"", "208": "", "209": "    def __init__(self, baseline_dir: Path) -> None:", "210": "        \"\"\"Initialize baseline manager.\"\"\"", "211": "        self.baseline_dir = baseline_dir", "212": "        self.baseline_dir.mkdir(parents=True, exist_ok=True)", "213": "        logger.debug(f\"Baseline directory: {baseline_dir}\")", "214": "", "215": "    def save(self, result: AnalysisResult, name: str = \"baseline\") -> Path:", "216": "        \"\"\"Save analysis result as baseline.\"\"\"", "217": "        baseline_file = self.baseline_dir / f\"{name}.json\"", "218": "", "219": "        with open(baseline_file, \"w\") as f:", "220": "            json.dump(result.to_dict(), f, indent=2)", "221": "", "222": "        logger.info(f\"Baseline saved: {baseline_file}\")", "223": "        return baseline_file", "224": "", "225": "    def load(self, name: str = \"baseline\") -> Optional[AnalysisResult]:", "226": "        \"\"\"Load baseline result.\"\"\"", "227": "        baseline_file = self.baseline_dir / f\"{name}.json\"", "228": "", "229": "        if not baseline_file.exists():", "230": "            logger.warning(f\"Baseline not found: {baseline_file}\")", "231": "            return None", "232": "", "233": "        with open(baseline_file) as f:", "234": "            data = json.load(f)", "235": "", "236": "        logger.info(f\"Baseline loaded: {baseline_file}\")", "237": "        return AnalysisResult.from_dict(data)", "238": "", "239": "    def list_baselines(self) -> list[dict[str, Any]]:", "240": "        \"\"\"List available baselines with their details.\"\"\"", "241": "        baselines = []", "242": "        for baseline_file in self.baseline_dir.glob(\"*.json\"):", "243": "            try:", "244": "                result = self.load(baseline_file.stem)", "245": "                if result:", "246": "                    baselines.append({", "247": "                        \"name\": baseline_file.stem,", "248": "                        \"result\": result,", "249": "                    })", "250": "            except Exception as e:", "251": "                logger.warning(f\"Failed to load baseline {baseline_file.stem}: {e}\")", "252": "", "253": "        logger.debug(f\"Available baselines: {[b['name'] for b in baselines]}\")", "254": "        return baselines", "255": "", "256": "", "257": "class TrendTracker:", "258": "    \"\"\"Track test duplicate trends over time.\"\"\"", "259": "", "260": "    def __init__(self, history_file: Path) -> None:", "261": "        \"\"\"Initialize trend tracker.\"\"\"", "262": "        self.history_file = history_file", "263": "        self.history_file.parent.mkdir(parents=True, exist_ok=True)", "264": "", "265": "    def add_result(self, result: AnalysisResult) -> None:", "266": "        \"\"\"Add analysis result to history.\"\"\"", "267": "        history = self.load_history()", "268": "        history.append(result.to_dict())", "269": "", "270": "        with open(self.history_file, \"w\") as f:", "271": "            json.dump(history, f, indent=2)", "272": "", "273": "        logger.info(f\"Result added to trend history: {self.history_file}\")", "274": "", "275": "    def load_history(self) -> list[dict[str, Any]]:", "276": "        \"\"\"Load historical results.\"\"\"", "277": "        if not self.history_file.exists():", "278": "            return []", "279": "", "280": "        with open(self.history_file) as f:", "281": "            return json.load(f)", "282": "", "283": "    def get_trend(self, metric: str, limit: int = 10) -> list[float]:", "284": "        \"\"\"", "285": "        Get trend for specific metric.", "286": "", "287": "        Args:", "288": "            metric: Metric name (e.g., 'exact_duplicates', 'duplicate_percentage')", "289": "            limit: Number of recent results to return", "290": "", "291": "        Returns:", "292": "            List of metric values over time", "293": "        \"\"\"", "294": "        history = self.load_history()", "295": "        recent = history[-limit:] if len(history) > limit else history", "296": "        return [r.get(metric, 0) for r in recent]", "297": "", "298": "    def is_improving(self, metric: str = \"exact_duplicates\") -> bool:", "299": "        \"\"\"Check if trend is improving (decreasing for duplicates).\"\"\"", "300": "        trend = self.get_trend(metric, limit=5)", "301": "        if len(trend) < 2:", "302": "            return True  # Not enough data", "303": "", "304": "        # Check if generally decreasing", "305": "        improvements = sum(", "306": "            1 for i in range(1, len(trend)) if trend[i] <= trend[i - 1]", "307": "        )", "308": "        return improvements >= len(trend) // 2", "309": "", "310": "", "311": "def get_exit_code(", "312": "    passed: bool, duplicate_count: int, total_tests: int", "313": ") -> int:", "314": "    \"\"\"", "315": "    Get appropriate exit code for CI/CD.", "316": "", "317": "    Args:", "318": "        passed: Whether quality gates passed", "319": "        duplicate_count: Number of duplicates found", "320": "        total_tests: Total number of tests", "321": "", "322": "    Returns:", "323": "        Exit code (0=success, 1=duplicates found, 2=quality gate failed)", "324": "    \"\"\"", "325": "    if not passed:", "326": "        return 2  # Quality gate failed", "327": "", "328": "    if duplicate_count > 0:", "329": "        return 1  # Duplicates found but within limits", "330": "", "331": "    return 0  # All good"}, "tests/test_reporting.py": {"1": "\"\"\"", "2": "Tests for reporting module (HTML and CSV generators).", "3": "\"\"\"", "4": "", "5": "import json", "6": "import tempfile", "7": "from pathlib import Path", "8": "", "9": "import pytest", "10": "", "11": "from testiq.analyzer import CoverageDuplicateFinder", "12": "from testiq.reporting import CSVReportGenerator, HTMLReportGenerator", "13": "", "14": "", "15": "@pytest.fixture", "16": "def sample_finder():", "17": "    \"\"\"Create a finder with sample test data.\"\"\"", "18": "    finder = CoverageDuplicateFinder()", "19": "", "20": "    # Exact duplicates", "21": "    finder.add_test_coverage(\"test_login_1\", {\"auth.py\": [1, 2, 3], \"user.py\": [10, 11]})", "22": "    finder.add_test_coverage(\"test_login_2\", {\"auth.py\": [1, 2, 3], \"user.py\": [10, 11]})", "23": "", "24": "    # Subset duplicates", "25": "    finder.add_test_coverage(\"test_short\", {\"utils.py\": [5, 6]})", "26": "    finder.add_test_coverage(\"test_long\", {\"utils.py\": [5, 6, 7, 8, 9]})", "27": "", "28": "    # Similar tests", "29": "    finder.add_test_coverage(\"test_similar_1\", {\"main.py\": [1, 2, 3, 4, 5]})", "30": "    finder.add_test_coverage(\"test_similar_2\", {\"main.py\": [1, 2, 3, 4, 10]})", "31": "", "32": "    # Unique test", "33": "    finder.add_test_coverage(\"test_unique\", {\"other.py\": [100, 101, 102]})", "34": "", "35": "    return finder", "36": "", "37": "", "38": "class TestHTMLReportGenerator:", "39": "    \"\"\"Tests for HTMLReportGenerator.\"\"\"", "40": "", "41": "    def test_generate_html_report(self, sample_finder):", "42": "        \"\"\"Test generating HTML report.\"\"\"", "43": "        generator = HTMLReportGenerator(sample_finder)", "44": "", "45": "        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".html\", delete=False) as f:", "46": "            output_path = Path(f.name)", "47": "", "48": "        try:", "49": "            generator.generate(output_path, threshold=0.8)", "50": "", "51": "            # Verify file exists and has content", "52": "            assert output_path.exists()", "53": "            content = output_path.read_text()", "54": "", "55": "            # Check for key HTML elements", "56": "            assert \"<!DOCTYPE html>\" in content", "57": "            assert \"<html\" in content", "58": "            assert \"TestIQ Analysis Report\" in content", "59": "            assert \"</html>\" in content", "60": "", "61": "            # Check for CSS styling", "62": "            assert \"<style>\" in content", "63": "            assert \"background:\" in content", "64": "            assert \"gradient\" in content.lower()", "65": "", "66": "            # Check for data sections", "67": "            assert \"Exact Duplicates\" in content", "68": "            assert \"Subset Duplicates\" in content", "69": "            assert \"Similar Tests\" in content", "70": "", "71": "            # Check for test names", "72": "            assert \"test_login_1\" in content", "73": "            assert \"test_login_2\" in content", "74": "", "75": "        finally:", "76": "            if output_path.exists():", "77": "                output_path.unlink()", "78": "", "79": "    def test_html_report_empty_finder(self):", "80": "        \"\"\"Test HTML report generation with no tests.\"\"\"", "81": "        finder = CoverageDuplicateFinder()", "82": "        generator = HTMLReportGenerator(finder)", "83": "", "84": "        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".html\", delete=False) as f:", "85": "            output_path = Path(f.name)", "86": "", "87": "        try:", "88": "            generator.generate(output_path)", "89": "", "90": "            assert output_path.exists()", "91": "            content = output_path.read_text()", "92": "            # Check that it shows 0 tests in stats", "93": "            assert \"<div class=\\\"stat-value\\\">0</div>\" in content", "94": "            assert \"No exact duplicates found\" in content", "95": "", "96": "        finally:", "97": "            if output_path.exists():", "98": "                output_path.unlink()", "99": "", "100": "    def test_html_report_stats_cards(self, sample_finder):", "101": "        \"\"\"Test that HTML report includes statistics cards.\"\"\"", "102": "        generator = HTMLReportGenerator(sample_finder)", "103": "", "104": "        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".html\", delete=False) as f:", "105": "            output_path = Path(f.name)", "106": "", "107": "        try:", "108": "            generator.generate(output_path)", "109": "            content = output_path.read_text()", "110": "", "111": "            # Check for stats cards structure (uses .stats class)", "112": "            assert \"class=\\\"stats\\\"\" in content", "113": "            assert \"class=\\\"stat-card\" in content", "114": "", "115": "        finally:", "116": "            if output_path.exists():", "117": "                output_path.unlink()", "118": "", "119": "", "120": "class TestCSVReportGenerator:", "121": "    \"\"\"Tests for CSVReportGenerator.\"\"\"", "122": "", "123": "    def test_generate_exact_duplicates_csv(self, sample_finder):", "124": "        \"\"\"Test generating CSV for exact duplicates.\"\"\"", "125": "        generator = CSVReportGenerator(sample_finder)", "126": "", "127": "        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".csv\", delete=False) as f:", "128": "            output_path = Path(f.name)", "129": "", "130": "        try:", "131": "            generator.generate_exact_duplicates(output_path)", "132": "", "133": "            assert output_path.exists()", "134": "            content = output_path.read_text()", "135": "", "136": "            # Check CSV headers", "137": "            assert \"Group\" in content", "138": "            assert \"Test Name\" in content", "139": "", "140": "            # Check data", "141": "            assert \"test_login_1\" in content", "142": "            assert \"test_login_2\" in content", "143": "", "144": "        finally:", "145": "            if output_path.exists():", "146": "                output_path.unlink()", "147": "", "148": "    def test_generate_subset_duplicates_csv(self, sample_finder):", "149": "        \"\"\"Test generating CSV for subset duplicates.\"\"\"", "150": "        generator = CSVReportGenerator(sample_finder)", "151": "", "152": "        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".csv\", delete=False) as f:", "153": "            output_path = Path(f.name)", "154": "", "155": "        try:", "156": "            generator.generate_subset_duplicates(output_path)", "157": "", "158": "            assert output_path.exists()", "159": "            content = output_path.read_text()", "160": "", "161": "            # Check CSV headers", "162": "            assert \"Subset Test\" in content", "163": "            assert \"Superset Test\" in content", "164": "            assert \"Coverage Ratio\" in content", "165": "", "166": "            # Check data", "167": "            assert \"test_short\" in content", "168": "            assert \"test_long\" in content", "169": "", "170": "        finally:", "171": "            if output_path.exists():", "172": "                output_path.unlink()", "173": "", "174": "    def test_generate_similar_tests_csv(self, sample_finder):", "175": "        \"\"\"Test generating CSV for similar tests.\"\"\"", "176": "        generator = CSVReportGenerator(sample_finder)", "177": "", "178": "        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".csv\", delete=False) as f:", "179": "            output_path = Path(f.name)", "180": "", "181": "        try:", "182": "            generator.generate_similar_tests(output_path, threshold=0.5)", "183": "", "184": "            assert output_path.exists()", "185": "            content = output_path.read_text()", "186": "", "187": "            # Check CSV headers", "188": "            assert \"Test 1\" in content", "189": "            assert \"Test 2\" in content", "190": "            assert \"Similarity\" in content", "191": "", "192": "        finally:", "193": "            if output_path.exists():", "194": "                output_path.unlink()", "195": "", "196": "    def test_generate_summary_csv(self, sample_finder):", "197": "        \"\"\"Test generating summary CSV.\"\"\"", "198": "        generator = CSVReportGenerator(sample_finder)", "199": "", "200": "        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".csv\", delete=False) as f:", "201": "            output_path = Path(f.name)", "202": "", "203": "        try:", "204": "            generator.generate_summary(output_path, threshold=0.8)", "205": "", "206": "            assert output_path.exists()", "207": "            content = output_path.read_text()", "208": "", "209": "            # Check for summary sections", "210": "            assert \"Total Tests\" in content", "211": "            assert \"Exact Duplicates\" in content", "212": "            assert \"Subset Duplicates\" in content", "213": "", "214": "        finally:", "215": "            if output_path.exists():", "216": "                output_path.unlink()", "217": "", "218": "    def test_csv_report_empty_finder(self):", "219": "        \"\"\"Test CSV report generation with no tests.\"\"\"", "220": "        finder = CoverageDuplicateFinder()", "221": "        generator = CSVReportGenerator(finder)", "222": "", "223": "        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".csv\", delete=False) as f:", "224": "            output_path = Path(f.name)", "225": "", "226": "        try:", "227": "            generator.generate_summary(output_path)", "228": "", "229": "            assert output_path.exists()", "230": "            content = output_path.read_text()", "231": "            assert \"0\" in content  # Should show 0 tests", "232": "", "233": "        finally:", "234": "            if output_path.exists():", "235": "                output_path.unlink()", "236": "", "237": "    def test_csv_valid_format(self, sample_finder):", "238": "        \"\"\"Test that CSV output is valid and parseable.\"\"\"", "239": "        import csv", "240": "", "241": "        generator = CSVReportGenerator(sample_finder)", "242": "", "243": "        with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".csv\", delete=False) as f:", "244": "            output_path = Path(f.name)", "245": "", "246": "        try:", "247": "            generator.generate_exact_duplicates(output_path)", "248": "", "249": "            # Try to parse the CSV", "250": "            with open(output_path, newline=\"\") as csvfile:", "251": "                reader = csv.DictReader(csvfile)", "252": "                rows = list(reader)", "253": "", "254": "                # Should have at least one row", "255": "                assert len(rows) > 0", "256": "", "257": "                # Check that expected columns exist", "258": "                assert \"Group\" in rows[0]", "259": "                assert \"Test Name\" in rows[0]", "260": "", "261": "        finally:", "262": "            if output_path.exists():", "263": "                output_path.unlink()"}, "src/testiq/analyzer.py": {"1": "\"\"\"", "2": "Coverage-based test duplicate detector.", "3": "Analyzes test coverage to find redundant tests.", "4": "\"\"\"", "5": "", "6": "import time", "7": "from collections import defaultdict", "8": "from dataclasses import dataclass", "9": "from typing import Optional", "10": "", "11": "from testiq.exceptions import AnalysisError, ValidationError", "12": "from testiq.logging_config import get_logger", "13": "from testiq.performance import (", "14": "    CacheManager,", "15": "    ParallelProcessor,", "16": "    ProgressTracker,", "17": "    compute_similarity,", "18": ")", "19": "", "20": "logger = get_logger(__name__)", "21": "", "22": "", "23": "@dataclass", "24": "class TestCoverage:", "25": "    \"\"\"Represents coverage data for a single test.\"\"\"", "26": "", "27": "    test_name: str", "28": "    covered_lines: set[tuple[str, int]]  # (filename, line_number)", "29": "", "30": "    def __hash__(self) -> int:", "31": "        return hash(self.test_name)", "32": "", "33": "", "34": "class CoverageDuplicateFinder:", "35": "    \"\"\"Finds duplicate tests based on coverage analysis.\"\"\"", "36": "", "37": "    def __init__(", "38": "        self,", "39": "        enable_parallel: bool = True,", "40": "        max_workers: int = 4,", "41": "        enable_caching: bool = True,", "42": "        cache_dir: Optional[str] = None,", "43": "    ) -> None:", "44": "        \"\"\"", "45": "        Initialize the duplicate finder.", "46": "", "47": "        Args:", "48": "            enable_parallel: Enable parallel processing", "49": "            max_workers: Maximum number of parallel workers", "50": "            enable_caching: Enable result caching", "51": "            cache_dir: Directory for cache files", "52": "        \"\"\"", "53": "        self.tests: list[TestCoverage] = []", "54": "        self.parallel_processor = ParallelProcessor(", "55": "            max_workers=max_workers, enabled=enable_parallel", "56": "        )", "57": "        self.cache_manager = CacheManager(cache_dir=cache_dir, enabled=enable_caching)", "58": "        logger.info(", "59": "            f\"Initialized CoverageDuplicateFinder (parallel={enable_parallel}, \"", "60": "            f\"caching={enable_caching})\"", "61": "        )", "62": "", "63": "    def add_test_coverage(self, test_name: str, coverage: dict[str, list[int]]) -> None:", "64": "        \"\"\"", "65": "        Add coverage data for a test.", "66": "", "67": "        Args:", "68": "            test_name: Name of the test", "69": "            coverage: Dict mapping filename -> list of covered line numbers", "70": "", "71": "        Raises:", "72": "            ValidationError: If test_name is empty or coverage is invalid", "73": "        \"\"\"", "74": "        if not test_name or not test_name.strip():", "75": "            raise ValidationError(\"Test name cannot be empty\")", "76": "", "77": "        if not isinstance(coverage, dict):", "78": "            raise ValidationError(f\"Coverage must be a dict, got {type(coverage)}\")", "79": "", "80": "        try:", "81": "            covered_lines = set()", "82": "            for filename, lines in coverage.items():", "83": "                if not isinstance(lines, list):", "84": "                    raise ValidationError(", "85": "                        f\"Coverage lines for '{filename}' must be a list, got {type(lines)}\"", "86": "                    )", "87": "                for line in lines:", "88": "                    if not isinstance(line, int) or line < 1:", "89": "                        raise ValidationError(f\"Invalid line number for '{filename}': {line}\")", "90": "                    covered_lines.add((filename, line))", "91": "", "92": "            self.tests.append(TestCoverage(test_name, covered_lines))", "93": "            logger.debug(f\"Added test '{test_name}' with {len(covered_lines)} covered lines\")", "94": "", "95": "        except Exception as e:", "96": "            logger.error(f\"Error adding test coverage for '{test_name}': {e}\")", "97": "            raise", "98": "", "99": "    def find_exact_duplicates(self) -> list[list[str]]:", "100": "        \"\"\"", "101": "        Find tests with identical coverage.", "102": "", "103": "        Returns:", "104": "            List of test groups where each group has identical coverage", "105": "", "106": "        Raises:", "107": "            AnalysisError: If analysis fails", "108": "        \"\"\"", "109": "        if not self.tests:", "110": "            logger.warning(\"No tests to analyze\")", "111": "            return []", "112": "", "113": "        logger.info(f\"Finding exact duplicates among {len(self.tests)} tests\")", "114": "        start_time = time.time()", "115": "", "116": "        try:", "117": "            coverage_map: dict[frozenset, list[str]] = defaultdict(list)", "118": "", "119": "            for test in self.tests:", "120": "                coverage_key = frozenset(test.covered_lines)", "121": "                coverage_map[coverage_key].append(test.test_name)", "122": "", "123": "            # Only return groups with more than one test (duplicates)", "124": "            duplicates = [tests for tests in coverage_map.values() if len(tests) > 1]", "125": "", "126": "            elapsed = time.time() - start_time", "127": "            logger.info(f\"Found {len(duplicates)} duplicate groups in {elapsed:.2f}s\")", "128": "            return duplicates", "129": "", "130": "        except Exception as e:", "131": "            logger.error(f\"Error finding exact duplicates: {e}\")", "132": "            raise AnalysisError(f\"Failed to find exact duplicates: {e}\")", "133": "", "134": "    def find_subset_duplicates(self) -> list[tuple[str, str, float]]:", "135": "        \"\"\"", "136": "        Find tests where one is a subset of another.", "137": "", "138": "        Returns:", "139": "            List of (subset_test, superset_test, coverage_ratio) tuples", "140": "", "141": "        Raises:", "142": "            AnalysisError: If analysis fails", "143": "        \"\"\"", "144": "        if not self.tests:", "145": "            logger.warning(\"No tests to analyze\")", "146": "            return []", "147": "", "148": "        logger.info(f\"Finding subset duplicates among {len(self.tests)} tests\")", "149": "        start_time = time.time()", "150": "", "151": "        try:", "152": "            subsets = []", "153": "            progress = ProgressTracker(len(self.tests), \"Subset analysis\")", "154": "", "155": "            for i, test1 in enumerate(self.tests):", "156": "                for test2 in self.tests[i + 1 :]:", "157": "                    if test1.covered_lines == test2.covered_lines:", "158": "                        continue  # Skip exact duplicates (handled separately)", "159": "", "160": "                    if test1.covered_lines.issubset(test2.covered_lines):", "161": "                        ratio = len(test1.covered_lines) / len(test2.covered_lines)", "162": "                        subsets.append((test1.test_name, test2.test_name, ratio))", "163": "                    elif test2.covered_lines.issubset(test1.covered_lines):", "164": "                        ratio = len(test2.covered_lines) / len(test1.covered_lines)", "165": "                        subsets.append((test2.test_name, test1.test_name, ratio))", "166": "", "167": "                if i % 10 == 0:", "168": "                    progress.update(10)", "169": "", "170": "            elapsed = time.time() - start_time", "171": "            logger.info(f\"Found {len(subsets)} subset duplicates in {elapsed:.2f}s\")", "172": "            return subsets", "173": "", "174": "        except Exception as e:", "175": "            logger.error(f\"Error finding subset duplicates: {e}\")", "176": "            raise AnalysisError(f\"Failed to find subset duplicates: {e}\")", "177": "", "178": "    def find_similar_coverage(self, threshold: float = 0.8) -> list[tuple[str, str, float]]:", "179": "        \"\"\"", "180": "        Find tests with similar (but not identical) coverage using Jaccard similarity.", "181": "", "182": "        Args:", "183": "            threshold: Minimum similarity ratio (0.0 to 1.0)", "184": "", "185": "        Returns:", "186": "            List of (test1, test2, similarity) tuples", "187": "", "188": "        Raises:", "189": "            ValidationError: If threshold is invalid", "190": "            AnalysisError: If analysis fails", "191": "        \"\"\"", "192": "        if not 0.0 <= threshold <= 1.0:", "193": "            raise ValidationError(f\"Threshold must be between 0.0 and 1.0, got {threshold}\")", "194": "", "195": "        if not self.tests:", "196": "            logger.warning(\"No tests to analyze\")", "197": "            return []", "198": "", "199": "        logger.info(f\"Finding similar tests (threshold={threshold}) among {len(self.tests)} tests\")", "200": "        start_time = time.time()", "201": "", "202": "        try:", "203": "            similar = []", "204": "            progress = ProgressTracker(len(self.tests), \"Similarity analysis\")", "205": "", "206": "            for i, test1 in enumerate(self.tests):", "207": "                for test2 in self.tests[i + 1 :]:", "208": "                    # Use cached similarity computation", "209": "                    similarity = compute_similarity(", "210": "                        frozenset(test1.covered_lines), frozenset(test2.covered_lines)", "211": "                    )", "212": "", "213": "                    if threshold <= similarity < 1.0:", "214": "                        similar.append((test1.test_name, test2.test_name, similarity))", "215": "", "216": "                if i % 10 == 0:", "217": "                    progress.update(10)", "218": "", "219": "            result = sorted(similar, key=lambda x: x[2], reverse=True)", "220": "            elapsed = time.time() - start_time", "221": "            logger.info(f\"Found {len(result)} similar test pairs in {elapsed:.2f}s\")", "222": "            return result", "223": "", "224": "        except Exception as e:", "225": "            logger.error(f\"Error finding similar coverage: {e}\")", "226": "            raise AnalysisError(f\"Failed to find similar coverage: {e}\")", "227": "", "228": "    def generate_report(self) -> str:", "229": "        \"\"\"Generate a comprehensive duplicate report.\"\"\"", "230": "        report_lines = [\"# Test Duplication Report\\n\"]", "231": "", "232": "        # Exact duplicates", "233": "        exact_dups = self.find_exact_duplicates()", "234": "        report_lines.append(\"## Exact Duplicates (Identical Coverage)\\n\")", "235": "        report_lines.append(f\"Found {len(exact_dups)} groups of tests with identical coverage:\\n\")", "236": "", "237": "        for i, group in enumerate(exact_dups, 1):", "238": "            report_lines.append(f\"\\n### Group {i} ({len(group)} tests):\")", "239": "            for test in group:", "240": "                report_lines.append(f\"  - {test}\")", "241": "            report_lines.append(", "242": "                f\"\\n  **Action**: Keep one test, remove {len(group) - 1} duplicates\\n\"", "243": "            )", "244": "", "245": "        # Subset duplicates", "246": "        subsets = self.find_subset_duplicates()", "247": "        report_lines.append(\"\\n## Subset Duplicates\\n\")", "248": "        report_lines.append(f\"Found {len(subsets)} tests that are subsets of others:\\n\")", "249": "", "250": "        for subset_test, superset_test, ratio in subsets[:10]:  # Top 10", "251": "            report_lines.append(", "252": "                f\"\\n  - `{subset_test}` is {ratio:.1%} covered by `{superset_test}`\"", "253": "            )", "254": "            report_lines.append(\"    **Action**: Consider removing if no unique edge cases\\n\")", "255": "", "256": "        # Similar coverage", "257": "        similar = self.find_similar_coverage(threshold=0.7)", "258": "        report_lines.append(\"\\n## Similar Coverage (70%+ overlap)\\n\")", "259": "        report_lines.append(f\"Found {len(similar)} test pairs with significant overlap:\\n\")", "260": "", "261": "        for test1, test2, similarity in similar[:10]:  # Top 10", "262": "            report_lines.append(f\"\\n  - `{test1}` \u2194 `{test2}`: {similarity:.1%} similar\")", "263": "            report_lines.append(\"    **Action**: Review for potential merge or refactoring\\n\")", "264": "", "265": "        # Summary statistics", "266": "        report_lines.append(\"\\n## Summary\\n\")", "267": "        report_lines.append(f\"- Total tests analyzed: {len(self.tests)}\")", "268": "        report_lines.append(", "269": "            f\"- Exact duplicates: {sum(len(g) - 1 for g in exact_dups)} tests can be removed\"", "270": "        )", "271": "        report_lines.append(f\"- Subset duplicates: {len(subsets)} tests may be redundant\")", "272": "        report_lines.append(f\"- Similar tests: {len(similar)} pairs need review\")", "273": "", "274": "        return \"\\n\".join(report_lines)"}, "src/testiq/plugins.py": {"1": "\"\"\"", "2": "Plugin and hook system for TestIQ.", "3": "Allows users to extend functionality with custom callbacks.", "4": "\"\"\"", "5": "", "6": "from dataclasses import dataclass", "7": "from enum import Enum", "8": "from typing import Any, Callable, Optional", "9": "", "10": "from testiq.logging_config import get_logger", "11": "", "12": "logger = get_logger(__name__)", "13": "", "14": "", "15": "class HookType(Enum):", "16": "    \"\"\"Types of hooks available in TestIQ.\"\"\"", "17": "", "18": "    BEFORE_ANALYSIS = \"before_analysis\"", "19": "    AFTER_ANALYSIS = \"after_analysis\"", "20": "    ON_DUPLICATE_FOUND = \"on_duplicate_found\"", "21": "    ON_SUBSET_FOUND = \"on_subset_found\"", "22": "    ON_SIMILAR_FOUND = \"on_similar_found\"", "23": "    ON_ERROR = \"on_error\"", "24": "    ON_QUALITY_GATE_FAIL = \"on_quality_gate_fail\"", "25": "", "26": "", "27": "@dataclass", "28": "class HookContext:", "29": "    \"\"\"Context passed to hook callbacks.\"\"\"", "30": "", "31": "    hook_type: HookType", "32": "    data: dict[str, Any]", "33": "    metadata: dict[str, Any]", "34": "", "35": "", "36": "class PluginManager:", "37": "    \"\"\"Manage plugins and hooks for TestIQ.\"\"\"", "38": "", "39": "    def __init__(self) -> None:", "40": "        \"\"\"Initialize plugin manager.\"\"\"", "41": "        self._hooks: dict[HookType, list[Callable]] = {hook: [] for hook in HookType}", "42": "        logger.debug(\"Plugin manager initialized\")", "43": "", "44": "    def register_hook(", "45": "        self, hook_type: HookType, callback: Callable[[HookContext], None]", "46": "    ) -> None:", "47": "        \"\"\"", "48": "        Register a hook callback.", "49": "", "50": "        Args:", "51": "            hook_type: Type of hook to register", "52": "            callback: Callback function that receives HookContext", "53": "", "54": "        Example:", "55": "            >>> def on_duplicate(ctx: HookContext):", "56": "            ...     print(f\"Found duplicates: {ctx.data['group']}\")", "57": "            >>> plugin_manager.register_hook(HookType.ON_DUPLICATE_FOUND, on_duplicate)", "58": "        \"\"\"", "59": "        self._hooks[hook_type].append(callback)", "60": "        logger.info(f\"Registered hook: {hook_type.value} -> {callback.__name__}\")", "61": "", "62": "    def unregister_hook(", "63": "        self, hook_type: HookType, callback: Callable[[HookContext], None]", "64": "    ) -> bool:", "65": "        \"\"\"", "66": "        Unregister a hook callback.", "67": "", "68": "        Args:", "69": "            hook_type: Type of hook", "70": "            callback: Callback to remove", "71": "", "72": "        Returns:", "73": "            True if callback was found and removed", "74": "        \"\"\"", "75": "        if callback in self._hooks[hook_type]:", "76": "            self._hooks[hook_type].remove(callback)", "77": "            logger.info(f\"Unregistered hook: {hook_type.value} -> {callback.__name__}\")", "78": "            return True", "79": "        return False", "80": "", "81": "    def trigger(", "82": "        self, hook_type: HookType, data: dict[str, Any], metadata: Optional[dict[str, Any]] = None", "83": "    ) -> None:", "84": "        \"\"\"", "85": "        Trigger all callbacks for a hook type.", "86": "", "87": "        Args:", "88": "            hook_type: Type of hook to trigger", "89": "            data: Data to pass to callbacks", "90": "            metadata: Optional metadata", "91": "        \"\"\"", "92": "        if not self._hooks[hook_type]:", "93": "            return", "94": "", "95": "        context = HookContext(", "96": "            hook_type=hook_type, data=data, metadata=metadata or {}", "97": "        )", "98": "", "99": "        logger.debug(f\"Triggering hook: {hook_type.value} ({len(self._hooks[hook_type])} callbacks)\")", "100": "", "101": "        for callback in self._hooks[hook_type]:", "102": "            try:", "103": "                callback(context)", "104": "            except Exception as e:", "105": "                logger.error(", "106": "                    f\"Error in hook callback {callback.__name__}: {e}\",", "107": "                    exc_info=True,", "108": "                )", "109": "", "110": "    def get_hooks(self, hook_type: HookType) -> list[Callable]:", "111": "        \"\"\"Get all registered hooks for a type.\"\"\"", "112": "        return self._hooks[hook_type].copy()", "113": "", "114": "    def clear_hooks(self, hook_type: Optional[HookType] = None) -> None:", "115": "        \"\"\"", "116": "        Clear hooks.", "117": "", "118": "        Args:", "119": "            hook_type: Specific hook type to clear, or None to clear all", "120": "        \"\"\"", "121": "        if hook_type:", "122": "            self._hooks[hook_type].clear()", "123": "            logger.info(f\"Cleared hooks: {hook_type.value}\")", "124": "        else:", "125": "            for hook in HookType:", "126": "                self._hooks[hook].clear()", "127": "            logger.info(\"Cleared all hooks\")", "128": "", "129": "    @property", "130": "    def hooks(self) -> dict[HookType, list[Callable]]:", "131": "        \"\"\"Get all hooks.\"\"\"", "132": "        return self._hooks", "133": "", "134": "", "135": "# Global plugin manager instance (singleton pattern with lazy initialization)", "136": "_plugin_manager: Optional[PluginManager] = None", "137": "", "138": "", "139": "def get_plugin_manager() -> PluginManager:", "140": "    \"\"\"Get the global plugin manager instance.\"\"\"", "141": "    global _plugin_manager", "142": "    if _plugin_manager is None:", "143": "        _plugin_manager = PluginManager()", "144": "    return _plugin_manager", "145": "", "146": "", "147": "# Convenience functions", "148": "def register_hook(hook_type: HookType, callback: Callable[[HookContext], None]) -> None:", "149": "    \"\"\"Register a hook callback (convenience function).\"\"\"", "150": "    get_plugin_manager().register_hook(hook_type, callback)", "151": "", "152": "", "153": "def unregister_hook(hook_type: HookType, callback: Callable[[HookContext], None]) -> bool:", "154": "    \"\"\"Unregister a hook callback (convenience function).\"\"\"", "155": "    return get_plugin_manager().unregister_hook(hook_type, callback)", "156": "", "157": "", "158": "def trigger_hook(", "159": "    hook_type: HookType, data: Optional[dict[str, Any]] = None, metadata: Optional[dict[str, Any]] = None, **kwargs", "160": ") -> None:", "161": "    \"\"\"Trigger hook callbacks (convenience function).\"\"\"", "162": "    # If kwargs provided, use them as data", "163": "    if kwargs and data is None:", "164": "        data = kwargs", "165": "    elif data is None:", "166": "        data = {}", "167": "    get_plugin_manager().trigger(hook_type, data, metadata)", "168": "", "169": "", "170": "def clear_hooks(hook_type: Optional[HookType] = None) -> None:", "171": "    \"\"\"Clear hooks (convenience function).\"\"\"", "172": "    get_plugin_manager().clear_hooks(hook_type)", "173": "", "174": "", "175": "# Alias for backward compatibility", "176": "def get_global_manager() -> PluginManager:", "177": "    \"\"\"Get the global plugin manager instance (alias for get_plugin_manager).\"\"\"", "178": "    return get_plugin_manager()"}, "src/testiq/security.py": {"1": "\"\"\"", "2": "Security utilities for TestIQ.", "3": "Provides input validation, sanitization, and security checks.", "4": "\"\"\"", "5": "", "6": "import hashlib", "7": "from pathlib import Path", "8": "from typing import Any", "9": "", "10": "from testiq.exceptions import SecurityError, ValidationError", "11": "", "12": "# Default security constants (can be overridden by config)", "13": "# These match the defaults in config.SecurityConfig", "14": "MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB", "15": "MAX_TESTS = 50000", "16": "MAX_LINES_PER_FILE = 100000", "17": "ALLOWED_EXTENSIONS = {\".json\", \".yaml\", \".yml\"}", "18": "", "19": "# Dangerous path patterns for security validation", "20": "DANGEROUS_PATTERNS = {\"../\", \"..\\\\\", \"~\"}", "21": "", "22": "", "23": "def validate_file_path(file_path: Path, check_exists: bool = True) -> Path:", "24": "    \"\"\"", "25": "    Validate and sanitize file path.", "26": "", "27": "    Args:", "28": "        file_path: Path to validate", "29": "        check_exists: Whether to check if file exists", "30": "", "31": "    Returns:", "32": "        Resolved absolute path", "33": "", "34": "    Raises:", "35": "        SecurityError: If path is dangerous", "36": "        ValidationError: If path is invalid", "37": "    \"\"\"", "38": "    try:", "39": "        # Resolve to absolute path", "40": "        resolved = file_path.resolve()", "41": "", "42": "        # Check for path traversal attempts", "43": "        path_str = str(file_path)", "44": "        for pattern in DANGEROUS_PATTERNS:", "45": "            if pattern in path_str:", "46": "                raise SecurityError(f\"Dangerous path pattern detected: {pattern}\")", "47": "", "48": "        # Check if path escapes intended directory", "49": "        # (This is a basic check, adjust based on your security requirements)", "50": "        if check_exists and not resolved.exists():", "51": "            raise ValidationError(f\"File does not exist: {file_path}\")", "52": "", "53": "        # Check file extension", "54": "        if resolved.suffix.lower() not in ALLOWED_EXTENSIONS:", "55": "            raise SecurityError(", "56": "                f\"File extension not allowed: {resolved.suffix}. \"", "57": "                f\"Allowed: {', '.join(ALLOWED_EXTENSIONS)}\"", "58": "            )", "59": "", "60": "        return resolved", "61": "", "62": "    except (OSError, RuntimeError) as e:", "63": "        raise ValidationError(f\"Invalid file path: {file_path} - {e}\")", "64": "", "65": "", "66": "def check_file_size(file_path: Path, max_size: int = MAX_FILE_SIZE) -> None:", "67": "    \"\"\"", "68": "    Check if file size is within limits.", "69": "", "70": "    Args:", "71": "        file_path: Path to check", "72": "        max_size: Maximum allowed size in bytes", "73": "", "74": "    Raises:", "75": "        SecurityError: If file is too large", "76": "    \"\"\"", "77": "    try:", "78": "        file_size = file_path.stat().st_size", "79": "        if file_size > max_size:", "80": "            size_mb = file_size / (1024 * 1024)", "81": "            max_mb = max_size / (1024 * 1024)", "82": "            raise SecurityError(f\"File too large: {size_mb:.2f}MB exceeds limit of {max_mb:.2f}MB\")", "83": "    except OSError as e:", "84": "        raise ValidationError(f\"Cannot check file size: {e}\")", "85": "", "86": "", "87": "def validate_coverage_data(data: dict[str, Any], max_tests: int = MAX_TESTS) -> None:", "88": "    \"\"\"", "89": "    Validate coverage data structure and limits.", "90": "", "91": "    Args:", "92": "        data: Coverage data dictionary", "93": "        max_tests: Maximum number of tests allowed", "94": "", "95": "    Raises:", "96": "        ValidationError: If data is invalid", "97": "        SecurityError: If limits are exceeded", "98": "    \"\"\"", "99": "    if not isinstance(data, dict):", "100": "        raise ValidationError(\"Coverage data must be a dictionary\")", "101": "", "102": "    if len(data) == 0:", "103": "        raise ValidationError(\"Coverage data is empty\")", "104": "", "105": "    if len(data) > max_tests:", "106": "        raise SecurityError(f\"Too many tests: {len(data)} exceeds limit of {max_tests}\")", "107": "", "108": "    # Validate structure", "109": "    for test_name, coverage in data.items():", "110": "        if not isinstance(test_name, str):", "111": "            raise ValidationError(f\"Test name must be string, got: {type(test_name)}\")", "112": "", "113": "        if not test_name.strip():", "114": "            raise ValidationError(\"Test name cannot be empty\")", "115": "", "116": "        if not isinstance(coverage, dict):", "117": "            raise ValidationError(", "118": "                f\"Coverage for '{test_name}' must be a dictionary, got: {type(coverage)}\"", "119": "            )", "120": "", "121": "        # Validate each file's coverage", "122": "        total_lines = 0", "123": "        for file_name, lines in coverage.items():", "124": "            if not isinstance(file_name, str):", "125": "                raise ValidationError(f\"File name must be string, got: {type(file_name)}\")", "126": "", "127": "            if not isinstance(lines, list):", "128": "                raise ValidationError(", "129": "                    f\"Coverage lines for '{file_name}' must be a list, got: {type(lines)}\"", "130": "                )", "131": "", "132": "            total_lines += len(lines)", "133": "", "134": "            # Validate line numbers", "135": "            for line_num in lines:", "136": "                if not isinstance(line_num, int):", "137": "                    raise ValidationError(f\"Line number must be integer, got: {type(line_num)}\")", "138": "                if line_num < 1:", "139": "                    raise ValidationError(f\"Invalid line number: {line_num} (must be >= 1)\")", "140": "", "141": "        # Check total lines limit", "142": "        if total_lines > MAX_LINES_PER_FILE:", "143": "            raise SecurityError(", "144": "                f\"Test '{test_name}' covers too many lines: {total_lines} \"", "145": "                f\"exceeds limit of {MAX_LINES_PER_FILE}\"", "146": "            )", "147": "", "148": "", "149": "def sanitize_output_path(output_path: Path, allowed_dirs: list[Path] = None) -> Path:", "150": "    \"\"\"", "151": "    Sanitize output file path.", "152": "", "153": "    Args:", "154": "        output_path: Path to sanitize", "155": "        allowed_dirs: List of allowed directories (if None, any directory is allowed)", "156": "", "157": "    Returns:", "158": "        Sanitized absolute path", "159": "", "160": "    Raises:", "161": "        SecurityError: If path is not allowed", "162": "    \"\"\"", "163": "    try:", "164": "        resolved = output_path.resolve()", "165": "", "166": "        # Check for dangerous patterns", "167": "        path_str = str(output_path)", "168": "        for pattern in DANGEROUS_PATTERNS:", "169": "            if pattern in path_str:", "170": "                raise SecurityError(f\"Dangerous path pattern detected: {pattern}\")", "171": "", "172": "        # Check allowed directories", "173": "        if allowed_dirs:", "174": "            allowed = False", "175": "            for allowed_dir in allowed_dirs:", "176": "                try:", "177": "                    resolved.relative_to(allowed_dir.resolve())", "178": "                    allowed = True", "179": "                    break", "180": "                except ValueError:", "181": "                    continue", "182": "", "183": "            if not allowed:", "184": "                raise SecurityError(f\"Output path not in allowed directories: {output_path}\")", "185": "", "186": "        return resolved", "187": "", "188": "    except (OSError, RuntimeError) as e:", "189": "        raise ValidationError(f\"Invalid output path: {output_path} - {e}\")", "190": "", "191": "", "192": "def compute_file_hash(file_path: Path) -> str:", "193": "    \"\"\"", "194": "    Compute SHA-256 hash of file for integrity verification.", "195": "", "196": "    This function is primarily used for file integrity checks and cache validation.", "197": "    Can be used to verify that coverage files haven't been tampered with.", "198": "", "199": "    Args:", "200": "        file_path: Path to file", "201": "", "202": "    Returns:", "203": "        Hexadecimal hash string", "204": "    \"\"\"", "205": "    sha256_hash = hashlib.sha256()", "206": "    with open(file_path, \"rb\") as f:", "207": "        for byte_block in iter(lambda: f.read(4096), b\"\"):", "208": "            sha256_hash.update(byte_block)", "209": "    return sha256_hash.hexdigest()"}, "tests/test_plugins.py": {"1": "\"\"\"", "2": "Tests for plugin/hook system.", "3": "\"\"\"", "4": "", "5": "import pytest", "6": "", "7": "from testiq.plugins import (", "8": "    HookContext,", "9": "    HookType,", "10": "    PluginManager,", "11": "    clear_hooks,", "12": "    get_global_manager,", "13": "    register_hook,", "14": "    trigger_hook,", "15": "    unregister_hook,", "16": ")", "17": "", "18": "", "19": "@pytest.fixture(autouse=True)", "20": "def reset_global_manager():", "21": "    \"\"\"Reset global plugin manager before each test.\"\"\"", "22": "    manager = get_global_manager()", "23": "    manager.clear_hooks()", "24": "    yield", "25": "    manager.clear_hooks()", "26": "", "27": "", "28": "class TestHookType:", "29": "    \"\"\"Tests for HookType enum.\"\"\"", "30": "", "31": "    def test_all_hook_types_exist(self):", "32": "        \"\"\"Test that all expected hook types are defined.\"\"\"", "33": "        expected_hooks = [", "34": "            \"BEFORE_ANALYSIS\",", "35": "            \"AFTER_ANALYSIS\",", "36": "            \"ON_DUPLICATE_FOUND\",", "37": "            \"ON_SUBSET_FOUND\",", "38": "            \"ON_SIMILAR_FOUND\",", "39": "            \"ON_ERROR\",", "40": "            \"ON_QUALITY_GATE_FAIL\",", "41": "        ]", "42": "", "43": "        for hook in expected_hooks:", "44": "            assert hasattr(HookType, hook)", "45": "", "46": "    def test_hook_type_values(self):", "47": "        \"\"\"Test that hook types have string values.\"\"\"", "48": "        assert isinstance(HookType.BEFORE_ANALYSIS.value, str)", "49": "        assert HookType.BEFORE_ANALYSIS.value == \"before_analysis\"", "50": "", "51": "", "52": "class TestPluginManager:", "53": "    \"\"\"Tests for PluginManager.\"\"\"", "54": "", "55": "    def test_register_hook(self):", "56": "        \"\"\"Test registering a hook.\"\"\"", "57": "        manager = PluginManager()", "58": "        called = []", "59": "", "60": "        def my_hook(ctx: HookContext):", "61": "            called.append(ctx.data)", "62": "", "63": "        manager.register_hook(HookType.BEFORE_ANALYSIS, my_hook)", "64": "", "65": "        # Verify hook is registered", "66": "        assert HookType.BEFORE_ANALYSIS in manager.hooks", "67": "        assert len(manager.hooks[HookType.BEFORE_ANALYSIS]) == 1", "68": "", "69": "    def test_register_multiple_hooks(self):", "70": "        \"\"\"Test registering multiple hooks for same event.\"\"\"", "71": "        manager = PluginManager()", "72": "", "73": "        def hook1(ctx: HookContext):", "74": "            pass", "75": "", "76": "        def hook2(ctx: HookContext):", "77": "            pass", "78": "", "79": "        manager.register_hook(HookType.BEFORE_ANALYSIS, hook1)", "80": "        manager.register_hook(HookType.BEFORE_ANALYSIS, hook2)", "81": "", "82": "        assert len(manager.hooks[HookType.BEFORE_ANALYSIS]) == 2", "83": "", "84": "    def test_trigger_hook(self):", "85": "        \"\"\"Test triggering a hook.\"\"\"", "86": "        manager = PluginManager()", "87": "        results = []", "88": "", "89": "        def my_hook(ctx: HookContext):", "90": "            results.append(ctx.data)", "91": "", "92": "        manager.register_hook(HookType.AFTER_ANALYSIS, my_hook)", "93": "        manager.trigger(HookType.AFTER_ANALYSIS, {\"test\": \"data\", \"count\": 42})", "94": "", "95": "        assert len(results) == 1", "96": "        assert results[0][\"test\"] == \"data\"", "97": "        assert results[0][\"count\"] == 42", "98": "", "99": "    def test_trigger_multiple_hooks(self):", "100": "        \"\"\"Test triggering multiple hooks in order.\"\"\"", "101": "        manager = PluginManager()", "102": "        results = []", "103": "", "104": "        def hook1(ctx: HookContext):", "105": "            results.append(\"hook1\")", "106": "", "107": "        def hook2(ctx: HookContext):", "108": "            results.append(\"hook2\")", "109": "", "110": "        manager.register_hook(HookType.ON_ERROR, hook1)", "111": "        manager.register_hook(HookType.ON_ERROR, hook2)", "112": "        manager.trigger(HookType.ON_ERROR, {})", "113": "", "114": "        assert results == [\"hook1\", \"hook2\"]", "115": "", "116": "    def test_trigger_nonexistent_hook(self):", "117": "        \"\"\"Test triggering a hook with no registered callbacks.\"\"\"", "118": "        manager = PluginManager()", "119": "", "120": "        # Should not raise an error", "121": "        manager.trigger(HookType.BEFORE_ANALYSIS, {})", "122": "", "123": "    def test_unregister_hook(self):", "124": "        \"\"\"Test unregistering a hook.\"\"\"", "125": "        manager = PluginManager()", "126": "", "127": "        def my_hook(ctx: HookContext):", "128": "            pass", "129": "", "130": "        manager.register_hook(HookType.AFTER_ANALYSIS, my_hook)", "131": "        assert len(manager.hooks[HookType.AFTER_ANALYSIS]) == 1", "132": "", "133": "        manager.unregister_hook(HookType.AFTER_ANALYSIS, my_hook)", "134": "        assert len(manager.hooks.get(HookType.AFTER_ANALYSIS, [])) == 0", "135": "", "136": "    def test_unregister_nonexistent_hook(self):", "137": "        \"\"\"Test unregistering a hook that wasn't registered.\"\"\"", "138": "        manager = PluginManager()", "139": "", "140": "        def my_hook(ctx: HookContext):", "141": "            pass", "142": "", "143": "        # Should not raise an error", "144": "        manager.unregister_hook(HookType.BEFORE_ANALYSIS, my_hook)", "145": "", "146": "    def test_clear_hooks(self):", "147": "        \"\"\"Test clearing all hooks.\"\"\"", "148": "        manager = PluginManager()", "149": "", "150": "        def hook1(ctx: HookContext):", "151": "            pass", "152": "", "153": "        def hook2(ctx: HookContext):", "154": "            pass", "155": "", "156": "        manager.register_hook(HookType.BEFORE_ANALYSIS, hook1)", "157": "        manager.register_hook(HookType.AFTER_ANALYSIS, hook2)", "158": "", "159": "        manager.clear_hooks()", "160": "        # All hooks should be empty lists", "161": "        for hooks_list in manager.hooks.values():", "162": "            assert len(hooks_list) == 0", "163": "", "164": "    def test_hook_error_handling(self):", "165": "        \"\"\"Test that hook errors don't break the system.\"\"\"", "166": "        manager = PluginManager()", "167": "        results = []", "168": "", "169": "        def failing_hook(ctx: HookContext):", "170": "            raise ValueError(\"Hook error!\")", "171": "", "172": "        def working_hook(ctx: HookContext):", "173": "            results.append(\"worked\")", "174": "", "175": "        manager.register_hook(HookType.ON_ERROR, failing_hook)", "176": "        manager.register_hook(HookType.ON_ERROR, working_hook)", "177": "", "178": "        # Should not raise, and working_hook should still execute", "179": "        manager.trigger(HookType.ON_ERROR, {})", "180": "", "181": "        # Working hook should have been called despite first hook failing", "182": "        assert \"worked\" in results", "183": "", "184": "", "185": "class TestGlobalFunctions:", "186": "    \"\"\"Tests for global convenience functions.\"\"\"", "187": "", "188": "    def test_register_global_hook(self):", "189": "        \"\"\"Test registering a hook globally.\"\"\"", "190": "        called = []", "191": "", "192": "        def my_hook(ctx: HookContext):", "193": "            called.append(True)", "194": "", "195": "        register_hook(HookType.BEFORE_ANALYSIS, my_hook)", "196": "        trigger_hook(HookType.BEFORE_ANALYSIS)", "197": "", "198": "        assert len(called) == 1", "199": "", "200": "    def test_unregister_global_hook(self):", "201": "        \"\"\"Test unregistering a global hook.\"\"\"", "202": "        called = []", "203": "", "204": "        def my_hook(ctx: HookContext):", "205": "            called.append(True)", "206": "", "207": "        register_hook(HookType.AFTER_ANALYSIS, my_hook)", "208": "        unregister_hook(HookType.AFTER_ANALYSIS, my_hook)", "209": "        trigger_hook(HookType.AFTER_ANALYSIS)", "210": "", "211": "        assert len(called) == 0", "212": "", "213": "    def test_clear_global_hooks(self):", "214": "        \"\"\"Test clearing all global hooks.\"\"\"", "215": "", "216": "        def hook1(ctx: HookContext):", "217": "            pass", "218": "", "219": "        def hook2(ctx: HookContext):", "220": "            pass", "221": "", "222": "        register_hook(HookType.BEFORE_ANALYSIS, hook1)", "223": "        register_hook(HookType.AFTER_ANALYSIS, hook2)", "224": "", "225": "        clear_hooks()", "226": "", "227": "        manager = get_global_manager()", "228": "        for hooks_list in manager.hooks.values():", "229": "            assert len(hooks_list) == 0", "230": "", "231": "    def test_multiple_registrations_same_function(self):", "232": "        \"\"\"Test registering the same function multiple times.\"\"\"", "233": "        called = []", "234": "", "235": "        def my_hook(ctx: HookContext):", "236": "            called.append(True)", "237": "", "238": "        register_hook(HookType.ON_DUPLICATE_FOUND, my_hook)", "239": "        register_hook(HookType.ON_DUPLICATE_FOUND, my_hook)  # Register again", "240": "", "241": "        trigger_hook(HookType.ON_DUPLICATE_FOUND)", "242": "", "243": "        # Function should be called twice", "244": "        assert len(called) == 2", "245": "", "246": "    def test_hook_with_data(self):", "247": "        \"\"\"Test hooks receive correct data.\"\"\"", "248": "        received_data = []", "249": "", "250": "        def my_hook(ctx: HookContext):", "251": "            received_data.append(ctx.data)", "252": "", "253": "        register_hook(HookType.ON_DUPLICATE_FOUND, my_hook)", "254": "        trigger_hook(", "255": "            HookType.ON_DUPLICATE_FOUND,", "256": "            test1=\"test_login_1\",", "257": "            test2=\"test_login_2\",", "258": "            similarity=1.0,", "259": "        )", "260": "", "261": "        assert len(received_data) == 1", "262": "        assert received_data[0][\"test1\"] == \"test_login_1\"", "263": "        assert received_data[0][\"test2\"] == \"test_login_2\"", "264": "        assert received_data[0][\"similarity\"] == 1.0", "265": "", "266": "", "267": "class TestPluginIntegration:", "268": "    \"\"\"Integration tests for plugin system.\"\"\"", "269": "", "270": "    def test_complete_workflow(self):", "271": "        \"\"\"Test a complete workflow with multiple hooks.\"\"\"", "272": "        events = []", "273": "", "274": "        def before_hook(ctx: HookContext):", "275": "            events.append(\"before\")", "276": "", "277": "        def after_hook(ctx: HookContext):", "278": "            events.append(\"after\")", "279": "", "280": "        def duplicate_hook(ctx: HookContext):", "281": "            events.append(f\"duplicate: {ctx.data.get('count', 0)}\")", "282": "", "283": "        # Register hooks", "284": "        register_hook(HookType.BEFORE_ANALYSIS, before_hook)", "285": "        register_hook(HookType.AFTER_ANALYSIS, after_hook)", "286": "        register_hook(HookType.ON_DUPLICATE_FOUND, duplicate_hook)", "287": "", "288": "        # Simulate analysis workflow", "289": "        trigger_hook(HookType.BEFORE_ANALYSIS)", "290": "        trigger_hook(HookType.ON_DUPLICATE_FOUND, count=5)", "291": "        trigger_hook(HookType.ON_DUPLICATE_FOUND, count=3)", "292": "        trigger_hook(HookType.AFTER_ANALYSIS)", "293": "", "294": "        assert events == [", "295": "            \"before\",", "296": "            \"duplicate: 5\",", "297": "            \"duplicate: 3\",", "298": "            \"after\",", "299": "        ]", "300": "", "301": "    def test_conditional_hook_execution(self):", "302": "        \"\"\"Test that hooks can conditionally execute logic.\"\"\"", "303": "        high_priority_alerts = []", "304": "", "305": "        def alert_hook(ctx: HookContext):", "306": "            count = ctx.data.get(\"count\", 0)", "307": "            if count > 10:", "308": "                high_priority_alerts.append(count)", "309": "", "310": "        register_hook(HookType.ON_DUPLICATE_FOUND, alert_hook)", "311": "", "312": "        # Low count - should not alert", "313": "        trigger_hook(HookType.ON_DUPLICATE_FOUND, count=5)", "314": "        assert len(high_priority_alerts) == 0", "315": "", "316": "        # High count - should alert", "317": "        trigger_hook(HookType.ON_DUPLICATE_FOUND, count=15)", "318": "        assert len(high_priority_alerts) == 1", "319": "        assert high_priority_alerts[0] == 15"}};
        let currentData = null;
        let syncEnabled = true;
        let isScrolling = false;
        
        function showComparison(index) {
            const data = coverageData[index];
            if (!data) return;
            
            currentData = data;
            
            document.getElementById('subsetName').innerHTML = formatTestName(data.subsetName);
            document.getElementById('supersetName').innerHTML = formatTestName(data.supersetName);
            document.getElementById('coverageRatio').textContent = (data.ratio * 100).toFixed(1) + '%';
            
            // Populate file filter
            const allFiles = new Set([...Object.keys(data.subset), ...Object.keys(data.superset)]);
            const fileFilter = document.getElementById('fileFilter');
            fileFilter.innerHTML = '<option value="">All Files</option>';
            Array.from(allFiles).sort().forEach(file => {
                const option = document.createElement('option');
                option.value = file;
                option.textContent = file;
                fileFilter.appendChild(option);
            });
            
            renderBothPanels();
            
            document.getElementById('comparisonModal').style.display = 'block';
            
            // Scroll to top of the modal
            const splitView = document.querySelector('.split-view');
            if (splitView) {
                splitView.scrollTop = 0;
            }
        }
        
        function renderBothPanels() {
            const selectedFile = document.getElementById('fileFilter').value;
            
            // Get all unique files from both sides
            const subsetFiles = Object.keys(currentData.subset).sort();
            const supersetFiles = Object.keys(currentData.superset).sort();
            const allFiles = [...new Set([...subsetFiles, ...supersetFiles])].sort();
            
            // Apply file filter
            const filesToRender = selectedFile ? [selectedFile] : allFiles;
            
            let subsetHtml = '';
            let supersetHtml = '';
            
            for (const file of filesToRender) {
                const subsetLines = currentData.subset[file] || [];
                const supersetLines = currentData.superset[file] || [];
                
                // Get all unique line numbers from both sides
                let allLineNums = [...new Set([...subsetLines, ...supersetLines])].sort((a, b) => a - b);
                
                if (allLineNums.length === 0) continue;
                
                const subsetLineSet = new Set(subsetLines);
                const supersetLineSet = new Set(supersetLines);
                const fileSource = sourceCode[file] || {};
                
                // Find and include method/class definitions for context
                const minLine = Math.min(...allLineNums);
                const maxLine = Math.max(...allLineNums);
                const contextLines = new Set(allLineNums);
                
                // Scan backwards from each covered line to find def/class
                for (const lineNum of allLineNums) {
                    for (let i = lineNum - 1; i >= Math.max(1, minLine - 20); i--) {
                        const line = fileSource[i] || '';
                        const trimmed = line.trim();
                        if (trimmed.startsWith('def ') || trimmed.startsWith('class ') || trimmed.startsWith('async def ')) {
                            contextLines.add(i);
                            break;
                        }
                        // Stop if we hit another definition or empty line followed by def
                        if (trimmed === '' && i < lineNum - 5) break;
                    }
                }
                
                // Convert back to sorted array
                allLineNums = Array.from(contextLines).sort((a, b) => a - b);
                
                // Add file headers
                subsetHtml += '<div class="file-section" style="margin-bottom: 30px;">';
                subsetHtml += '<div class="file-path">üìÑ ' + escapeHtml(file) + '</div>';
                
                supersetHtml += '<div class="file-section" style="margin-bottom: 30px;">';
                supersetHtml += '<div class="file-path">üìÑ ' + escapeHtml(file) + '</div>';
                
                // Render each line with gap detection
                let prevLineNum = null;
                for (let idx = 0; idx < allLineNums.length; idx++) {
                    const lineNum = allLineNums[idx];
                    const sourceLine = fileSource[lineNum] || '';
                    const trimmed = sourceLine.trim();
                    
                    // Skip docstrings
                    if (trimmed.startsWith('"""') || trimmed.startsWith("'''")) {
                        continue;
                    }
                    
                    // Handle gap between lines
                    if (prevLineNum !== null && lineNum - prevLineNum > 1) {
                        const gap = lineNum - prevLineNum - 1;
                        const gapStart = prevLineNum + 1;
                        const gapEnd = lineNum - 1;
                        
                        if (gap > 3) {
                            // Show collapsible gap for >3 lines
                            const gapId = 'gap_' + file.replace(/[^a-zA-Z0-9]/g, '_') + '_' + gapStart + '_' + gapEnd;
                            const gapText = '‚ãÆ (' + gap + ' line' + (gap > 1 ? 's' : '') + ') ‚ãÆ Click to expand';
                            
                            subsetHtml += '<div class="code-line gap-line" style="color: #00c6ff; text-align: center; font-style: italic; background: #f0f0f0; cursor: pointer; padding: 8px;" ';
                            subsetHtml += 'data-gap-id="' + gapId + '" data-gap-start="' + gapStart + '" data-gap-end="' + gapEnd + '" data-file="' + escapeHtml(file) + '" ';
                            subsetHtml += 'onclick="toggleGap(this, \'subset\')" title="Click to view hidden lines">';
                            subsetHtml += '<strong>' + gapText + '</strong>';
                            subsetHtml += '</div>';
                            
                            supersetHtml += '<div class="code-line gap-line" style="color: #00c6ff; text-align: center; font-style: italic; background: #f0f0f0; cursor: pointer; padding: 8px;" ';
                            supersetHtml += 'data-gap-id="' + gapId + '" data-gap-start="' + gapStart + '" data-gap-end="' + gapEnd + '" data-file="' + escapeHtml(file) + '" ';
                            supersetHtml += 'onclick="toggleGap(this, \'superset\')" title="Click to view hidden lines">';
                            supersetHtml += '<strong>' + gapText + '</strong>';
                            supersetHtml += '</div>';
                        } else {
                            // Show lines if gap is 3 or less
                            for (let gapLine = gapStart; gapLine <= gapEnd; gapLine++) {
                                const gapSource = fileSource[gapLine] || '';
                                const gapLineNumStr = String(gapLine).padStart(4, ' ');
                                
                                subsetHtml += '<div class="code-line" style="opacity: 0.4; background: #fafafa;">';
                                subsetHtml += '<span style="color: #bbb; margin-right: 10px;">' + gapLineNumStr + '</span>';
                                subsetHtml += '<span style="color: #aaa;">' + escapeHtml(gapSource) + '</span>';
                                subsetHtml += '</div>';
                                
                                supersetHtml += '<div class="code-line" style="opacity: 0.4; background: #fafafa;">';
                                supersetHtml += '<span style="color: #bbb; margin-right: 10px;">' + gapLineNumStr + '</span>';
                                supersetHtml += '<span style="color: #aaa;">' + escapeHtml(gapSource) + '</span>';
                                supersetHtml += '</div>';
                            }
                        }
                    }
                    
                    prevLineNum = lineNum;
                    const lineNumStr = String(lineNum).padStart(4, ' ');
                    const isDefLine = trimmed.startsWith('def ') || trimmed.startsWith('class ') || trimmed.startsWith('async def ');
                    
                    // Render left side (subset)
                    if (subsetLineSet.has(lineNum)) {
                        subsetHtml += '<div class="code-line covered">';
                        subsetHtml += '<span style="color: #999; margin-right: 10px;">' + lineNumStr + '</span>';
                        subsetHtml += escapeHtml(sourceLine) || '‚ñå Covered line';
                        subsetHtml += '</div>';
                    } else if (isDefLine) {
                        // Show def/class lines as context
                        subsetHtml += '<div class="code-line" style="background: #e8f4f8; font-weight: 600;">';
                        subsetHtml += '<span style="color: #999; margin-right: 10px;">' + lineNumStr + '</span>';
                        subsetHtml += escapeHtml(sourceLine);
                        subsetHtml += '</div>';
                    } else {
                        // Show blank line to maintain alignment
                        subsetHtml += '<div class="code-line" style="opacity: 0.3;">';
                        subsetHtml += '<span style="color: #999; margin-right: 10px;">' + lineNumStr + '</span>';
                        subsetHtml += '<span style="color: #ccc;">‚Äî</span>';
                        subsetHtml += '</div>';
                    }
                    
                    // Render right side (superset)
                    if (supersetLineSet.has(lineNum)) {
                        supersetHtml += '<div class="code-line covered">';
                        supersetHtml += '<span style="color: #999; margin-right: 10px;">' + lineNumStr + '</span>';
                        supersetHtml += escapeHtml(sourceLine) || '‚ñå Covered line';
                        supersetHtml += '</div>';
                    } else if (isDefLine) {
                        // Show def/class lines as context
                        supersetHtml += '<div class="code-line" style="background: #e8f4f8; font-weight: 600;">';
                        supersetHtml += '<span style="color: #999; margin-right: 10px;">' + lineNumStr + '</span>';
                        supersetHtml += escapeHtml(sourceLine);
                        supersetHtml += '</div>';
                    } else {
                        // Show blank line to maintain alignment
                        supersetHtml += '<div class="code-line" style="opacity: 0.3;">';
                        supersetHtml += '<span style="color: #999; margin-right: 10px;">' + lineNumStr + '</span>';
                        supersetHtml += '<span style="color: #ccc;">‚Äî</span>';
                        supersetHtml += '</div>';
                    }
                }
                
                subsetHtml += '</div>';
                supersetHtml += '</div>';
            }
            
            document.getElementById('subsetContent').innerHTML = subsetHtml || '<p style="padding: 20px; color: #7f8c8d;">No coverage data</p>';
            document.getElementById('supersetContent').innerHTML = supersetHtml || '<p style="padding: 20px; color: #7f8c8d;">No coverage data</p>';
        }
        
        function applyFileFilter() {
            renderBothPanels();
        }
        
        function toggleSync() {
            syncEnabled = !syncEnabled;
            const checkbox = document.getElementById('syncCheckbox');
            const toggle = document.getElementById('syncToggle');
            const splitView = document.querySelector('.split-view');
            const filePanels = document.querySelectorAll('.file-panel');
            
            checkbox.checked = syncEnabled;
            if (syncEnabled) {
                toggle.classList.add('active');
                // Use single scroll - both panels scroll together
                splitView.classList.remove('independent');
                filePanels.forEach(panel => panel.classList.remove('independent'));
            } else {
                toggle.classList.remove('active');
                // Enable independent scrolling for each panel
                splitView.classList.add('independent');
                filePanels.forEach(panel => panel.classList.add('independent'));
            }
        }
        
        function toggleGap(element, side) {
            const gapId = element.getAttribute('data-gap-id');
            const gapStart = parseInt(element.getAttribute('data-gap-start'));
            const gapEnd = parseInt(element.getAttribute('data-gap-end'));
            const file = element.getAttribute('data-file');
            
            // Find the corresponding gap in the other panel
            const otherSide = side === 'subset' ? 'superset' : 'subset';
            const otherContent = document.getElementById(otherSide + 'Content');
            const otherGap = otherContent.querySelector('.gap-line[data-gap-id="' + gapId + '"]');
            
            // Check if already expanded
            const isExpanded = element.classList.contains('expanded');
            
            if (isExpanded) {
                // Collapse both sides
                const expandedLines = element.parentElement.querySelectorAll('.expanded-line[data-gap-id="' + gapId + '"]');
                expandedLines.forEach(line => line.remove());
                element.classList.remove('expanded');
                element.innerHTML = '<strong>‚ãÆ (' + (gapEnd - gapStart + 1) + ' line' + (gapEnd - gapStart > 0 ? 's' : '') + ') ‚ãÆ Click to expand</strong>';
                
                // Collapse other side
                if (otherGap) {
                    const otherExpandedLines = otherGap.parentElement.querySelectorAll('.expanded-line[data-gap-id="' + gapId + '"]');
                    otherExpandedLines.forEach(line => line.remove());
                    otherGap.classList.remove('expanded');
                    otherGap.innerHTML = '<strong>‚ãÆ (' + (gapEnd - gapStart + 1) + ' line' + (gapEnd - gapStart > 0 ? 's' : '') + ') ‚ãÆ Click to expand</strong>';
                }
            } else {
                // Expand both sides
                const fileSource = sourceCode[file] || {};
                element.classList.add('expanded');
                element.innerHTML = '<strong>‚ãÆ Click to collapse ‚ãÆ</strong>';
                
                let insertHtml = '';
                for (let lineNum = gapStart; lineNum <= gapEnd; lineNum++) {
                    const sourceLine = fileSource[lineNum] || '';
                    const lineNumStr = String(lineNum).padStart(4, ' ');
                    
                    insertHtml += '<div class="code-line expanded-line" data-gap-id="' + gapId + '" style="opacity: 0.6; background: #f9f9f9; border-left: 3px solid #00c6ff;">';
                    insertHtml += '<span style="color: #aaa; margin-right: 10px;">' + lineNumStr + '</span>';
                    insertHtml += '<span style="color: #666;">' + escapeHtml(sourceLine) + '</span>';
                    insertHtml += '</div>';
                }
                
                // Insert after the gap element on current side
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = insertHtml;
                while (tempDiv.firstChild) {
                    element.parentNode.insertBefore(tempDiv.firstChild, element.nextSibling);
                }
                
                // Expand other side
                if (otherGap) {
                    otherGap.classList.add('expanded');
                    otherGap.innerHTML = '<strong>‚ãÆ Click to collapse ‚ãÆ</strong>';
                    
                    const tempDiv2 = document.createElement('div');
                    tempDiv2.innerHTML = insertHtml;
                    while (tempDiv2.firstChild) {
                        otherGap.parentNode.insertBefore(tempDiv2.firstChild, otherGap.nextSibling);
                    }
                }
            }
        }
        
        function closeModal() {
            document.getElementById('comparisonModal').style.display = 'none';
            currentData = null;
        }
        
        window.onclick = function(event) {
            const modal = document.getElementById('comparisonModal');
            if (event.target == modal) {
                closeModal();
            }
        }
        
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeModal();
            }
        });
        
        // Format all test names on page load
        document.addEventListener('DOMContentLoaded', function() {
            const testNames = document.querySelectorAll('.test-name');
            testNames.forEach(el => {
                const originalText = el.textContent;
                if (originalText.includes('::')) {
                    el.innerHTML = formatTestName(originalText);
                }
            });
        });
        </script>
        
        <div class="footer">
            <p>Generated by <strong>TestIQ</strong> - Intelligent Test Analysis</p>
            <p>üîó <a href="https://github.com/pydevtools/TestIQ" style="color: #00c6ff;">github.com/pydevtools/TestIQ</a></p>
        </div>
    </div>
</body>
</html>
